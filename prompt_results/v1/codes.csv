case_no,code_token
1,"import java.util.Arrays;
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		new Main().solve();
	}
	
	void solve(){
		Scanner sc=new Scanner(System.in);
		int n=sc.nextInt();
		int m=sc.nextInt();
		int[] x=new int[m];
		int[] y=new int[m];
		int[] BallCount=new int[n+1];
		boolean[] poss=new boolean[n+1];
		
		for(int i=0;i<m;i++){
			x[i]=sc.nextInt();
			y[i]=sc.nextInt();
		}
		Arrays.fill(poss, false);
		poss[1]=true;
		Arrays.fill(BallCount, 1);
		for(int i=0;i<m;i++){
			
			if(poss[x[i]])poss[y[i]]=true;
			
			BallCount[x[i]]-=1;
			BallCount[y[i]]+=1;
			
			if(BallCount[x[i]]==0)poss[x[i]]=false;
			
		}
		int BallBox=0;
		for(int i=1;i<=n;i++){
			if(poss[i])BallBox++;
		}
		System.out.println(BallBox);
		
	}

}
"
2,"#include <bits/stdc++.h>
 
using namespace std;
 
typedef long long ll;
typedef long double ld;
typedef pair < int , pair < int , int > > mp;

#define rep(i , j , n) for(long long i = j ; i <= n ; i++)
#define per(i , j , n) for(long long i = j ; i >= n ; i--)
 
const ll N = 123456;
const ll mod = 1e9 + 7;
const ld eps = 1e-6;
const ld pi = 3.1415926535;

int a[N];
int vis[N];
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
 
    cout << fixed << setprecision(12);

    int n;

    int k;

    cin >> n >> k;

    string s;
    cin >> s;

    rep(i , 1 , n) {
      if(s[i - 1] == 'L') {
        a[i] = 1;
      }
      else {
        a[i] = -1;
      }
    }

    // rep(i , 1 , n) {
    //   a[i] += a[i - 1];
    // }

    // rep(i , 1 , n) {
    //   cout << a[i] << "" "";
    // }

    // cout << endl;

    int sum = 0;

    int cur = 1;
    if(n == 1) {
      cout << 0 << endl;
      return 0;
    }

    vector < int > res;

    // rep(i , 1 , n) {
    //     cout << a[i] << endl;
    // }
    rep(i , 2 , n) {
        if(a[i] == a[i - 1]) {
            //cout << a[i - 1] << "" "" << a[i] << endl;
            cur++;
        }
        else {
            res.push_back(cur);
            cur = 1;
        }
    }

    res.push_back(cur);

    for(auto j : res) {
        sum += j - 1;
    }

    while(k--) {
        sum += 2;
    }
    cout << min(sum , n - 1) << endl;
    return 0;

}
"
3,"import java.io.*;
public class Main{
	public static void main(String[] args){
		
InputStreamReader is = new InputStreamReader(System.in);

        BufferedReader br = new BufferedReader(is);

        String str = br.readLine();
		
		int x = Integer.parseInt(str);
		
		System.out.println(x*x*x);
	}
}"
4,"
import java.util.Scanner;
import java.util.stream.LongStream;

public class Main {
    static int n;
    static int W;
    static long[][] dp;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        W = sc.nextInt();
        dp = new long[n + 1][1000 * n + 1];
        for (int i = 0; i < n+1; i++) {
            for (int j = 1; j < dp[i].length; j++) {
                dp[i][j] = Integer.MAX_VALUE * 10L;
            }
        }
        for (int i = 0; i < n; i++) {
            int w = sc.nextInt();
            int v = sc.nextInt();
            dp[i + 1][v] = Math.min(w, dp[i][v]);
            for (int j = 0; j < v; j++) {
                dp[i + 1][j] = dp[i][j];
            }
            for (int j = v; j < dp[0].length; j++) {
                dp[i + 1][j] = Math.min(dp[i][j], dp[i][j - v] + w);
            }


        }
        int max = 0;
        for (int i = 0; i < dp[n].length; i++) {
            if (dp[n][i] <= W) max = i;
        }
        System.out.println(max);
    }

}
"
5,"import java.util.Scanner;
 
 static int calc(int num) {
  if (400 =< num =< 599) {
    System.out.println(8);
  } else if (600 =< num =< 799) {
    System.out.println(7);
  } else if (800 =< num =< 999) {
    System.out.println(6);
  } else if (1000 =< num =< 1199) {
    System.out.println(5);
  } else if (1200 =< num =< 1399) {
    System.out.println(4);
  } else if (1400 =< num =< 1599) {
    System.out.println(3);
  } else if (1600 =< num =< 1799) {
    System.out.println(2);
  } else if (1800 =< num =< 1999) {
    System.out.println(1);
  }
  public static void main (String[] args) {
    Scanner stdIn = new Scanner(System.in);
    int num stdIn.nextInt();
    
    calc(num);
  }
}"
6,"
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		new Main().run();
	}

	private void run() {
		Scanner scanner = new Scanner(System.in);
		int n = scanner.nextInt();
		int[] num = new int[n];
		int s = 0;
		for (int i = 0; i < n; i++) {
			num[i] = scanner.nextInt();
			s += num[i];
		}
		boolean[] map = new boolean[s + 1];

		slove(0, 0, num, map);
		int m = scanner.nextInt();
		while (m-- > 0) {
			int a = scanner.nextInt();
			System.out.println(a <= s && map[a] ? ""yes"" : ""no"");
		}

	}

	private void slove(int i, int sum, int[] num, boolean[] map) {
		map[sum] = true;
		if (i == num.length)
			return;

		slove(i + 1, sum + num[i], num, map);
		slove(i + 1, sum, num, map);
	}
}"
7,"import java.util.Scanner;
public class Main{
  public static void main(String[] args){
	Scanner sc = new Scanner(System.in);
    int K = Integer.parseInt(sc.next());
    int S = Integer.parseInt(sc.next());
    int count = 0;
    int z = 0;
    
    //K以下の自然数X,Y,Zの合計がSとなる組み合わせは何通りあるか
    for(int x = 0; x <=K; x++){
      for(int y = 0; y <=K; y++){
        z = S - x - y;
       if(z >= 0 && z <= K) count++;
      }
    }   
    System.out.println(count);      
  }
}"
8,"import java.util.Scanner;
public class Main{
    public static void main(String[]args){
	Scanner sc=new Scanner(System.in);

	int a=sc.nextInt();
	int b=sc.nextInt();
	if(a<b){
	    System.out.println(""a<b"");
	}
	if(a>b){
	    System.out.println(""a>b"");
	}
	if (a==b){
    System.out.println(""a==b"");
	}



}"
9,"import java.util.Scanner;
public class Test {
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);

		String a = sc.next();

		String b = sc.next();
		String c= a+b;
    double d =	Integer.parseInt(c);
		double e = Math.floor(Math.sqrt(d));
		if (d-(e*e)==0){
			System.out.println(""Yes"");
		}else{
			System.out.println(""No"");
		}
	}
}
"
10,"import java.util.Scanner;
public class Main {
	public static void main(String[] args){
		Scanner as = new Scanner(System.in);
		String a = as.next();
		boolean b = true;
		try{
		for(int i=0;i<a.length();i++){
			if(b){
				if(String.valueOf(a.charAt(i)).equals(""d"")){
					i++;
					if(String.valueOf(a.charAt(i)).equals(""r"")){
						i++;
						if(String.valueOf(a.charAt(i)).equals(""e"")){
							i++;
							if(String.valueOf(a.charAt(i)).equals(""a"")){
								i++;
								if(String.valueOf(a.charAt(i)).equals(""m"")){
									if(i+1<a.length()&&String.valueOf(a.charAt(i+1)).equals(""e"")
											&&String.valueOf(a.charAt(i+2)).equals(""r"")){
										if(i+3<a.length()&&(String.valueOf(a.charAt(i+3)).equals(""d"")
												||String.valueOf(a.charAt(i+3)).equals(""e""))){
											i+=2;
										}else if(i+3<a.length()&&String.valueOf(a.charAt(i+3)).equals(""a"")){
											
										}else if(i+3>=a.length()){
											i+=3;
										}
									}else if(i+1>=a.length()){
										
									}
								}else{
									b = false;
								}
							}else{
								b = false;
							}
						}else{
							b = false;
						}
					}else{
						b = false;
					}
				}else if(String.valueOf(a.charAt(i)).equals(""e"")){
					i++;
					if(String.valueOf(a.charAt(i)).equals(""r"")){
						i++;
						if(String.valueOf(a.charAt(i)).equals(""a"")){
							i++;
							if(String.valueOf(a.charAt(i)).equals(""s"")){
								i++;
								if(String.valueOf(a.charAt(i)).equals(""e"")){
									if(i+1<a.length()&&String.valueOf(a.charAt(i+1)).equals(""r"")){
										i++;
									}else if(i+1>=a.length()){
										
									}
								}else{
									b = false;
								}
							}else{
								b = false;
							}
						}else{
							b = false;
						}
					}else{
						b = false;
					}
				}else{
					b = false;
				}
			}else{
				break;
			}
		}
		}catch(Exception e){
			b = false;
		}
		if(b){
			System.out.println(""YES"");
		}else{
			System.out.println(""NO"");
		}
	}
}"
11,"
import java.util.Scanner;

public class Main {
	static Scanner sc = new Scanner(System.in);

	//３文字目以降の探索
	//引数のnはターゲットの看板のどこを探索しているか
	//引数のpadは隙間
	static boolean paddingcheck(String tar,String str,int n,int pad){
		boolean f=false;
		for(int i=2;i<tar.length();i++){
			if(n+i*pad>=str.length()){f=false;break;}//
			if(tar.charAt(i)==str.charAt(n+i*pad))f = true;
			else {
				f = false;
				break;
			}
		}

		return f;
	}
	//２つの引数の文字列で看板が作れるかどうか判定するクラスメソッド
	static boolean search(String tar , String str){
		boolean f = false;
		for(int j=0;j<str.length();j++){
			if(tar.equals(str))return true;
			if(tar.charAt(0)==str.charAt(j)){
				int cnt=0;
				for(int i=j+1;i<str.length();i++){
					cnt++;
					if(str.length()<j+cnt)continue;
					if(tar.charAt(1)==str.charAt(i)){
						if((j+tar.length()-1*cnt)>str.length())break;//
						f = paddingcheck(tar,str,j,cnt);
						if(f==true) return f;
					}
				}
			}
		}		
		return f;
	}
	
	void doIt(){//クラス変数scに対しての操作を決めるメソッド
		int n = sc.nextInt();
		int ans = 0;
		String tar = sc.next();
		for(int i=0;i<n;++i){
			String s = sc.next();
			if(search(tar,s))ans++;
		}
		System.out.println(ans);
	}

	public static void main(String[] args) {
		new Main().doIt();
	}

}"
12,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

	public static void main(String[] args) throws IOException {
		// TODO ?????????????????????????????????????????????
		BufferedReader insBR = new BufferedReader(new InputStreamReader(System.in));
		
		//?????????????????????????´?????????????
		int[] aryDice = new int[6];
		//????????????????????????
		String[] ary = insBR.readLine().split("" "");
		//int???????????????????????£??\
		for(int i = 0; i < ary.length; i++){
			aryDice[i] = Integer.parseInt(ary[i]);
		}
		 
		//????????????????????????(?????????1????????\?????????)
		String[] aryDirection = insBR.readLine().split("""");
		//Dice ????????????????????????
		Dice dice = new Dice();
		//??????????????????????????????????????????
		dice.setAryDice(aryDice);
		for(int i = 0; i < aryDirection.length; i++){
			 dice.roll(aryDirection[i]);
		}
		aryDice = dice.getAryDice();
		//System.out.print(""diceTop:"");
		System.out.println(aryDice[0]);
	}

////?????????????????????????????????	
	static class Dice {
		
		//?????£?????????
		
		//???????????????????????????????????????????´?????????????
		private int [] aryDice = new int[6];
		
		//?????????????????????Dice
		Dice(){
		}
		//Method ????§?????????°??§??????????????????????????????????????????
		public void roll(String direction){
			//??£??\?????????????????¨??????????????¨
			int temp = 0;
			if(""S"".equals(direction)){
				temp = aryDice[0];
				aryDice[0] = aryDice[4];
				aryDice[4] = aryDice[5];
				aryDice[5] = aryDice[1];
				aryDice[1] = temp;
			}else if(""E"".equals(direction)){
				temp = aryDice[0];
				aryDice[0] = aryDice[3];
				aryDice[3] = aryDice[5];
				aryDice[5] = aryDice[2];
				aryDice[2] = temp;
			}else if(""W"".equals(direction)){
				temp = aryDice[0];
				aryDice[0] = aryDice[2];
				aryDice[2] = aryDice[5];
				aryDice[5] = aryDice[3];
				aryDice[3] = temp;
			}else if(""N"".equals(direction)){
				temp = aryDice[0];
				aryDice[0] = aryDice[1];
				aryDice[1] = aryDice[5];
				aryDice[5] = aryDice[4];
				aryDice[4] = temp;
			}
		
		}
		//Method set get
		public int[] getAryDice() {
			return aryDice;
		}
		public void setAryDice(int[] aryDice) {
			this.aryDice = aryDice;
		}
		
	}//??????????????????
}"
13,"/**
 * Created by abhishek on 7/31/2016.
 */
import java.util.*;
import java.io.*;
public class A {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        long l = Integer.parseInt(st.nextToken());
        long array[] = new long[n + 1];
        int node = -1;
        st = new StringTokenizer(br.readLine());
        for (int i = 1; i <= n; i++) {
            array[i] = Integer.parseInt(st.nextToken());
            if (i == 1) continue;
            if (array[i] + array[i - 1] >= l) {
                node = i;
            }
        }
        if (node == -1) {
            System.out.println(""Impossible"");
            return;
        }
        System.out.println(""Possible"");
        StringBuilder sb = new StringBuilder();
        for (int i = 1; i < node - 1; i++) {
            sb.append(i);
            sb.append('\n');
        }
        for(int i = n - 1;i >= node;i++){
            sb.append(i);
            sb.append('\n');
        }
        sb.append(node - 1);
        System.out.println(sb);
    }
}
"
14,"import java.util.*;
import java.lang.*;
import java.io.*;
import java.math.BigDecimal;

public class CB68D {
    public static void main (String[] args) throws java.lang.Exception {
        InputReader in = new InputReader(System.in);
        PrintWriter w = new PrintWriter(System.out);
        int n = 50;
        long k = in.nextLong();
        long[] a = new long[n];
        for (int i = 0; i < n; i++) {
            a[i] = i ;
        }
        for (int i = 0; i < n; i++)
            a[i] += k / n;
        for (int i = 0; i < k % n; i++) {
            a[i] += n + 1;
            for (int j = 0; j < n; j++)
                a[j]--;
        }
        for (long x : a)
            w.print(x + "" "");
        w.close();
    }

    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1)
                throw new UnknownError();
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new UnknownError();
                }
                if (numChars <= 0)
                    return -1;
            }
            return buf[curChar++];
        }

        public int peek() {
            if (numChars == -1)
                return -1;
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    return -1;
                }
                if (numChars <= 0)
                    return -1;
            }
            return buf[curChar];
        }

        public void skip(int x) {
            while (x-- > 0)
                read();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public String nextString() {
            return next();
        }

        public String next() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            StringBuffer res = new StringBuffer();
            do {
                res.appendCodePoint(c);
                c = read();
            } while (!isSpaceChar(c));

            return res.toString();
        }

        public String nextLine() {
            StringBuffer buf = new StringBuffer();
            int c = read();
            while (c != '\n' && c != -1) {
                if (c != '\r')
                    buf.appendCodePoint(c);
                c = read();
            }
            return buf.toString();
        }

        public double nextDouble() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            double res = 0;
            while (!isSpaceChar(c) && c != '.') {
                if (c == 'e' || c == 'E')
                    return res * Math.pow(10, nextInt());
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            if (c == '.') {
                c = read();
                double m = 1;
                while (!isSpaceChar(c)) {
                    if (c == 'e' || c == 'E')
                        return res * Math.pow(10, nextInt());
                    if (c < '0' || c > '9')
                        throw new InputMismatchException();
                    m /= 10;
                    res += (c - '0') * m;
                    c = read();
                }
            }
            return res * sgn;
        }
        public int[] nextIntArray(int n) {
            int[] a = new int[n];
            for (int i = 0; i < n; i++)
                a[i] = nextInt();
            return a;
        }
        public long[] nextLongArray(int n) {
            long[] a = new long[n];
            for (int i = 0; i < n; i++)
                a[i] = nextLong();
            return a;
        }
        public boolean hasNext() {
            int value;
            while (isSpaceChar(value = peek()) && value != -1)
                read();
            return value != -1;
        }

        private boolean isSpaceChar(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

    }
}"
15,"

import java.awt.Point;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.Serializable;
import java.util.AbstractList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.Locale;
import java.util.NoSuchElementException;
import java.util.PriorityQueue;
import java.util.RandomAccess;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;

public class Main implements Runnable{

	private final int INF = 1000000007; // Lより大きい値かつ2倍してもセーフな値
	private class Fuel implements Comparable<Fuel>{
		private final int supply;
		private final int fuel;
		private final int city;

		private Fuel(int city, int cost) {
			supply = 0;
			fuel = cost;
			this.city = city;
		}

		private Fuel(Fuel last, int nextCity, int edge, int L) {
			city = nextCity;
			if (last.fuel >= edge) {
				fuel = last.fuel - edge;
				supply = last.supply;
			} else {
				fuel = L - edge;
				supply = last.supply + 1;
			}
		}

		@Override
		public int compareTo(Fuel o) {
			if (o.supply != supply) return Integer.compare(supply, o.supply);
			return Integer.compare(o.fuel, fuel);
		}

		@Override
		public String toString() {
			if (supply != INF) return (city + 1) + "":"" + supply + "","" + fuel;
			return (city + 1) + "":-1:-1"";
		}
	}
	private void solve(FastIO io) {
		/*
		 * author: 31536000
		 * ABC143 E問題
		 * 考察メモ
		 * まず、各クエリについて幅優先探索することを考える
		 * これだと計算量は1回あたりO(N+M)なので全体はO(Q(N+M))、TLEするね
		 * ところで、各町について補給回数最小が望ましいね
		 * で、補給回数が同じなら燃料最大が望ましいね
		 * ということは単にそれを用いて各点から求めていけば良さそう、上の条件で最短経路なので
		 * Dijkstra法を各頂点から行うことを考える
		 * この時、ちゃんと順に定まっていくので問題なさそう
		 * 計算量はO(N(N+M)logN)、まぁ頑張れば間に合うって
		 */
		int N = io.nextInt(), M = io.nextInt(), L = io.nextInt();
		int[][] edge = new int[N][N];
		for (int[] i : edge) Arrays.fill(i, INF);
		for (int i = 0;i < M;++ i) {
			int A = io.nextInt() - 1, B = io.nextInt() - 1, C = io.nextInt();
			if (C <= L) edge[A][B] = edge[B][A] = C; // そもそも行けない辺はINFへ
		}

		/*
		 *
		 */
		Fuel[][] dp = new Fuel[N][N];
		Fuel[][] minCost = new Fuel[N][N];
		PriorityQueue<Fuel> pq = new PriorityQueue<Fuel>();
		for (int i = 0;i < N;++ i) { // この頂点について確定させていく
			pq.add(minCost[i][i] = new Fuel(i, L));
			while(!pq.isEmpty()) { // Dijkstra法
				Fuel tmp = pq.poll(); // これが最小、確定！
				if (dp[i][tmp.city] != null) continue;
				dp[i][tmp.city] = tmp;
				for (int j = 0;j < N;++ j) {
					if (edge[tmp.city][j] != INF && dp[i][j] == null) { // 移動可能かつまだ確定していない頂点
						Fuel push = new Fuel(tmp, j, edge[tmp.city][j], L);
						if (minCost[i][j] == null || minCost[i][j].compareTo(push) > 0) pq.add(minCost[i][j] = push);
					}
				}
			}
		}

		// 後はクエリにこたえる
		for (int i = 0, Q = io.nextInt();i < Q;++ i) {
			int s = io.nextInt() - 1, t = io.nextInt() - 1;
			io.println(dp[s][t] != null ? dp[s][t].supply : -1); // 移動できないなら-1
		}
	}

	/** デバッグ用コードのお供に */
	private static boolean DEBUG = false;
	/** 確保するメモリの大きさ(単位: MB)*/
	private static final long MEMORY = 64;
	private final FastIO io;

	public static void main(String[] args) {
	        Thread.setDefaultUncaughtExceptionHandler((t, e) -> e.printStackTrace());
	        new Thread(null, new Main(), """", MEMORY * 1048576).start();
	}

	public Main() {
		io = new FastIO();
		assert (DEBUG = true) | true; // yukicoderだと-eaが付いてるので正しく動かないことに注意
		if (DEBUG) {
			io.setAutoFlush(true);
			io.println(""debug mode"");
		}
	}

	@Override
	public void run() {
		solve(io);
		io.flush();
	}

	// 以下、ライブラリ

	public static class FastIO {
		private final InputStream in;
		private final byte[] buffer = new byte[1024];
		private int read = 0;
		private int length = 0;
		public final PrintWriter out;
		public final PrintWriter err;
		private boolean autoFlush = false;

		public FastIO() {
			this(System.in, System.out, System.err);
		}

		public FastIO(InputStream in, PrintStream out, PrintStream err) {
			this.in = in;
			this.out = new PrintWriter(out, false);
			this.err = new PrintWriter(err, false);
		}

		public void setAutoFlush(boolean flush) {
			autoFlush = flush;
		}

		private boolean hasNextByte() {
			if (read < length) return true;
			read = 0;
			try {
				length = in.read(buffer);
			} catch (IOException e) {
				e.printStackTrace();
			}
			return length > 0;
		}

		private int readByte() {
			return hasNextByte() ? buffer[read++] : -1;
		}

		private static boolean isPrintableChar(int c) {
			return 33 <= c && c <= 126;
		}

		private static boolean isNumber(int c) {
			return '0' <= c && c <= '9';
		}

		public boolean hasNext() {
			while (hasNextByte() && !isPrintableChar(buffer[read])) read++;
			return hasNextByte();
		}

		public char nextChar() {
			if (!hasNextByte())  throw new NoSuchElementException();
			return (char)readByte();
		}

		public char[][] nextChar(int height) {
			char[][] ret = new char[height][];
			for (int i = 0;i < ret.length;++ i) ret[i] = next().toCharArray();
			return ret;
		}

		public String next() {
			if (!hasNext()) throw new NoSuchElementException();
			StringBuilder sb = new StringBuilder();
			int b;
			while (isPrintableChar(b = readByte())) sb.appendCodePoint(b);
			return sb.toString();
		}

		public String nextLine() {
			StringBuilder sb = new StringBuilder();
			int b;
			while(!isPrintableChar(b = readByte()));
			do sb.appendCodePoint(b); while(isPrintableChar(b = readByte()) || b == ' ');
			return sb.toString();
		}

		public long nextLong() {
			if (!hasNext()) throw new NoSuchElementException();
			long n = 0;
			boolean minus = false;
			int b = readByte();
			if (b == '-') {
				minus = true;
				b = readByte();
			}
			if (!isNumber(b)) throw new NumberFormatException();
			while (true) {
				if (isNumber(b)) {
					n *= 10;
					n += b - '0';
				} else if (b == -1 || !isPrintableChar(b)) return minus ? -n : n;
				else throw new NumberFormatException();
				b = readByte();
			}
		}

		public int nextInt() {
			long nl = nextLong();
			if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
			return (int) nl;
		}

		public double nextDouble() {
			return Double.parseDouble(next());
		}

		public int[] nextInt(int width) {
			int[] ret = new int[width];
			for (int i = 0;i < width;++ i) ret[i] = nextInt();
			return ret;
		}

		public int[] nextInts() {
			return nextInts("" "");
		}

		public int[] nextInts(String parse) {
			String[] get = nextLine().split(parse);
			int[] ret = new int[get.length];
			for (int i = 0;i < ret.length;++ i) ret[i] = Integer.valueOf(get[i]);
			return ret;
		}

		public long[] nextLong(int width) {
			long[] ret = new long[width];
			for (int i = 0;i < width;++ i) ret[i] = nextLong();
			return ret;
		}

		public long[] nextLongs() {
			return nextLongs("" "");
		}

		public long[] nextLongs(String parse) {
			String[] get = nextLine().split(parse);
			long[] ret = new long[get.length];
			for (int i = 0;i < ret.length;++ i) ret[i] = Long.valueOf(get[i]);
			return ret;
		}

		public int[][] nextInt(int width, int height) {
			int[][] ret = new int[height][width];
			for (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[i][j] = nextInt();
			return ret;
		}

		public long[][] nextLong(int width, int height) {
			long[][] ret = new long[height][width];
			for (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[j][i] = nextLong();
			return ret;
		}

		public boolean[] nextBoolean(char T) {
			char[] s = next().toCharArray();
			boolean[] ret = new boolean[s.length];
			for (int i = 0;i < ret.length;++ i) ret[i] = s[i] == T;
			return ret;
		}

		public boolean[][] nextBoolean(char T, int height) {
			boolean[][] ret = new boolean[height][];
			for (int i = 0;i < ret.length;++ i) {
				char[] s = next().toCharArray();
				ret[i] = new boolean[s.length];
				for (int j = 0;j < ret[i].length;++ j) ret[i][j] = s[j] == T;
			}
			return ret;
		}

		public Point nextPoint() {
			return new Point(nextInt(), nextInt());
		}

		public Point[] nextPoint(int width) {
			Point[] ret = new Point[width];
			for (int i = 0;i < width;++ i) ret[i] = nextPoint();
			return ret;
		}

		@Override
		protected void finalize() throws Throwable {
			try {
				super.finalize();
			} finally {
				in.close();
				out.close();
				err.close();
			}
		}

		public boolean print(boolean b) {
			out.print(b);
			if (autoFlush) flush();
			return b;
		}

		public Object print(boolean b, Object t, Object f) {
			return b ? print(t) : print(f);
		}

		public char print(char c) {
			out.print(c);
			if (autoFlush) flush();
			return c;
		}

		public char[] print(char[] s) {
			out.print(s);
			return s;
		}

		public double print(double d) {
			out.print(d);
			if (autoFlush) flush();
			return d;
		}

		public double print(double d, int length) {
			if (d < 0) {
				out.print('-');
				d = -d;
			}
			d += Math.pow(10, -length) / 2;
			out.print((long)d);
			out.print('.');
			d -= (long)d;
			for (int i = 0;i < length;++ i) {
				d *= 10;
				out.print((int)d);
				d -= (int)d;
			}
			if (autoFlush) flush();
			return d;
		}

		public float print(float f) {
			out.print(f);
			if (autoFlush) flush();
			return f;
		}

		public int print(int i) {
			out.print(i);
			if (autoFlush) flush();
			return i;
		}

		public long print(long l) {
			out.print(l);
			if (autoFlush) flush();
			return l;
		}

		public Object print(Object obj) {
			if (obj.getClass().isArray()) {
				if (obj instanceof boolean[][]) print(obj, ""\n"", "" "");
				else if (obj instanceof byte[][]) print(obj, ""\n"", "" "");
				else if (obj instanceof short[][]) print(obj, ""\n"", "" "");
				else if (obj instanceof int[][]) print(obj, ""\n"", "" "");
				else if (obj instanceof long[][]) print(obj, ""\n"", "" "");
				else if (obj instanceof float[][]) print(obj, ""\n"", "" "");
				else if (obj instanceof double[][]) print(obj, ""\n"", "" "");
				else if (obj instanceof char[][]) print(obj, ""\n"", "" "");
				else if (obj instanceof Object[][]) print(obj, ""\n"", "" "");
				else print(obj, "" "");
			} else {
				out.print(obj);
				if (autoFlush) flush();
			}
			return obj;
		}

		public String print(String s) {
			out.print(s);
			if (autoFlush) flush();
			return s;
		}

		public Object print(Object array, String... parse) {
			print(array, 0, parse);
			if (autoFlush) flush();
			return array;
		}

		private Object print(Object array, int check, String... parse) {
			if (check >= parse.length) {
				if (array.getClass().isArray()) throw new IllegalArgumentException(""not equal dimension"");
				print(array);
				return array;
			}
			String str = parse[check];
			if (array instanceof Object[]) {
				Object[] obj = (Object[]) array;
				if (obj.length == 0) return array;
				print(obj[0], check + 1, parse);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i], check + 1, parse);
				}
				return array;
			}
			if (array instanceof Collection) {
				Iterator<?> iter = ((Collection<?>)array).iterator();
				if (!iter.hasNext()) return array;
				print(iter.next(), check + 1, parse);
				while(iter.hasNext()) {
					print(str);
					print(iter.next(), check + 1, parse);
				}
				return array;
			}
			if (!array.getClass().isArray()) throw new IllegalArgumentException(""not equal dimension"");
			if (check != parse.length - 1) throw new IllegalArgumentException(""not equal dimension"");
			if (array instanceof boolean[]) {
				boolean[] obj = (boolean[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else if (array instanceof byte[]) {
				byte[] obj = (byte[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
				return array;
			} else if (array instanceof short[]) {
				short[] obj = (short[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else if (array instanceof int[]) {
				int[] obj = (int[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else if (array instanceof long[]) {
				long[] obj = (long[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else if (array instanceof float[]) {
				float[] obj = (float[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else if (array instanceof double[]) {
				double[] obj = (double[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else if (array instanceof char[]) {
				char[] obj = (char[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else throw new AssertionError();
			return array;
		}

		public Object[] print(String parse, Object... args) {
			print(args[0]);
			for (int i = 1;i < args.length;++ i) {
				print(parse);
				print(args[i]);
			}
			return args;
		}

		public Object[] printf(String format, Object... args) {
			out.printf(format, args);
			if (autoFlush) flush();
			return args;
		}

		public Object printf(Locale l, String format, Object... args) {
			out.printf(l, format, args);
			if (autoFlush) flush();
			return args;
		}

		public void println() {
			out.println();
			if (autoFlush) flush();
		}

		public boolean println(boolean b) {
			out.println(b);
			if (autoFlush) flush();
			return b;
		}

		public Object println(boolean b, Object t, Object f) {
			return b ? println(t) : println(f);
		}

		public char println(char c) {
			out.println(c);
			if (autoFlush) flush();
			return c;
		}

		public char[] println(char[] s) {
			out.println(s);
			if (autoFlush) flush();
			return s;
		}

		public double println(double d) {
			out.println(d);
			if (autoFlush) flush();
			return d;
		}

		public double println(double d, int length) {
			print(d, length);
			println();
			return d;
		}

		public float println(float f) {
			out.println(f);
			if (autoFlush) flush();
			return f;
		}

		public int println(int i) {
			out.println(i);
			if (autoFlush) flush();
			return i;
		}

		public long println(long l) {
			out.println(l);
			if (autoFlush) flush();
			return l;
		}

		public Object println(Object obj) {
			print(obj);
			println();
			return obj;
		}

		public String println(String s) {
			out.println(s);
			if (autoFlush) flush();
			return s;
		}

		public Object println(Object array, String... parse) {
			print(array, parse);
			println();
			return array;
		}

		public void flush() {
			out.flush();
			err.flush();
		}
	}

	public enum BoundType {
		CLOSED, OPEN;
	}

	public static class Range<C> implements Serializable{

		private static final long serialVersionUID = -4702828934863023392L;
		protected C lower;
		protected C upper;
		protected BoundType lowerType;
		protected BoundType upperType;
		private Comparator<? super C> comparator;

		protected Range(C lower, BoundType lowerType, C upper, BoundType upperType) {
			this(lower, lowerType, upper, upperType, null);
		}

		protected Range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {
			this.lower = lower;
			this.upper = upper;
			this.lowerType = lowerType;
			this.upperType = upperType;
			this.comparator = comparator;
		}

		public static <C extends Comparable<? super C>> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType) {
			if (lower != null && upper != null) {
				int comp = lower.compareTo(upper);
				if (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);
				else if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN))return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);
			}
			return new Range<C>(lower, lowerType, upper, upperType);
		}

		public static <C> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {
			if (lower != null && upper != null) {
				int comp = comparator.compare(lower, upper);
				if (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);
				else if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);
			}
			return new Range<C>(lower, lowerType, upper, upperType, comparator);
		}

		public static <C extends Comparable<? super C>> Range<C> all() {
			return range((C)null, BoundType.OPEN, null, BoundType.OPEN);
		}

		public static <C> Range<C> all(Comparator<? super C> comparator) {
			return range((C)null, BoundType.OPEN, null, BoundType.OPEN, comparator);
		}

		public static <C extends Comparable<? super C>> Range<C> atMost(C upper) {
			return range(null, BoundType.OPEN, upper, BoundType.CLOSED);
		}

		public static <C> Range<C> atMost(C upper, Comparator<? super C> comparator) {
			return range(null, BoundType.OPEN, upper, BoundType.CLOSED, comparator);
		}

		public static <C extends Comparable<? super C>> Range<C> lessThan(C upper) {
			return range(null, BoundType.OPEN, upper, BoundType.OPEN);
		}

		public static <C> Range<C> lessThan(C upper, Comparator<? super C> comparator) {
			return range(null, BoundType.OPEN, upper, BoundType.OPEN, comparator);
		}

		public static <C extends Comparable<? super C>> Range<C> downTo(C upper, BoundType boundType) {
			return range(null, BoundType.OPEN, upper, boundType);
		}

		public static <C> Range<C> downTo(C upper, BoundType boundType, Comparator<? super C> comparator) {
			return range(null, BoundType.OPEN, upper, boundType, comparator);
		}

		public static <C extends Comparable<? super C>> Range<C> atLeast(C lower) {
			return range(lower, BoundType.CLOSED, null, BoundType.OPEN);
		}

		public static <C> Range<C> atLeast(C lower, Comparator<? super C> comparator) {
			return range(lower, BoundType.CLOSED, null, BoundType.OPEN, comparator);
		}

		public static <C extends Comparable<? super C>> Range<C> greaterThan(C lower) {
			return range(lower, BoundType.OPEN, null, BoundType.OPEN);
		}

		public static <C> Range<C> greaterThan(C lower, Comparator<? super C> comparator) {
			return range(lower, BoundType.OPEN, null, BoundType.OPEN, comparator);
		}

		public static <C extends Comparable<? super C>> Range<C> upTo(C lower, BoundType boundType) {
			return range(lower, boundType, null, BoundType.OPEN);
		}

		public static <C> Range<C> upTo(C lower, BoundType boundType, Comparator<? super C> comparator) {
			return range(lower, boundType, null, BoundType.OPEN, comparator  );
		}

		public static <C extends Comparable<? super C>> Range<C> open(C lower, C upper) {
			return range(lower, BoundType.OPEN, upper, BoundType.OPEN);
		}

		public static <C> Range<C> open(C lower, C upper, Comparator<? super C> comparator) {
			return range(lower, BoundType.OPEN, upper, BoundType.OPEN, comparator);
		}

		public static <C extends Comparable<? super C>> Range<C> openClosed(C lower, C upper) {
			return range(lower, BoundType.OPEN, upper, BoundType.CLOSED);
		}

		public static <C> Range<C> openClosed(C lower, C upper, Comparator<? super C> comparator) {
			return range(lower, BoundType.OPEN, upper, BoundType.CLOSED, comparator);
		}

		public static <C extends Comparable<? super C>> Range<C> closedOpen(C lower, C upper) {
			return range(lower, BoundType.CLOSED, upper, BoundType.OPEN);
		}

		public static <C> Range<C> closedOpen(C lower, C upper, Comparator<? super C> comparator) {
			return range(lower, BoundType.CLOSED, upper, BoundType.OPEN, comparator);
		}

		public static <C extends Comparable<? super C>> Range<C> closed(C lower, C upper) {
			return range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);
		}

		public static <C> Range<C> closed(C lower, C upper, Comparator<? super C> comparator) {
			return range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);
		}

		public static <C extends Comparable<? super C>> Range<C> singleton(C value) {
			return range(value, BoundType.CLOSED, value, BoundType.CLOSED);
		}

		public static <C> Range<C> singleton(C value, Comparator<? super C> comparator) {
			return range(value, BoundType.CLOSED, value, BoundType.CLOSED, comparator);
		}

		public static <C extends Comparable<? super C>> Range<C> empty() {
			return range((C)null, BoundType.CLOSED, null, BoundType.CLOSED);
		}

		public static <C> Range<C> empty(Comparator<? super C> comparator) {
			return range((C)null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);
		}

		public static <C extends Comparable<? super C>> Range<C> encloseAll(Iterable<C> values) {
			C lower = values.iterator().next();
			C upper = lower;
			for (C i : values) {
				if (lower.compareTo(i) > 0) lower = i;
				if (upper.compareTo(i) < 0) upper = i;
			}
			return range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);
		}

		public static <C> Range<C> encloseAll(Iterable<C> values, Comparator<? super C> comparator) {
			C lower = values.iterator().next();
			C upper = lower;
			for (C i : values) {
				if (comparator.compare(lower, i) > 0) lower = i;
				if (comparator.compare(upper, i) < 0) upper = i;
			}
			return range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);
		}

		protected int compareLower(C value) {
			return compareLower(value, BoundType.CLOSED);
		}

		protected int compareLower(C value, BoundType boundType) {
			return compareLower(lower, lowerType, value, boundType);
		}

		protected int compareLower(C lower, BoundType lowerType, C value) {
			return compareLower(lower, lowerType, value, BoundType.CLOSED);
		}

		protected int compareLower(C lower, BoundType lowerType, C value, BoundType boundType) {
			if (lower == null) return value == null ? 0 : -1;
			else if (value == null) return 1;
			int compare;
			if (comparator == null) {
				@SuppressWarnings(""unchecked"")
				Comparable<C> comp = (Comparable<C>)lower;
				compare = comp.compareTo(value);
			} else compare = comparator.compare(lower, value);
			if (compare == 0) {
				if (lowerType == BoundType.CLOSED) -- compare;
				if (boundType == BoundType.CLOSED) ++ compare;
			}
			return compare;
		}

		protected int compareUpper(C value) {
			return compareUpper(value, BoundType.CLOSED);
		}

		protected int compareUpper(C value, BoundType boundType) {
			return compareUpper(upper, upperType, value, boundType);
		}

		protected int compareUpper(C upper, BoundType upperType, C value) {
			return compareUpper(upper, upperType, value, BoundType.CLOSED);
		}

		protected int compareUpper(C upper, BoundType upperType, C value, BoundType boundType) {
			if (upper == null) return value == null ? 0 : 1;
			if (value == null) return -1;
			int compare;
			if (comparator == null) {
				@SuppressWarnings(""unchecked"")
				Comparable<C> comp = (Comparable<C>)upper;
				compare = comp.compareTo(value);
			} else compare = comparator.compare(upper, value);
			if (compare == 0) {
				if (upperType == BoundType.CLOSED) ++ compare;
				if (boundType == BoundType.CLOSED) -- compare;
			}
			return compare;
		}

		public boolean hasLowerBound() {
			return lower != null;
		}

		public C lowerEndpoint() {
			if (hasLowerBound()) return lower;
			throw new IllegalStateException();
		}

		public BoundType lowerBoundType() {
			if (hasLowerBound()) return lowerType;
			throw new IllegalStateException();
		}

		public boolean hasUpperBound() {
			return upper != null;
		}

		public C upperEndpoint() {
			if (hasUpperBound()) return upper;
			throw new IllegalStateException();
		}

		public BoundType upperBoundType() {
			if (hasUpperBound()) return upperType;
			throw new IllegalStateException();
		}

		/**
		 * この区間が空集合か判定します。
		 * @return 空集合ならばtrue
		 */
		public boolean isEmpty() {
			return lower == null && upper == null && lowerType == BoundType.CLOSED;
		}

		/**
		 * 与えられた引数が区間の左側に位置するか判定します。<br>
		 * 接する場合は区間の左側ではないと判定します。
		 * @param value 調べる引数
		 * @return 区間の左側に位置するならtrue
		 */
		public boolean isLess(C value) {
			return isLess(value, BoundType.CLOSED);
		}

		protected boolean isLess(C value, BoundType boundType) {
			return compareLower(value, boundType) > 0;
		}

		/**
		 * 与えられた引数が区間の右側に位置するか判定します。<br>
		 * 接する場合は区間の右側ではないと判定します。
		 * @param value 調べる引数
		 * @return 区間の右側に位置するならtrue
		 */
		public boolean isGreater(C value) {
			return isGreater(value, BoundType.CLOSED);
		}

		private boolean isGreater(C value, BoundType boundType) {
			return compareUpper(value, boundType) < 0;
		}

		/**
		 * 与えられた引数が区間内に位置するか判定します。<br>
		 * 接する場合も区間内に位置すると判定します。
		 * @param value 調べる引数
		 * @return 区間内に位置するならtrue
		 */
		public boolean contains(C value) {
			return !isLess(value) && !isGreater(value) && !isEmpty();
		}

		/**
		 * 与えられた引数すべてが区間内に位置するか判定します。<br>
		 * 接する場合も区間内に位置すると判定します。
		 * @param value 調べる要素
		 * @return 全ての要素が区間内に位置するならtrue
		 */
		public boolean containsAll(Iterable<? extends C> values) {
			for (C i : values) if (!contains(i)) return false;
			return true;
		}

		/**
		 * 与えられた区間がこの区間に内包されるか判定します。<br>
		 *
		 * @param other
		 * @return 与えられた区間がこの区間に内包されるならtrue
		 */
		public boolean encloses(Range<C> other) {
			return !isLess(other.lower, other.lowerType) && !isGreater(other.upper, other.upperType);
		}

		/**
		 * 与えられた区間がこの区間と公差するか判定します。<br>
		 * 接する場合は公差するものとします。
		 * @param value 調べる引数
		 * @return 区間が交差するならtrue
		 */
		public boolean isConnected(Range<C> other) {
			if (this.isEmpty() || other.isEmpty()) return false;
			C lower, upper;
			BoundType lowerType, upperType;
			if (isLess(other.lower, other.lowerType)) {
				lower = other.lower;
				lowerType = other.lowerType;
			} else {
				lower = this.lower;
				lowerType = this.lowerType;
			}
			if (isGreater(other.upper, other.upperType)) {
				upper = other.upper;
				upperType = other.upperType;
			} else {
				upper = this.upper;
				upperType = this.upperType;
			}
			if (lower == null || upper == null) return true;
			int comp = compareLower(lower, lowerType, upper, upperType);
			return comp <= 0;
		}
		/**
		 * この区間との積集合を返します。
		 * @param connectedRange 積集合を求める区間
		 * @return 積集合
		 */
		public Range<C> intersection(Range<C> connectedRange) {
			if (this.isEmpty() || connectedRange.isEmpty()) {
				if (comparator == null) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);
				return empty(comparator);
			}
			C lower, upper;
			BoundType lowerType, upperType;
			if (isLess(connectedRange.lower, connectedRange.lowerType)) {
				lower = connectedRange.lower;
				lowerType = connectedRange.lowerType;
			} else {
				lower = this.lower;
				lowerType = this.lowerType;
			}
			if (isGreater(connectedRange.upper, connectedRange.upperType)) {
				upper = connectedRange.upper;
				upperType = connectedRange.upperType;
			} else {
				upper = this.upper;
				upperType = this.upperType;
			}
			if (comparator == null) {
				return new Range<C>(lower, lowerType, upper, upperType);
			}
			return range(lower, lowerType, upper, upperType, comparator);
		}

		/**
		 * この区間との和集合を返します。
		 * @param other 和集合を求める区間
		 * @return 和集合
		 */
		public Range<C> span(Range<C> other) {
			if (other.isEmpty()) return new Range<C>(lower, lowerType, upper, upperType);
			C lower, upper;
			BoundType lowerType, upperType;
			if (isLess(other.lower, other.lowerType)) {
				lower = this.lower;
				lowerType = this.lowerType;
			} else {
				lower = other.lower;
				lowerType = other.lowerType;
			}
			if (isGreater(other.upper, other.upperType)) {
				upper = this.upper;
				upperType = this.upperType;
			} else {
				upper = other.upper;
				upperType = other.upperType;
			}
			return new Range<C>(lower, lowerType, upper, upperType, comparator);
		}

		@Override
		public boolean equals(Object object) {
			if (this == object) return true;
			if (object instanceof Range) {
				@SuppressWarnings(""unchecked"")
				Range<C> comp = (Range<C>) object;
				return compareLower(comp.lower, comp.lowerType) == 0 && compareUpper(comp.upper, comp.upperType) == 0 && lowerType == comp.lowerType && upperType == comp.upperType;
			}
			return false;
		}

		@Override
		public int hashCode() {
			if (lower == null && upper == null) return 0;
			else if (lower == null) return upper.hashCode();
			else if (upper == null) return lower.hashCode();
			return lower.hashCode() ^ upper.hashCode();
		}

		@Override
		public String toString() {
			if (isEmpty()) return ""()"";
			return (lowerType == BoundType.OPEN ? ""("" : ""["") + (lower == null ? """" : lower.toString()) + "".."" + (upper == null ? """" : upper.toString()) + (upperType == BoundType.OPEN ? "")"" : ""]"");
		}
	}

	public static class IterableRange<C> extends Range<C> implements Iterable<C>{

		private static final long serialVersionUID = 9065915259748260688L;
		protected UnaryOperator<C> func;

		protected IterableRange(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {
			super(lower, lowerType, upper, upperType);
			this.func = func;
		}

		public static <C extends Comparable<? super C>> IterableRange<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {
			if (lower == null || upper == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);
			int comp = lower.compareTo(upper);
			if (comp > 0) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);
			else if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);
			return new IterableRange<C>(lower, lowerType, upper, upperType, func);
		}

		public static <C extends Comparable<? super C>> IterableRange<C> open(C lower, C upper, UnaryOperator<C> func) {
			if (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);
			return range(func.apply(lower), BoundType.CLOSED, upper, BoundType.OPEN, func);
		}

		public static <C extends Comparable<? super C>> IterableRange<C> openClosed(C lower, C upper, UnaryOperator<C> func) {
			if (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);
			return range(func.apply(lower), BoundType.CLOSED, upper, BoundType.CLOSED, func);
		}

		public static <C extends Comparable<? super C>> IterableRange<C> closedOpen(C lower, C upper, UnaryOperator<C> func) {
			return range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);
		}

		public static <C extends Comparable<? super C>> IterableRange<C> closed(C lower, C upper, UnaryOperator<C> func) {
			return range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);
		}

		public static <C extends Comparable<? super C>> IterableRange<C> singleton(C value, UnaryOperator<C> func) {
			return range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);
		}

		protected class Iter implements Iterator<C> {
			C now;
			Iter() {
				now = lower;
			}
			@Override
			public final boolean hasNext() {
				return !isGreater(now);
			}

			@Override
			public final C next() {
				C ret = now;
				now = func.apply(now);
				return ret;
			}

			@Override
			public final void remove() {
				throw new UnsupportedOperationException();
			}
		}

		protected class EmptyIter implements Iterator<C> {

			@Override
			public boolean hasNext() {
				return false;
			}

			@Override
			public C next() {
				return null;
			}

			@Override
			public final void remove() {
				throw new UnsupportedOperationException();
			}

		}

		@Override
		public Iterator<C> iterator() {
			return lower == null || upper == null ? new EmptyIter() : new Iter();
		}

		public int getDistance() {
			C check = upper;
			int ret = 0;
			while (lower != check) {
				check = func.apply(check);
				++ ret;
			}
			return ret;
		}
	}

	public static class IntRange extends IterableRange<Integer>{

		private static final long serialVersionUID = 5623995336491967216L;
		private final boolean useFastIter;

		private static class Next implements UnaryOperator<Integer> {

			@Override
			public Integer apply(Integer value) {
				return value + 1;
			}
		}

		protected IntRange() {
			super(null, BoundType.CLOSED, null, BoundType.CLOSED, new Next());
			useFastIter = true;
		}

		protected IntRange(UnaryOperator<Integer> func) {
			super(null, BoundType.CLOSED, null, BoundType.CLOSED, func);
			useFastIter = false;
		}

		protected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType) {
			super(lower, lowerType, upper, upperType, new Next());
			useFastIter = true;
		}

		protected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {
			super(lower, lowerType, upper, upperType, func);
			useFastIter = false;
		}

		public static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType) {
			if (lower > upper) return new IntRange();
			if (lowerType == BoundType.OPEN) ++ lower;
			if (upperType == BoundType.OPEN) -- upper;
			return new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED);
		}

		public static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {
			if (lower > upper) return new IntRange(func);
			if (lowerType == BoundType.OPEN) ++ lower;
			if (upperType == BoundType.OPEN) -- upper;
			return new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);
		}

		public static IntRange open(int lower, int upper) {
			return range(lower, BoundType.OPEN, upper, BoundType.OPEN);
		}

		public static IntRange open(int lower, int upper, UnaryOperator<Integer> func) {
			return range(lower, BoundType.OPEN, upper, BoundType.OPEN, func);
		}

		public static IntRange open(int upper) {
			return range(0, BoundType.CLOSED, upper, BoundType.OPEN);
		}

		public static IntRange open(int upper, UnaryOperator<Integer> func) {
			return range(0, BoundType.CLOSED, upper, BoundType.OPEN, func);
		}

		public static IntRange openClosed(int lower, int upper) {
			return range(lower, BoundType.OPEN, upper, BoundType.CLOSED);
		}

		public static IntRange openClosed(int lower, int upper, UnaryOperator<Integer> func) {
			return range(lower, BoundType.OPEN, upper, BoundType.CLOSED, func);
		}

		public static IntRange closedOpen(int lower, int upper) {
			return range(lower, BoundType.CLOSED, upper, BoundType.OPEN);
		}

		public static IntRange closedOpen(int lower, int upper, UnaryOperator<Integer> func) {
			return range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);
		}

		public static IntRange closed(int lower, int upper) {
			return range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);
		}

		public static IntRange closed(int lower, int upper, UnaryOperator<Integer> func) {
			return range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);
		}

		public static IntRange closed(int upper) {
			return range(0, BoundType.CLOSED, upper, BoundType.CLOSED);
		}

		public static IntRange closed(int upper, UnaryOperator<Integer> func) {
			return range(0, BoundType.CLOSED, upper, BoundType.CLOSED, func);
		}

		public static IntRange singleton(int value) {
			return range(value, BoundType.CLOSED, value, BoundType.CLOSED);
		}

		public static IntRange singleton(int value, UnaryOperator<Integer> func) {
			return range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);
		}

		private class FastIter implements Iterator<Integer> {
			int now;
			public FastIter() {
				now = lower;
			}
			@Override
			public final boolean hasNext() {
				return now <= upper;
			}

			@Override
			public final Integer next() {
				return now++;
			}

			@Override
			public final void remove() {
				throw new UnsupportedOperationException();
			}
		}

		private class Iter implements Iterator<Integer> {
			int now;
			public Iter() {
				now = lower;
			}
			@Override
			public final boolean hasNext() {
				return now <= upper;
			}

			@Override
			public final Integer next() {
				int ret = now;
				now = func.apply(now);
				return ret;
			}

			@Override
			public final void remove() {
				throw new UnsupportedOperationException();
			}
		}

		@Override
		public Iterator<Integer> iterator() {
			return lower == null || upper == null ? new EmptyIter() : useFastIter ? new FastIter() : new Iter();
		}

		@Override
		public int getDistance() {
			int ret = upper - lower;
			if (upperType == BoundType.CLOSED) ++ ret;
			return ret;
		}

		public int getClosedLower() {
			return lower;
		}

		public int getOpenLower() {
			return lower - 1;
		}

		public int getClosedUpper() {
			return upperType == BoundType.CLOSED ? upper : upper - 1;
		}

		public int getOpenUpper() {
			return upperType == BoundType.CLOSED ? upper + 1 : upper;
		}
	}

	/**
	 * 演算が結合法則を満たすことを示すために使用するマーカー・インターフェースです。
	 * @author 31536000
	 *
	 * @param <T> 二項演算の型
	 */
	public interface Associative<T> extends BinaryOperator<T>{
		/**
		 * repeat個のelementを順次演算した値を返します。
		 * @param element 演算する値
		 * @param repeat 繰り返す回数、1以上であること
		 * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値
		 */
		public default T hyper(T element, int repeat) {
			if (repeat < 1) throw new IllegalArgumentException(""undefined operation"");
			T ret = element;
			-- repeat;
			for (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);
			return ret;
		}
	}

	/**
	* この演算が逆元を持つことを示すために使用するマーカー・インターフェースです。
	 * @author 31536000
	 *
	 * @param <T> 二項演算の型
	 */
	public interface Inverse<T> extends BinaryOperator<T>{
		public T inverse(T element);
	}

	/**
	 * 演算が交換法則を満たすことを示すために使用するマーカー・インターフェースです。
	 * @author 31536000
	 *
	 * @param <T> 二項演算の型
	 */
	public interface Commutative<T> extends BinaryOperator<T>{

	}

	/**
	 * 演算が単位元を持つことを示すために使用するマーカー・インターフェースです。
	 * @author 31536000
	 *
	 * @param <T> 二項演算の型
	 */
	public interface Unit<T> extends BinaryOperator<T>{
		/**
		 * 単位元を返します。
		 * @return 単位元
		 */
		public T unit();
	}

	/**
	 * 演算が群であることを示すために使用するマーカー・インターフェースです。
	 * @author 31536000
	 *
	 * @param <T> 二項演算の型
	 */
	public interface Group<T> extends Monoid<T>, Inverse<T>{
		/**
		 * repeat個のelementを順次演算した値を返します。
		 * @param element 演算する値
		 * @param repeat 繰り返す回数
		 * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値
		 */
		@Override
		public default T hyper(T element, int repeat) {
			T ret = unit();
			if (repeat < 0) {
				repeat = -repeat;
				for (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);
				return inverse(ret);
			}
			for (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);
			return ret;
		}
	}

	/**
	 * 演算がモノイドであることを示すために使用するマーカー・インターフェースです。
	 * @author 31536000
	 *
	 * @param <T> 二項演算の型
	 */
	public interface Monoid<T> extends Associative<T>, Unit<T> {
		/**
		 * repeat個のelementを順次演算した値を返します。
		 * @param element 演算する値
		 * @param repeat 繰り返す回数、0以上であること
		 * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値
		 */
		@Override
		public default T hyper(T element, int repeat) {
			if (repeat < 0) throw new IllegalArgumentException(""undefined operation"");
			T ret = unit();
			for (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);
			return ret;
		}
	}

	/**
	 * 演算が可換モノイドであることを示すために使用するマーカー・インターフェースです。
	 * @author 31536000
	 *
	 * @param <T> 二項演算の型
	 */
	public interface CommutativeMonoid<T> extends Monoid<T>, Commutative<T> {

	}

	/**
	 * 演算がアーベル群(可換群)であることを示すために使用するマーカー・インターフェースです。
	 * @author 31536000
	 *
	 * @param <T> 二項演算の型
	 */
	public interface Abelian<T> extends Group<T>, CommutativeMonoid<T> {

	}

	/**
	 * 演算が半環であることを示すために使用するマーカー・インターフェースです。
	 * @author 31536000
	 *
	 * @param <T> 二項演算の型
	 * @param <A> 和に関する演算
	 * @param <M> 積に関する演算
	 */
	public interface Semiring<T, A extends CommutativeMonoid<T>, M extends Monoid<T>> {
		public A getAddition();
		public M getMultiplication();
	}

	/**
	 * 演算が環であることを示すために使用するマーカー・インターフェースです。
	 * @author 31536000
	 *
	 * @param <T> 二項演算の型
	 * @param <A> 和に関する演算
	 * @param <M> 積に関する演算
	 */
	public interface Ring<T, A extends Abelian<T>, M extends Monoid<T>> extends Semiring<T, A, M>{

	}

	/**
	 * 演算が可換環に属することを示すために使用するマーカー・インターフェースです。
	 * @author 31536000
	 *
	 * @param <T> 二項演算の型
	 * @param <A> 和に関する演算
	 * @param <M> 積に関する演算
	 */
	public interface CommutativeRing<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends Ring<T, A, M>{

	}

	public static class ModInteger extends Number implements CommutativeRing<ModInteger, Abelian<ModInteger>, CommutativeMonoid<ModInteger>>{

		private static final long serialVersionUID = -8595710127161317579L;
		private final int mod;
		private int num;

		private final Addition add;
		private final Multiplication mul;

		private class Addition implements Abelian<ModInteger> {

			@Override
			public ModInteger unit() {
				return new ModInteger(mod, 0);
			}

			@Override
			public ModInteger inverse(ModInteger element) {
				return new ModInteger(element, element.mod - element.num);
			}

			@Override
			public ModInteger apply(ModInteger left, ModInteger right) {
				return new ModInteger(left).addEqual(right);
			}
		}

		private class Multiplication implements Abelian<ModInteger> {

			@Override
			public ModInteger unit() {
				return new ModInteger(mod, 1);
			}

			@Override
			public ModInteger apply(ModInteger left, ModInteger right) {
				return new ModInteger(left).multiplyEqual(right);
			}

			@Override
			public ModInteger inverse(ModInteger element) {
				return new ModInteger(element, element.inverse(element.num));
			}

		}

		public ModInteger(int mod) {
			this.mod = mod;
			num = 0;
			add = new Addition();
			mul = new Multiplication();
		}

		public ModInteger(int mod, int num) {
			this.mod = mod;
			this.num = validNum(num);
			add = new Addition();
			mul = new Multiplication();
		}

		public ModInteger(ModInteger n) {
			mod = n.mod;
			num = n.num;
			add = n.add;
			mul = n.mul;
		}

		private ModInteger(ModInteger n, int num) {
			mod = n.mod;
			this.num = num;
			add = n.add;
			mul = n.mul;
		}

		private int validNum(int n) {
			n %= mod;
			if (n < 0) n += mod;
			return n;
		}

		private int validNum(long n) {
			n %= mod;
			if (n < 0) n += mod;
			return (int)n;
		}

		protected int inverse(int n) {
			int m = mod, u = 0, v = 1, t;
			while(n != 0) {
				t = m / n;
				m -= t * n;
				u -= t * v;
				if (m != 0) {
					t = n / m;
					n -= t * m;
					v -= t * u;
				} else {
					v %= mod;
					if (v < 0) v += mod;
					return v;
				}
			}
			u %= mod;
			if (u < 0) u += mod;
			return u;
		}

		public boolean isPrime(int n) {
			if ((n & 1) == 0) return false; // 偶数
			for (int i = 3, j = 8, k = 9;k <= n;i += 2, k += j += 8) if (n % i == 0) return false;
			return true;
		}

		@Override
		public int intValue() {
			return num;
		}

		@Override
		public long longValue() {
			return num;
		}

		@Override
		public float floatValue() {
			return num;
		}

		@Override
		public double doubleValue() {
			return num;
		}

		public ModInteger add(int n) {
			return new ModInteger(this).addEqual(n);
		}

		public ModInteger add(long n) {
			return new ModInteger(this).addEqual(n);
		}

		public ModInteger add(ModInteger n) {
			return new ModInteger(this).addEqual(n);
		}

		public ModInteger addEqual(int n) {
			num = validNum(num + n);
			return this;
		}

		public ModInteger addEqual(long n) {
			num = validNum(num + n);
			return this;
		}

		public ModInteger addEqual(ModInteger n) {
			if ((num += n.num) >= mod) num -= mod;
			return this;
		}

		public ModInteger subtract(int n) {
			return new ModInteger(this).subtractEqual(n);
		}

		public ModInteger subtract(long n) {
			return new ModInteger(this).subtractEqual(n);
		}

		public ModInteger subtract(ModInteger n) {
			return new ModInteger(this).subtractEqual(n);
		}

		public ModInteger subtractEqual(int n) {
			num = validNum(num - n);
			return this;
		}

		public ModInteger subtractEqual(long n) {
			num = validNum(num - n);
			return this;
		}

		public ModInteger subtractEqual(ModInteger n) {
			if ((num -= n.num) < 0) num += mod;
			return this;
		}

		public ModInteger multiply(int n) {
			return new ModInteger(this).multiplyEqual(n);
		}

		public ModInteger multiply(long n) {
			return new ModInteger(this).multiplyEqual(n);
		}

		public ModInteger multiply(ModInteger n) {
			return new ModInteger(this).multiplyEqual(n);
		}

		public ModInteger multiplyEqual(int n) {
			num = (int)((long)num * n % mod);
			if (num < 0) num += mod;
			return this;
		}

		public ModInteger multiplyEqual(long n) {
			return multiplyEqual((int) (n % mod));
		}

		public ModInteger multiplyEqual(ModInteger n) {
			num = (int)((long)num * n.num % mod);
			return this;
		}

		public ModInteger divide(int n) {
			return new ModInteger(this).divideEqual(n);
		}

		public ModInteger divide(long n) {
			return new ModInteger(this).divideEqual(n);
		}

		public ModInteger divide(ModInteger n) {
			return new ModInteger(this).divideEqual(n);
		}

		public ModInteger divideEqual(int n) {
			num = (int)((long)num * inverse(validNum(n)) % mod);
			return this;
		}

		public ModInteger divideEqual(long n) {
			return divideEqual((int)(n % mod));
		}

		public ModInteger divideEqual(ModInteger n) {
			num = (int)((long)num * n.inverse(n.num) % mod);
			return this;
		}

		public ModInteger pow(int n) {
			return new ModInteger(this).powEqual(n);
		}

		public ModInteger pow(long n) {
			return new ModInteger(this).powEqual(n);
		}

		public ModInteger pow(ModInteger n) {
			return new ModInteger(this).powEqual(n);
		}

		public ModInteger powEqual(int n) {
			long ans = 1, num = this.num;
			if (n < 0) {
				n = -n;
				while (n != 0) {
					if ((n & 1) != 0) ans = ans * num % mod;
					n >>>= 1;
			num = num * num % mod;
				}
				this.num = inverse((int)ans);
				return this;
			}
			while (n != 0) {
				if ((n & 1) != 0) ans = ans * num % mod;
				n >>>= 1;
					num = num * num % mod;
			}
			this.num = (int)ans;
			return this;
		}
		public ModInteger powEqual(long n) {
			return powEqual((int)(n % (mod - 1)));
		}

		public ModInteger powEqual(ModInteger n) {
			long num = this.num;
			this.num = 1;
			int mul = n.num;
			while (mul != 0) {
				if ((mul & 1) != 0) this.num *= num;
				mul >>>= 1;
				num *= num;
				num %= mod;
			}
			return this;
		}

		public ModInteger equal(int n) {
			num = validNum(n);
			return this;
		}

		public ModInteger equal(long n) {
			num = validNum(n);
			return this;
		}

		public ModInteger equal(ModInteger n) {
			num = n.num;
			return this;
		}

		public int toInt() {
			return num;
		}

		public int getMod() {
			return mod;
		}

		@Override
		public boolean equals(Object x) {
			if (x instanceof ModInteger) return ((ModInteger)x).num == num && ((ModInteger)x).mod == mod;
			return false;
		}

		@Override
		public int hashCode() {
			return num ^ mod;
		}

		@Override
		public String toString() {
			return String.valueOf(num);
		}

		@Deprecated
		public String debug() {
			int min = num, ans = 1;
			for (int i = 2;i < min;++ i) {
				int tmp = multiply(i).num;
				if (min > tmp) {
					min = tmp;
					ans = i;
				}
			}
			return min + ""/"" + ans;
		}

		@Override
		public Addition getAddition() {
			return add;
		}

		@Override
		public Multiplication getMultiplication() {
			return mul;
		}
	}

	/**
	 * 素数を法とする演算上で、組み合わせの計算を高速に行います。
	 * @author 31536000
	 *
	 */
	public static class ModUtility {
		private final int mod, totient;
		private int[] fact, inv, invfact;
		/**
		 * modを法とする
		 * @param mod
		 */
		public ModUtility(int mod) {
			this(mod, 2);
		}

		public ModUtility(int mod, int calc) {
			if (mod <= 0) throw new IllegalArgumentException(""illegal mod: "" + mod);
			this.mod = mod;
			int totient = mod;
			for (int i = 2;i * i <= mod;++ i) {
				if (mod % i == 0) {
					totient = totient / i * (i - 1);
					while ((mod %= i) % i == 0);
				}
			}
			this.totient = totient;
			precalc(calc);
		}

		public void precalc(int calc) {
			if (calc < 2) calc = 2;
			fact = new int[calc];
			inv = new int[calc];
			invfact = new int[calc];
			fact[0] = invfact[0] = fact[1] = invfact[1] = inv[1] = 1;
			for (int i = 2;i < calc;++ i) {
				fact[i] = (int)((long)fact[i - 1] * i % mod);
				inv[i] = (int)(mod - (long)inv[mod % i] * (mod / i) % mod);
				invfact[i] = (int)((long)invfact[i - 1] * inv[i] % mod);
			}
		}

		public ModInteger create() {
			return create(0);
		}

		public ModInteger create(int n) {
			return new ModInt(n);
		}

		private class ModInt extends ModInteger {

			private static final long serialVersionUID = -2435281861935422575L;

			public ModInt(int n) {
				super(mod, n);
			}

			@Override
			protected int inverse(int n) {
				return ModUtility.this.inverse(n);
			}
		}

		public int inverse(int n) {
			try {
				if (inv.length > n) return inv[n];
				int m = mod, u = 0, v = 1, t;
				while(n != 0) {
					t = m / n;
					m -= t * n;
					u -= t * v;
					if (m != 0) {
						t = n / m;
						n -= t * m;
						v -= t * u;
					} else {
						v %= mod;
						if (v < 0) v += mod;
						return v;
					}
				}
				u %= mod;
				if (u < 0) u += mod;
				return u;
			} catch (ArrayIndexOutOfBoundsException e) {
				throw new IllegalArgumentException();
			}
		}

		public int factorial(int n) {
			try {
				if (fact.length > n) return fact[n];
				long ret = fact[fact.length - 1];
				for (int i = fact.length;i <= n;++ i) ret = ret * i % mod;
				return (int)ret;
			} catch (ArrayIndexOutOfBoundsException e) {
				throw new IllegalArgumentException();
			}
		}

		public int permutation(int n, int k) {
			if (k < 0) throw new IllegalArgumentException();
			if (n < k) return 0;
			if (fact.length > n) return (int)((long)fact[n] * invfact[n - k] % mod);
			long ret = 1;
			for (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;
			return (int)ret;
		}

		public int combination(int n, int k) {
			if (k < 0) throw new IllegalArgumentException();
			if (n < k) return 0;
			if (fact.length > n) return (int)((long)fact[n] * invfact[k] % mod * invfact[n - k] % mod);
			long ret = 1;
			if (n < 2 * k) k = n - k;
			if (invfact.length > k) ret = invfact[k];
			else ret = inverse(factorial(k));
			for (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;
			return (int)ret;
		}

		public int multinomial(int n, int... k) {
			int sum = 0;
			for (int i : k) sum += i;
			long ret = factorial(n);
			if (fact.length > n) {
				for (int i : k) {
					if (i < 0) throw new IllegalArgumentException();
					ret = ret * invfact[i] % mod;
					sum += i;
				}
				if (sum > n) return 0;
				ret = ret * invfact[n - sum] % mod;
			} else {
				for (int i : k) {
					if (i < 0) throw new IllegalArgumentException();
					if (invfact.length > i) ret = ret * invfact[i] % mod;
					else ret = ret * inverse(factorial(i)) % mod;
					sum += i;
				}
				if (sum > n) return 0;
				if (invfact.length > n - sum) ret = ret * invfact[n - sum] % mod;
				else ret = ret * inverse(factorial(n - sum)) % mod;
			}
			return (int)ret;
		}

		public int multichoose(int n, int k) {
			return combination(mod(n + k - 1), k);
		}

		public int catalan(int n) {
			return divide(combination(mod(2 * n), n), mod(n + 1));
		}

		public int pow(int n, int m) {
			long ans = 1, num = n;
			if (m < 0) {
				m = -m;
				while (m != 0) {
					if ((m & 1) != 0) ans = ans * num % mod;
					m >>>= 1;
			num = num * num % mod;
				}
				return inverse((int)ans);
			}
			while (m != 0) {
				if ((m & 1) != 0) ans = ans * num % mod;
				m >>>= 1;
			num = num * num % mod;
			}
			return (int)ans;
		}

		public int pow(long n, long m) {
			return pow((int)(n % mod), (int)(m % (mod - 1)));
		}

		public int totient() {
			return totient;
		}

		public boolean isPrime() {
			return totient == mod - 1;
		}

		public int mod(int n) {
			return (n %= mod) < 0 ? n + mod : n;
		}

		public int mod(long n) {
			return (int)((n %= mod) < 0 ? n + mod : n);
		}

		public int add(int n, int m) {
			return mod(n + m);
		}

		public int add(long n, long m) {
			return mod(n + m);
		}

		public int subtract(int n, int m) {
			return mod(n - m);
		}

		public int subtract(long n, long m) {
			return mod(n - m);
		}

		public int multiply(int n, int m) {
			int ans = (int)((long)n * m % mod);
			return ans < 0 ? ans + mod : ans;
		}

		public int multiply(long n, long m) {
			return multiply(mod(n), mod(m));
		}

		public int divide(int n, int m) {
			return multiply(n, inverse(mod(m)));
		}

		public int divide(long n, long m) {
			return multiply(n, inverse(mod(m)));
		}

		public ModInteger lagrangePolynomial(ModInteger[] f, int x) {
			if (f.length > x) return f[x];
			if (x > fact.length) precalc(x);
			ModInteger ret = create(0);
			ModInteger[] dp = new ModInteger[f.length], dp2 = new ModInteger[f.length];
			dp[0] = create(1);
			dp2[f.length - 1] = create(1);
			for (int i = 1;i < f.length;++ i) {
				dp[i] = dp[i - 1].multiply(x - i - 1);
				dp2[f.length - i - 1] = dp2[f.length - i].multiply(x - f.length + i);
			}
			for (int i = 0;i < f.length;++ i) {
				ModInteger tmp = f[i].multiply(dp[i]).multiplyEqual(dp2[i]).multiplyEqual(inv[i]).multiplyEqual(inv[f.length - 1 - i]);
				if ((f.length - i & 1) == 0) ret.addEqual(tmp);
				else ret.subtractEqual(tmp);
			}
			return ret;
		}
	}

	public static class AbstractArray<T> extends AbstractList<T> implements RandomAccess{

		private final Object[] array;

		public AbstractArray(int size) {
			array = new Object[size];
		}

		public AbstractArray(T[] array) {
			this(array.length);
			System.arraycopy(array, 0, this.array, 0, array.length);
		}

		@Override
		public T set(int index, T element) {
			T ret = get(index);
			array[index] = element;
			return ret;
		}

		@Override
		public T get(int index) {
			@SuppressWarnings(""unchecked"")
			T ret = (T)array[index];
			return ret;
		}

		public Object[] get() {
			return array;
		}

		public T[] get(T[] array) {
			if (array.length < this.array.length) {
				@SuppressWarnings(""unchecked"")
				T[] ret  = (T[])Arrays.copyOfRange(this.array, 0, this.array.length, array.getClass());
				return ret;
			}
			System.arraycopy(this.array, 0, array, 0, this.array.length);
			return array;
		}

		@Override
		public int size() {
			return array.length;
		}

		public int length() {
			return size();
		}

		@Override
		public int hashCode() {
			return Arrays.hashCode(array);
		}

		private class Iter implements Iterator<T> {
			private int index;

			private Iter() {
				index = 0;
			}

			@Override
			public boolean hasNext() {
				return index < array.length;
			}

			@Override
			public T next() {
				return get(index++);
			}

			@Override
			public void remove() {
				throw new UnsupportedOperationException();
			}
		}

		@Override
		public Iterator<T> iterator() {
			return new Iter();
		}
	}

	public static class Array<T> extends AbstractArray<T> implements Serializable{

		private static final long serialVersionUID = 2749604433067098063L;

		public Array(int size) {
			super(size);
		}

		public Array(T[] array) {
			super(array);
		}

		public T front() {
			return get(0);
		}

		public T back() {
			return get(size() - 1);
		}
	}

	public static abstract class Enumeration<V> implements Iterator<Enumeration.Entry<V>>, Iterable<Enumeration.Entry<V>> {

		public static class Entry<V> {
			public final int index;
			public final V value;

			public Entry(int index, V value) {
				this.index = index;
				this.value = value;
			}

			public int getIndex() {
				return index;
			}

			public V getValue() {
				return value;
			}

			@Override
			public String toString() {
				return index + "":"" + value.toString();
			}
		}

		@Override
		public Iterator<Entry<V>> iterator() {
			return this;
		}

		public static <V> Enumeration<V> create(V[] array) {
			return new EnumerationArray<>(array);
		}

		public static <V> Enumeration<V> create(Collection<? extends V> collection) {
			return new EnumerationCollection<>(collection);
		}

		private static class EnumerationArray<V> extends Enumeration<V> {
			private int index;
			private final V[] array;

			public EnumerationArray(V[] array) {
				index = 0;
				this.array = array;
			}
			@Override
			public boolean hasNext() {
				return index != array.length;
			}

			@Override
			public Entry<V> next() {
				Entry<V> ret = new Entry<>(index, array[index]);
				++ index;
				return ret;
			}
		}

		private static class EnumerationCollection<V> extends Enumeration<V> {
			private int index;
			private final Iterator<? extends V> iterator;

			public EnumerationCollection(Collection<? extends V> collection) {
				index = 0;
				iterator = collection.iterator();
			}
			@Override
			public boolean hasNext() {
				return iterator.hasNext();
			}

			@Override
			public Entry<V> next() {
				Entry<V> ret = new Entry<>(index, iterator.next());
				++ index;
				return ret;
			}
		}
	}
}
"
16,"import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        int b = sc.nextInt();
        if((a * b) % 2 == 0){
            System.out.println(""Even"");
        } else {
            System.out.println(""Odd"");
        }
    }
}"
17,"import java.io.IOException;
import java.io.InputStream;
import java.util.Arrays;
import java.util.NoSuchElementException;

public class Main {
	public static void main(String[] args) {
		new Main().solve();
	}

	void solve() {
		FastScanner sc = new FastScanner();
		int N = sc.nextInt();
		int A = sc.nextInt();
		int B = sc.nextInt();
		long ans = 0;
		for (int i = 1; i <= N; i++) {
			String s = String.valueOf(i);
			int num = -48 * s.length();
			for (int j = 0; j < s.length(); j++) {
				num += s.charAt(j);
			}
			if (num >= A && num <= B) ans += i;
		}
		out(ans);
	}

	class Combination {
		final int mod;
		final int max;

		final long[] fact;
		final long[] inv;
		final long[] invfact;

		public Combination(int n) {
			this(n, 1_000_000_007);
		}

		public Combination(int n, int mod) {
			this.mod = mod;
			max = n + 1;
			fact = new long[max];
			invfact = new long[max];
			inv = new long[max];

			inv[1] = 1;
			for (int i = 2; i < inv.length; i++) {
				inv[i] = inv[mod % i] * (mod - mod / i) % mod;
			}

			fact[0] = 1;
			invfact[0] = 1;
			for (int i = 1; i < inv.length; i++) {
				fact[i] = i * fact[i - 1] % mod;
				invfact[i] = inv[i] * invfact[i - 1] % mod;
			}
		}

		public long get(int n, int r) {
			return fact[n] * invfact[n - r] % mod * invfact[r] % mod;
		}
	}


	public long gcd(long a, long b) {
		long remainder = a % b;
		if (remainder == 0) {
			return b;
		} else {
			return gcd(b, remainder);
		}
	}

	void out(String a) {
		System.out.println(a);
	}

	void out(int a) {
		System.out.println(a);
	}

	void out(long a) {
		System.out.println(a);
	}

	void out(double a) {
		System.out.println(a);
	}

	void out(char a) {
		System.out.println(a);
	}
}


class FastScanner {
    private final InputStream in = System.in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        } else {
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }

    private int readByte() {
        if (hasNextByte())
            return buffer[ptr++];
        else
            return -1;
    }

    private boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }

    public boolean hasNext() {
        while (hasNextByte() && !isPrintableChar(buffer[ptr]))
            ptr++;
        return hasNextByte();
    }

    public String next() {
        if (!hasNext())
            throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while (isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    public long nextLong() {
        if (!hasNext())
            throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            } else if (b == -1 || !isPrintableChar(b)) {
                return minus ? -n : n;
            } else {
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }

    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)
            throw new NumberFormatException();
        return (int) nl;
    }

    public double nextDouble() {
        return Double.parseDouble(next());
    }
}
"
18,"import java.util.Scanner;
class {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    if(n % 2 ==0) {
      System.out.println(n/2);
    } else {
      System.out.println((n+1)/(2*n));
    }
  }
}"
19,"import java.util.*;
class Main{
  public static void main(String[] args){
    Scanner sc = new Scanner(System.in);
    int N = sc.nextInt();
    int K = sc.nextLong();
    int[] hp = new int[N];
    long sum = 0;
    for(int i=0; i<N; i++){
      int tmp = sc.nextLong();
      hp.add(tmp);
    }
    Arrays.sort(hp);
    for(int i=0; i<N -K; i++){
      sum += tmp;
    }
    System.out.println(sum);
  }
}

"
20,"import java.util.*;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        String s = sc.next();
        SegTree t = new SegTree(n, s);
        int q = sc.nextInt();
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < q; i++) {
            int c = sc.nextInt();
            if(c == 1){
                int a = sc.nextInt()-1;
                int b = sc.next().charAt(0) - 'a';
                t.update(a, b);
            }else{
                int l = sc.nextInt()-1;
                int r = sc.nextInt();
                int x = t.query(l, r, 0, 0, t.size);
                sb.append(Integer.bitCount(x) + ""\n"");
            }
        }
        System.out.print(sb.toString());
        sc.close();

    }

}

class SegTree {

    public int n;
    public int size;
    /**
     * 要素全体を含むノードのindex：0.
     * k番目(0-indexed)の要素のindex：k + size - 1
     * ノードkの親要素のindex：(k - 1) / 2.
     * ノードkの子要素のうち左側のindex：k*2+1.
     * ノードkの子要素のうち右側のindex：k*2+2.
     */
    public int[] data;

    /**
     * コンストラクタ.
     * @param n 要素数
     */
    public SegTree(int n, String s){
        this.n = n;
        size = 1;
        while(size < n) size *= 2;
        data = new int[size*2];
        // 初期化処理
        for (int i = 0; i < s.length(); i++) {
            int x = s.charAt(i) - 'a';
            update(i, x);
        }
    }

    /**
     * k番目（0-indexed）の要素をaに更新します.
     * @param k 変更対象要素のindex（0-indexed）
     * @param a 変更後の値
     */
    public void update(int k, int a){
        k += size - 1;
        if(data[k] != 1<<a){
            data[k] = 1<<a;
            while(0 < k){
                k = (k - 1) / 2;
                data[k] = data[k * 2 + 1] | data[k * 2 + 2];
            }
        }
    }

    /**
     * 区間[a, b)での○○を求めます.
     * 最初に呼ぶ際は、query(a, b, 0, 0, size)として呼ぶ.
     * @param a 求める区間の下限（含む）
     * @param b 求める区間の上限（含まない）
     * @param k 確認するノードのindex
     * @param l 確認するノードの下限（含む）
     * @param r 確認するノードの上限（含まない）
     * @return 区間[a, b)での○○
     */
    public int query(int a, int b, int k, int l, int r){
        if(r <= a || b <= l) return 0;

        if(a <= l && r <= b) return data[k];

        int vl = query(a, b, k*2+1, l, (l+r)/2);
        int vr = query(a, b, k*2+2, (l+r)/2, r);
        return vl | vr;
    }
}
"
21,"import java.util.Scanner;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        String str = scanner.next();
        char[] chars = str.toCharArray();
        int cnt = 0;
        for(int i = 0; i < chars.length/2; i++){
            if( chars[i] == chars[chars.length-1-i] ){
                continue;
            } else {
                cnt++;
            }
        }
        System.out.println(cnt);
    }
}
"
22,"import java.util.Scanner;

class Main{
  public static main(String[] args){
    Scanner sc = new Scanner(System.in);
    final int K = sc.nextInt();
    final int A = sc.nextInt();
    final int B = sc.nextInt();
    sc.close();
    String is_ok = ""NG"";
    for(int i=A;i<=B;i++){
      if(i%K == 0){
        is_ok = ""OK"";
      }
    }
    System.out.println(is_ok);
  }
}"
23,"
import java.util.Scanner;

class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		String s = sc.next();
		if(s.equals( ""a"")) {
			System.out.println(""b"");
		}else if(s.equals( ""b"")) {
			System.out.println(""c"");
		}else if(s.equals( ""c"")) {
			System.out.println(""d"");
		}else if(s.equals( ""d"")) {
			System.out.println(""e"");
		}else if(s.equals( ""e"")) {
			System.out.println(""f"");
		}else if(s.equals( ""f"")) {
			System.out.println(""g"");
		}else if(s.equals( ""g"")) {
			System.out.println(""h"");
		}else if(s.equals( ""h"")) {
			System.out.println(""i"");
		}else if(s.equals( ""i"")) {
			System.out.println(""j"");
		}else if(s.equals( ""j"")) {
			System.out.println(""k"");
		}else if(s.equals( ""k"")) {
			System.out.println(""l"");
		}else if(s.equals( ""l"")) {
			System.out.println(""m"");
		}else if(s.equals( ""m"")) {
			System.out.println(""n"");
		}else if(s.equals( ""n"")) {
			System.out.println(""o"");
		}else if(s.equals( ""o"")) {
			System.out.println(""p"");
		}else if(s.equals( ""p"")) {
			System.out.println(""q"");
		}else if(s.equals( ""q"")) {
			System.out.println(""r"");
		}else if(s.equals( ""r"")) {
			System.out.println(""s"");
		}else if(s.equals( ""s"")) {
			System.out.println(""t"");
		}else if(s.equals( ""t"")) {
			System.out.println(""u"");
		}else if(s.equals( ""u"")) {
			System.out.println(""v"");
		}else if(s.equals( ""v"")) {
			System.out.println(""w"");
		}else if(s.equals( ""w"")) {
			System.out.println(""x"");
		}else if(s.equals( ""x"")){
			System.out.println(""y"");
		}else {
			System.out.println(""z"");
		}
	}
}
"
24,"import java.util.*;

class Abc088b
{
    public static void main (String[] args)
    {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] a = new int[n];
        for(int i=0; i<n; i++)
        {
            a[i] = sc.nextInt();
        }
        int x;
        for(int i=0; i<n; i++)
        {
            for(int j=i; j<n; j++)
            {
                if(a[i] < a[j])
                {
                    x    = a[i];
                    a[i] = a[j];
                    a[j] = x;
                }
            }
        }
        int sum = 0;
        for(int i=n-1; i>=1; i--)
        {
             sum += a[i];
             sum -= a[--i];

        }
        if(n % 2 == 1)
        {
            sum += a[0];
        }
        System.out.println(sum);
    }
}"
25,"import java.util.Scanner;

class Solver{
    final String S;

    Solver(Scanner in){
        S = in.next();
    }

    void solve(){
        char[] chars = S.toCharArray();
        int counter = 0;
        int result = 0;

        for(char ch : chars){
            if(ch == 'S') counter++;
            else if(counter <= 0){
                result++;
            }else counter--;
        }

        System.out.println(result * 2);
    }
}

class Main{
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);

        new Solver(in).solve();

        in.close();
    }
}"
26,"import java.io.*;
public class Main {
	public static void main(String[] args){
		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
		try{
        	while(true) {
        		String line = reader.readLine();
        		String[] num = line.split("" "", -1);
        		int H = Integer.parseInt(num[0]);
        		int W = Integer.parseInt(num[1]);
        		if (H == 0 && W == 0) {
        			break;
        		} else {
        			for (int i = 0; i < H; i++) {
        				for (int j = 0; j < W; j++) {
        					System.out.print(""#"");
        				}
        				System.out.println();
        			}
        			System.out.println();
        		}
        	}
        } catch (IOException e) {
          System.out.println(e);
        } catch (NumberFormatException e) {
          System.out.println(""error"");
        }
    }
}"
27,"import java.util.Arrays;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class Main {
	MyScanner sc = new MyScanner();
	Scanner sc2 = new Scanner(System.in);
	int mod = 1000000007;

	int[] dx = { 1, 0, -1, 0, 0 };
	int[] dy = { 0, 1, 0, -1, 0 };

	void run() {
		for (;;) {
			int H = sc.nextInt();
			int W = sc.nextInt();
			if ((H | W) == 0) {
				return;
			}
			char[][] field = new char[H][W];
			// HashSet<String> hs = new HashSet<String>();
			int allcnt = 0;
			int gH = 0, gW = 0, goH = 0, goW = 0;
			for (int i = 0; i < H; i++) {
				String input = sc.next();
				for (int j = 0; j < W; j++) {
					field[i][j] = input.charAt(j);
					if (input.charAt(j) == 'A') {
						gH = i;
						gW = j;
					}
					if (input.charAt(j) == 'B') {
						goH = i;
						goW = j;
					}
				}
			}
			String direction = sc.next();
			boolean visit[][][][][] = new boolean[H][W][H][W][9];
			Queue<Info> queue = new LinkedList<Info>();
			queue.add(new Info(gH, gW));
			int nowGohostH = goH;
			int nowGohostW = goW;
			int cnt = 0;
			int ansH = 0;
			int ansW = 0;
			int index = 0;
			boolean able = false;
			int roop = 0;
			label: while (!queue.isEmpty()) {
				int size = queue.size();
				char exe = direction.charAt(index % direction.length());
				for (int I = 0; I < size; I++) {
					Info now = queue.poll();
					if (now.girlH == nowGohostH && now.girlW == nowGohostW) {
						ansH = now.girlH;
						ansW = now.girlW;
						able = true;
						break label;
					}
					// hs.add(now.girlH + ""-"" + now.girlW + ""-"" + now.gohostH
					// + ""-"" + now.gohostW);
					int girl_nextH = 0;
					int girl_nextW = 0;
					for (int i = 0; i < 5; i++) {
						girl_nextH = now.girlH + dy[i];
						girl_nextW = now.girlW + dx[i];
						if (girl_nextH < 0) {
							girl_nextH = 0;
						}
						if (girl_nextH == H) {
							girl_nextH = H - 1;
						}
						if (girl_nextW < 0) {
							girl_nextW = 0;
						}
						if (girl_nextW == W) {
							girl_nextW = W - 1;
						}
						if (0 <= girl_nextH && girl_nextH < H
								&& 0 <= girl_nextW && girl_nextW < W
								&& 0 <= nowGohostH && nowGohostH < H
								&& 0 <= nowGohostW && nowGohostW < W
								&& field[girl_nextH][girl_nextW] != '#') {
							Info next = new Info(girl_nextH, girl_nextW);
							if (!visit[next.girlH][next.girlW][nowGohostH][nowGohostW][Integer.valueOf(exe-'0')]) {
								visit[next.girlH][next.girlW][nowGohostH][nowGohostW][Integer.valueOf(exe-'0')] = true;
								roop = 0;
								queue.add(next);
								allcnt++;
							}
						}
					}
					if (queue.isEmpty()) {
						roop++;
						if (roop <= 10) {
							queue.add(now);
						}
					}
				}
				cnt++;
				index++;
				if (exe == '5') {
					nowGohostW = nowGohostW + dx[4];
					nowGohostH = nowGohostH + dy[4];
				}
				if (exe == '8') {
					nowGohostW = nowGohostW + dx[3];
					nowGohostH = nowGohostH + dy[3];
				}
				if (exe == '6') {
					nowGohostW = nowGohostW + dx[0];
					nowGohostH = nowGohostH + dy[0];
				}
				if (exe == '4') {
					nowGohostW = nowGohostW + dx[2];
					nowGohostH = nowGohostH + dy[2];
				}
				if (exe == '2') {
					nowGohostW = nowGohostW + dx[1];
					nowGohostH = nowGohostH + dy[1];
				}
				if (nowGohostH < 0) {
					nowGohostH = 0;
				}
				if (nowGohostH == H) {
					nowGohostH = H - 1;
				}
				if (nowGohostW < 0) {
					nowGohostW = 0;
				}
				if (nowGohostW == W) {
					nowGohostW = W - 1;
				}
			}
			System.out.println(able ? cnt + "" "" + ansH + "" "" + ansW
					: ""impossible"");
		}
	}

	class Info {
		int girlH;
		int girlW;

		public Info(int girlH, int girlW) {
			this.girlH = girlH;
			this.girlW = girlW;
		}
	}

	public static void main(String[] args) {
		new AOJ_1046().run();
	}

	void debug(Object... o) {
		System.out.println(Arrays.deepToString(o));
	}

	void debug2(char[][] array) {
		for (int i = 0; i < array.length; i++) {
			for (int j = 0; j < array[i].length; j++) {
				System.out.print(array[i][j]);
			}
			System.out.println();
		}
	}

	class MyScanner {
		int nextInt() {
			try {
				int c = System.in.read();
				while (c != '-' && (c < '0' || '9' < c))
					c = System.in.read();
				if (c == '-')
					return -nextInt();
				int res = 0;
				do {
					res *= 10;
					res += c - '0';
					c = System.in.read();
				} while ('0' <= c && c <= '9');
				return res;
			} catch (Exception e) {
				return -1;
			}
		}

		double nextDouble() {
			return Double.parseDouble(next());
		}

		String next() {
			try {
				StringBuilder res = new StringBuilder("""");
				int c = System.in.read();
				while (Character.isWhitespace(c))
					c = System.in.read();
				do {
					res.append((char) c);
				} while (!Character.isWhitespace(c = System.in.read()));
				return res.toString();
			} catch (Exception e) {
				return null;
			}
		}
	}
}"
28,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.*;
public class code {
	public static void main(String[] args)throws IOException {
		FastReader sc = new FastReader();
		PrintWriter pw = new PrintWriter(System.out);
		int x = sc.nextInt();
		System.out.println(360 / x);

	}
}





class FastReader {
	BufferedReader br;
	StringTokenizer st;

	public FastReader() {
		br = new BufferedReader(new
		                        InputStreamReader(System.in));
	}

	String next() {
		while (st == null || !st.hasMoreElements()) {
			try {
				st = new StringTokenizer(br.readLine());
			} catch (IOException  e) {
				e.printStackTrace();
			}
		}
		return st.nextToken();
	}

	int nextInt() {
		return Integer.parseInt(next());
	}

	long nextLong() {
		return Long.parseLong(next());
	}

	double nextDouble() {
		return Double.parseDouble(next());
	}

	String nextLine() {
		String str = """";
		try {
			str = br.readLine();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return str;
	}
}"
29,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int w = sc.nextInt();
        int n = sc.nextInt();
        int array[] = new int[w];
        for (int i = 0; i < w; i++) array[i] = i+1;
        for (int i = 0; i < n; i++){
            String line = sc.next();
            String spl[] = line.split("","");
            int a = Integer.parseInt(spl[0]) - 1;
            int b = Integer.parseInt(spl[1]) - 1;
            int tmp = array[a];
            array[a] = array[b];
            array[b] = tmp;
        }
        for (int i = 0; i < w; i++){
            System.out.println(array[i]);
        }
    }
}"
30,"import java.util.Scanner;

public class ITP1_3C {
    public static void main(String args[]){
	Scanner in= new Scanner(System.in);
	short a = 0;
	short b = 0;
	short c = 0;
	while (true){
		a = in.nextShort();
		b = in.nextShort();
		if (a == 0 && b == 0){
			break;
		}else if (a > b){
			c = a;
			a = b;
			b = c;
		}
	        System.out.printf(""%d %d%n"", a, b);
	} 
    }   
}"
31,"import java.util.*;
 
class Main {
 
  public static void main(String[] args) {
    
    Scanner sc = new Scanner(System.in);
    
    int[] fromAnt;
    int[] toAnt;
    
    for(int i = 0; i < 5; i++) {
      fromAnt[i] = sc.nextInt();
      toAnt[i] = fromAnt[i];
    }
    
    for(int i = 0; i < 5; i++) {
      for(int j = i+1; j < 5; j++) {
        if(toAnt[j] - fromAnt[i] > k) {
          System.out.println("":("");
          return;
        }
      }
    }
    
    System.out.println(""Yay!"");
	return;    
  }
 
}"
32,"import java.util.Scanner;
 public class Main {
 public static void main(String[] args) {
 // ?¨??????\??????????????????????????????????????? 
Scanner sc = new Scanner(System.in);
 int w = sc.nextInt();
 int n = sc.nextInt();
 int i;
 int c = 0;
 int[] values = new int[w];
 for (i = 0; i < values.length; i++) { 
values[i] = i + 1; 
} 
for (i = 0; i < n; i++) {
 String str = sc.next();
 String[] ab = str.split("","");
 int a = Integer.parseInt(ab[0]) - 1;
 int b = Integer.parseInt(ab[1]) - 1;
 // a??¨b????????£???values??????????????????
 c = values[a];
 values[a] =  values[b];
 values[b] =  c; 
}
 // values??????????????????
 for(i = 0;i<w;i++){
   System.out.println(values[i]);
}   
}
 }"
33,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

	public static void main(String[] args) throws Exception {
		int[] charArray = readLine().chars().sorted().toArray();
		if (charArray[0] == charArray[1] && charArray[2] == charArray[3] && charArray[0] != charArray[2]) {
			System.out.println(""Yes"");
		} else {
			System.out.println(""No"");
		}
	}
	
	private static String readLine() throws IOException {
		return new BufferedReader(new InputStreamReader(System.in)).readLine();
	}
}
"
34,"
import java.util.*;

public class Main{
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        String s = sc.next();
        String ans = """";
        for(int i = 0; i < sa.length; i++){
            if(s.charAt(i) == ""0"" || s.charAt(i) == ""1""){
                ans += s.charAt(i);
            }else{
                ans.substring(0, ans.length() - 1);
            }
        }
        System.out.println(ans);
    }
}"
35,"import java.util.Scanner;

public class Main {

	static long mod = 1_000_000_007;

	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int N = in.nextInt(), K = in.nextInt();
		int a[] = new int[N + 1];
		for ( int i = 1; i <= N; i++ ) {
			a[i] = in.nextInt();
		}
		in.close();

		long dp[][] = new long[N + 1][K + 1];
		dp[0][0] = 1;

		for ( int n = 1; n <= N; n++ ) {
			for ( int k = 0; k <= K; k++ ) {
				if ( k == 0 ) {
					dp[n][k] = 1;
					
				} else if ( k <= a[n] ) {
					dp[n][k] = (dp[n][k - 1] + dp[n - 1][k]) % mod;
					
				} else {
					dp[n][k] = (dp[n][k - 1] + dp[n - 1][k] - dp[n - 1][k - a[n] - 1]) % mod;
					
				} 
			}
		}

		//				for ( long[] ls : dp ) {
		//					for ( long l : ls ) {
		//						System.out.print(l + "" "");
		//					}
		//					System.out.println();
		//				}
		System.out.println((dp[N][K] + mod)% mod);
	}
}
"
36,"import static java.lang.Math.*;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.PriorityQueue;
import java.util.stream.Stream;

public class Main {

	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		MyInput in = new MyInput(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskX solver = new TaskX();
		solver.solve(1, in, out);
		out.close();
	}

	static int INF = 1 << 30;
	static long LINF = 1L << 55;
	static int MOD = 1000000007;
	static int[] mh4 = { 0, -1, 1, 0 };
	static int[] mw4 = { -1, 0, 0, 1 };
	static int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };
	static int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };

	static class TaskX {

		@SuppressWarnings(""unchecked"")
		public void solve(int testNumber, MyInput in, PrintWriter out) {

			T s = new T(1001, in.nextLong(), in.nextLong(), 0);
			T t = new T(1002, in.nextLong(), in.nextLong(), 0);
			int n = in.nextInt();
			T[] ts = new T[1010];
			for (int i = 0; i < n; i++) {
				ts[i] = new T(i, in.nextLong(), in.nextLong(), in.nextLong());
			}

			List<P>[] g = new ArrayList[1010];
			g = Stream.generate(ArrayList::new).limit(1010).toArray(List[]::new);

			for (int i = 0; i < n; i++) {
				g[1001].add(new P(ts[i].idx, dist(s, ts[i])));
				g[ts[i].idx].add(new P(1001, dist(s, ts[i])));
			}

			for (int i = 0; i < n; i++) {
				g[1002].add(new P(ts[i].idx, dist(t, ts[i])));
				g[ts[i].idx].add(new P(1002, dist(t, ts[i])));
			}

			g[s.idx].add(new P(t.idx, dist(s, t)));
			g[t.idx].add(new P(s.idx, dist(s, t)));

			for (int from = 0; from < n; from++) {
				for (int to = 0; to < n; to++) {
					if (from == to) continue;
					g[ts[from].idx].add(new P(ts[to].idx, dist(ts[from], ts[to])));
				}
			}

			double[] cost = new double[1010];
			Arrays.fill(cost, Double.MAX_VALUE/2);
			cost[1001] = 0.0;

			PriorityQueue<P> pq = new PriorityQueue<>();
			pq.add(new P(1001, cost[1001]));
			while (!pq.isEmpty()) {
				P now = pq.remove();

				if (now.d != cost[now.idx]) continue;

				for (P to : g[now.idx]) {
					if (cost[now.idx] + to.d < cost[to.idx]) {
						cost[to.idx] = cost[now.idx] + to.d;
						pq.add(new P(to.idx, cost[to.idx]));
					}
				}
			}

			out.println(cost[1002]);

		}

		class P implements Comparable<P> {
			int idx;
			double d;

			public P(int idx, double d) {
				super();
				this.idx = idx;
				this.d = d;
			}

			@Override
			public int compareTo(P o) {
				return Double.compare(this.d, o.d);
			}

			@Override
			public String toString() {
				return ""P [idx="" + idx + "", d="" + d + ""]"";
			}

		}

		double dist (T t1, T t2) {
			double ret = sqrt(pow(t1.x - t2.x, 2) + pow(t1.y - t2.y, 2));
			ret -= t1.r + t2.r;
			return Math.max(ret, 0);
		}

		class T {
			int idx;
			long x, y, r;

			public T(int idx, long x, long y, long r) {
				super();
				this.idx = idx;
				this.x = x;
				this.y = y;
				this.r = r;
			}

			@Override
			public String toString() {
				return ""T [idx="" + idx + "", x="" + x + "", y="" + y + "", r="" + r
						+ ""]"";
			}

		}
	}

	static class MyInput {
		private final BufferedReader in;
		private static int pos;
		private static int readLen;
		private static final char[] buffer = new char[1024 * 8];
		private static char[] str = new char[500 * 8 * 2];
		private static boolean[] isDigit = new boolean[256];
		private static boolean[] isSpace = new boolean[256];
		private static boolean[] isLineSep = new boolean[256];

		static {
			for (int i = 0; i < 10; i++) {
				isDigit['0' + i] = true;
			}
			isDigit['-'] = true;
			isSpace[' '] = isSpace['\r'] = isSpace['\n'] = isSpace['\t'] = true;
			isLineSep['\r'] = isLineSep['\n'] = true;
		}

		public MyInput(InputStream is) {
			in = new BufferedReader(new InputStreamReader(is));
		}

		public int read() {
			if (pos >= readLen) {
				pos = 0;
				try {
					readLen = in.read(buffer);
				} catch (IOException e) {
					throw new RuntimeException();
				}
				if (readLen <= 0) {
					throw new MyInput.EndOfFileRuntimeException();
				}
			}
			return buffer[pos++];
		}

		public int nextInt() {
			int len = 0;
			str[len++] = nextChar();
			len = reads(len, isSpace);
			int i = 0;
			int ret = 0;
			if (str[0] == '-') {
				i = 1;
			}
			for (; i < len; i++)
				ret = ret * 10 + str[i] - '0';
			if (str[0] == '-') {
				ret = -ret;
			}
			return ret;
		}

		public long nextLong() {
			int len = 0;
			str[len++] = nextChar();
			len = reads(len, isSpace);
			int i = 0;
			long ret = 0;
			if (str[0] == '-') {
				i = 1;
			}
			for (; i < len; i++)
				ret = ret * 10 + str[i] - '0';
			if (str[0] == '-') {
				ret = -ret;
			}
			return ret;
		}

		public char nextChar() {
			while (true) {
				final int c = read();
				if (!isSpace[c]) {
					return (char) c;
				}
			}
		}

		public String nextString() {
			return new String(nextChars());
		}

		public char[] nextChars() {
			int len = 0;
			str[len++] = nextChar();
			len = reads(len, isSpace);
			return Arrays.copyOf(str, len);
		}

		public char[][] next2DChars(int h, int w) {
			char[][] s = new char[h][w];
			for (int i = 0; i < h; i++) {
				s[i] = nextChars();
			}
			return s;
		}

		int reads(int len, boolean[] accept) {
			try {
				while (true) {
					final int c = read();
					if (accept[c]) {
						break;
					}
					if (str.length == len) {
						char[] rep = new char[str.length * 3 / 2];
						System.arraycopy(str, 0, rep, 0, str.length);
						str = rep;
					}
					str[len++] = (char) c;
				}
			} catch (MyInput.EndOfFileRuntimeException e) {
			}
			return len;
		}

		public int[] nextIntArray(final int n) {
			final int[] res = new int[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextInt();
			}
			return res;
		}

		public int[] nextIntArray1Index(final int n) {
			final int[] res = new int[n + 1];
			for (int i = 1; i < n + 1; i++) {
				res[i] = nextInt();
			}
			return res;
		}

		public int[] nextIntArrayDec(final int n) {
			final int[] res = new int[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextInt() - 1;
			}
			return res;
		}

		public long[] nextLongArray(final int n) {
			final long[] res = new long[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextLong();
			}
			return res;
		}

		public long[] nextLongArray1Index(final int n) {
			final long[] res = new long[n + 1];
			for (int i = 1; i < n + 1; i++) {
				res[i] = nextLong();
			}
			return res;
		}

		public long[] nextLongArrayDec(final int n) {
			final long[] res = new long[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextLong() - 1;
			}
			return res;
		}

		public double nextDouble() {
			return Double.parseDouble(nextString());
		}

		public double[] nextDoubleArray(int n) {
			double[] res = new double[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextDouble();
			}
			return res;
		}

		static class EndOfFileRuntimeException extends RuntimeException {
		}

	}

}
"
37,"import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] d = new int[n + 1];
        long[] cnt = new long[n + 1];
        for (int i = 1; i <= n; i++) {
            d[i] = sc.nextInt();
            cnt[d[i]]++;
        }

        if (d[1] != 0 || cnt[0] != 1) {
            System.out.println(0);
            return;
        }
        long MOD = 998244353;
        long ans = 1;
        for (int i = 2; i <= n; i++) {
            long j = 0;
            while (j < cnt[i]) {
                ans *= cnt[i - 1];
                ans %= MOD;
                j++;
            }
        }
        System.out.println(ans);
    }

}
"
38,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

    private static final String OVER_FLOW = ""overflow"";
    private static final String STRING_ZERO = ""0"";
    private static final int MAX_NUM = 100000000;

    public static void main(String[] args) {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        int count = 0;

        try {
            count = Integer.valueOf(in.readLine());

            for (int i = 0; i < count; i++) {

                int[] budget = new int[10];
                String input1 = in.readLine();
                String input2 = in.readLine();

                if(input1.length() > 80 || input2.length() > 80) {
                    System.out.println(OVER_FLOW);
                    continue;
                }

                int idx = 0;
                for (int j = input1.length(); j > 0; j -= 8) {

                    budget[idx] = Integer.valueOf(input1.substring(
                            j - 8 > 0 ? j - 8 : 0, j));
                    idx++;
                }

                idx = 0;

                for (int k = input2.length(); k > 0; k -= 8) {

                    budget[idx] += Integer.valueOf(input2.substring(
                            k - 8 > 0 ? k - 8 : 0, k));
                    idx++;
                }

                for (int l = 0; l < 9; l++) {
                    if (budget[l] >= MAX_NUM) {
                        budget[l + 1] += 1;
                        budget[l] -= MAX_NUM;
                    }
                }

                if (budget[9] >= MAX_NUM) {
                    System.out.println(OVER_FLOW);
                } else {

                    boolean startFlg = false;

                    StringBuilder result = new StringBuilder();

                    for (int m = 9; m >= 0; m--) {

                        if (startFlg) {

                            String tmp = String.valueOf(budget[m]);

                            for (int n = 8 - tmp.length(); n > 0; n--) {
                                result.append(STRING_ZERO);
                            }
                            result.append(tmp);
                        } else if (budget[m] > 0 || m == 0) {
                            result.append(budget[m]);
                            startFlg = true;
                        }
                    }

                    System.out.println(result.toString());
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}"
39,"import java.io.*;
public class Main{
    static void scan()throws IOException{
	InputStreamReader isr = new InputStreamReader(System.in);
	BufferedReader br = new BufferedReader(isr);
	String str=br.readLine();
	turn(str);
    }

    static void turn(String str){
	int l = str.length();
	for(int i=l-1;i>0;i--)
	    System.out.print(str.charAt(i));
System.out.println(atr.length(0));
    }
    
    public static void main(String[] args)throws IOException{
	scan();
    }
}"
40,"

import java.util.Scanner;

public class Main {

	public static void main(String args[])
	{
		Scanner scan=new Scanner(System.in);
		int n=scan.nextInt();
		double prob[]=new double[n+1];
		for(int i=1;i<=n;i++)
		{
			prob[i]=scan.nextDouble();
		}
		double dp[][]=new double[n+1][n+1];
		dp[1][0]=1-prob[1];
		dp[1][1]=prob[1];
		for(int i=2;i<=n;i++)
		{
			for(int j=0;j<=i;j++)
			{
				dp[i][j]=dp[i-1][j]*(1-prob[i]);
				
				if(j!=0)
				{
					dp[i][j]+=dp[i-1][j-1]*prob[i];
				}
			}
		}
		double ans=0;
		for(int i=(n+1)/2;i<=n;i++)
		{
			ans+=dp[n][i];
		}
		System.out.print(ans);
	}
}
"
41,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int k = sc.nextInt();
        sc.close();

        ArrayList<Long> ll = new ArrayList<Long>();
        ArrayList<Double> dl = new ArrayList<Double>();
        ll.add(1L);
        dl.add(1.0);

        for (int i = 2; i < 1002; i++) {
            int s = 0;
            int ti = i;
            for (int j = 0; j < 8; j++) {
                int div = (int) (Math.pow(10, 7 - j));
                if (ti >= div) {
                    int ts = ti / div;
                    s += ts;
                    ti -= ts * div;
                }
            }
            double f = (double) i / (double) s;
            // System.out.println(f + "" "" + i + "" "" + s);
            while (dl.get(dl.size() - 1) > f) {
                ll.remove(ll.size() - 1);
                dl.remove(dl.size() - 1);
            }
            ll.add((long) i);
            dl.add(f);
        }

        long nine = 0;
        int count = 0;
        // for (int i = 0; i < 1; i++) {
        //     nine += (long) (Math.pow(10, count)) * 9;
        //     nine += (long) (Math.pow(10, count + 1)) * 9;
        //     count += 2;
        //     for (int j = 1; j <= 99; j++) {
        //         long tl = nine + j * (long) (Math.pow(10, count));
        //         long stl = tl;
        //         long s = 0;
        //         for (int m = 0; m < 17; m++) {
        //             long div = (long) (Math.pow(10, 16 - m));
        //             if (tl >= div) {
        //                 long ts = tl / div;
        //                 s += ts;
        //                 tl -= ts * div;
        //             }
        //         }
        //         double f = (double) stl / (double) s;
        //         // System.out.println(f + "" "" + i + "" "" + s);
        //         while (dl.get(dl.size() - 1) > f) {
        //             ll.remove(ll.size() - 1);
        //             dl.remove(dl.size() - 1);
        //         }
        //         ll.add(stl);
        //         dl.add(f);
        //         // System.out.println(stl + "" "" + f);
        //     }
        // }

        nine = 0;
        count = 0;
        for (int i = 0; i < 15; i++) {
            nine += (long) (Math.pow(10, count)) * 9;
            count += 1;
            for (int j = 100; j <= 999; j++) {
                long tl = nine + j * (long) (Math.pow(10, count));
                long stl = tl;
                long s = 0;
                for (int m = 0; m < 17; m++) {
                    long div = (long) (Math.pow(10, 16 - m));
                    if (tl >= div) {
                        long ts = tl / div;
                        s += ts;
                        tl -= ts * div;
                    }
                }
                double f = (double) stl / (double) s;
                // System.out.println(f + "" "" + i + "" "" + s);
                while (dl.get(dl.size() - 1) > f) {
                    ll.remove(ll.size() - 1);
                    dl.remove(dl.size() - 1);
                }
                ll.add(stl);
                dl.add(f);
                // System.out.println(stl + "" "" + f);
            }
        }

        for (int i = 0; i < k; i++) {
            System.out.println(ll.get(i));
        }
    }
}"
42,"import java.io.*;
import java.util.*;
import java.lang.*;
class Graph
{
	public ArrayList adjacency[];
	public Graph(int nodes)
	{
		adjacency = new ArrayList[nodes];
		for(int i=0;i<nodes;i++)
		{
			adjacency[i] = new ArrayList<Integer>();
		}
	}
	@Override
	public String toString()
	{
		String ret = """";
		for (ArrayList temp : adjacency) {
			ret+=(temp.toString()+""\n"");
		}
		return ret;
	}
	public void addEdge(int from, int to)
	{
		adjacency[from].add(to);
		adjacency[to].add(from);
	}
}
	
public class Main {
	public static Graph g;
	public static int taka,aoki;
	public static int count[];
	public static boolean vis[];
	public static void mark(int node, int pos)
	{
		count[node] = pos;
		ArrayList list = g.adjacency[node];
		int val;
		for(int i=0;i<list.size();i++)
		{
			val = (int)list.get(i);
			if(count[val]<0)
			{
				mark(val,pos+1);
			}
		}
	}
	public static int calc(int node, int pos,PrintWriter out)
	{
		vis[node]=true;
		if(count[node]==pos || count[node]+1==pos)
			return count[node];
		// if(count[node]<pos)
		// 	return Integer.MIN_VALUE;
		ArrayList list = g.adjacency[node];
		// out.println(""node: ""+node);
		// out.println(""list: ""+list);
		// out.println();
		int val;
		int ans = 0;
		if(list.size()==1){
			// out.println(""yo"");
			ans = count[(int)list.get(0)];
		}
		for(int i=0;i<list.size();i++)
		{
			val = (int)list.get(i);
			if(!vis[val])
				ans=Math.max(ans,calc(val,pos+1,out));
		}
		return ans;
	}
	public static void main(String[] args)throws IOException {
        InputReader in = new InputReader(System.in);
        PrintWriter out = new PrintWriter(System.out);
        
		int n = in.nextInt();
		taka = in.nextInt()-1;
		aoki = in.nextInt()-1;
		g = new Graph(n);
		int a,b;
		for(int i=0;i<n-1;i++)
		{
			a=in.nextInt()-1;
			b=in.nextInt()-1;
			g.addEdge(a,b);
		}
		count = new int[n];
		vis = new boolean[n];
		// Arrays.fill(count,-1);
		for(int i=0;i<n;i++)
		{
			count[i]=-1;
			vis[i]=false;
		}
		mark(aoki,0);
		// out.println(""marked"");
		// for(int i=0;i<n;i++)
		// {
		// 	out.print(i+"" "");
		// 	out.println(count[i]);
		// }
		out.println(calc(taka,0,out));
        out.close();
	}
    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

    }

}"
43,"import java.util.Scanner;

class Main {
  public static void main(String args[]) {
	Scanner scanner = new Scanner(System.in);
	boolean Judge = true;
  	String end = ""-"";
  	String work;
  	
  	
  	while( Judge || scanner.hasnext ){
		String deck = scanner.next();		//最初の文字
		int shuffle = scanner.nextInt();	//シャッフル回数
  		//終わる処理
  		if( deck.equals(end) ){
  			Judge = false;
  		}

  	/*	//シャッフル
  		for( int i = 0; i < shuffle ; i ++ ) {
			int num = scanner.nextInt();	//シャッフル開始位置
			String substr = deck.substring(0, num);
			work = deck.replaceFirst(substr, """");
			deck = work.concat(substr);
  		}
*/
  	  	//結果出力
  		System.out.println(deck);
  	}
  	
	
  	//後処理
	scanner.close();
  }
}
"
44,"import java.util.Scanner;
public class Main{
  public static void main(String[] args){
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    int cou = 0;
    int che = 0;
    for(int i = 1 ; i <= n ; i++){
      int a = sc.nextInt();
      int zyo = 0;
      while(zyo == 0){
        if(a % 2 == 1){
          zyo = 1;
        }else{
          cou = cou + 1;
          a = a / 2;
        }
      }
      if(cou > che){
         che = cou;
      }
      System.out.println(che);
    }
  }
      "
45,"import java.util.Scanner;
import java.util.ArrayList;

public class Main {
	public static void main(String args[]){
		Scanner in=new Scanner(System.in);
		ArrayList<Integer> set=new ArrayList<Integer>();
		ArrayList<Integer> result=new ArrayList<Integer>();
		int a=1;
		int b=1;
		int c=1;
		String grade=""FDCBA"";
		while (!(a==-1 && b==-1 && c==-1)){
			a=in.nextInt();
			b=in.nextInt();
			c=in.nextInt();
			set.add(a);
			set.add(b);
			set.add(c);
		}
		for(int k=0;k<(set.size()-3);k+=3){
			a=set.get(k);
			b=set.get(k+1);
			c=set.get(k+2);
			if (a==-1 ||b==-1){
				result.add(0);
			}else if ((a+b)>=80) {
				result.add(4);
			}else if ((a+b)>=65) {
				result.add(3);
			}else if ((a+b)>=50) {
				result.add(2);
			}else if ((a+b)>=30) {
				if (c >= 50) {
					result.add(2)
				}
				result.add(1);
			}else{
				result.add(0);
			}
		}

		for (int i=0;i<result.size();i++) {
			System.out.println(""%c"",grade.charAt(result.get(i)))
		}

	}
}"
46,"import java.util.Scanner;
{

public static void main(String[] args)
    {
        Scanner in = new Scanner(System.in);

        System.out.print(""Input first number: "");
        int x = in.nextInt();
        System.out.print(""Input second number: "");
        int y = in.nextInt();
        System.out.print(""Input third number: "");
        int z = in.nextInt();

        if (x == y && x == z)
        {
            System.out.println(""Not a Poor Number"");
        }
        else if ((x == y) || (x == z) || (z == y))
        {
            System.out.println(""Poor Number"");
        }
}
"
47,"import java.math.BigDecimal;
import java.util.*;

public class Main {

    static BigDecimal MAX = new BigDecimal(1_000_000_000_000_000_000L);
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        long[] a = new long[n];
        boolean hasZero = false;
        for (int i = 0; i < n; i++) {
            a[i] = sc.nextLong();
            if(a[i] == 0) hasZero = true;
        }
        if(hasZero){
            System.out.println(0);
        }else{
            BigDecimal d = new BigDecimal(a[0]);
            boolean over = false;
            for (int i = 1; i < n; i++) {
                d = d.multiply(new BigDecimal(a[i]));
                if(d.compareTo(MAX) == 1){
                    over = true;break;
                }
            }
            if(over) System.out.println(-1);
            else System.out.println(d.longValue());
        }
        sc.close();

    }

}
"
48,"import java.util.*;
public class Main {
  
    public static void main(String[] args){
	  Scanner sc = new Scanner(System.in);
      
      int a = sc.nextInt();
      int b = sc.nectInt();
      
      if ((a * b) % 2 == 0) {
          System.out.println('Even');
      } else {
          System.out.println('Odd');
    }
      
}"
49,"import java.util.*;
import java.math.*;
public class Main1
{
public static void main(String args[])
{
Scanner sc=new Scanner(System.in);
long a=sc.nextLong();
long b=sc.nextLong();
long c=sc.nextLong();
double a1=Math.sqrt(a);
double b1=Math.sqrt(b);
double c1=Math.sqrt(c);

if((a1+b1)<c1)
System.out.println(""Yes"");
else
System.out.println(""No"");



}
}"
50,"import java.util.*;

class Main{
	public static void main(String[] $){
		final Scanner s=new Scanner(System.in);
		int h=s.nextInt();
		int w=s.nextInt();
		int[][] a=new int[h+1][w+1];
		char[][] c=new char[h+1][w+1];

		Arrays.fill(a[0], 99999);
		for(int i=2;i<=h;++i)
			a[i][0]=99999;
		c[1][0]='.';

		for(int i=1;i<=h;++i){
			String t=s.next();
			for(int j=1;j<=w;++j){
				c[i][j]=t.charAt(j-1);

				int u=(c[i][j]!=c[i-1][j]?1:0)+a[i-1][j];
				int l=(c[i][j]!=c[i][j-1]?1:0)+a[i][j-1];
				a[i][j]=Math.min(u,l);
			}
		}
		System.out.println((a[h][w]+1)/2);
	}
}
"
