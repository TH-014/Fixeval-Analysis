case_no,code_token
1,"import java.io.*;
import java.util.*;

public class test{
	public static void main(String[] args) throws IOException{
		BufferedReader r = new BufferedReader(new InputStreamReader(System.in));
		String s;
		while(true){
			s = r.readLine();
			int a;
			a = Integer.parseInt(s);
			if (a==0) {
				break;
			}
			System.out.println(a);
		}
	}
}"
2,"import java.util.Scanner;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        int b = sc.nextInt();
        int area = a*b;
        int length =2*a+2*b;
        System.out.println(area+"" ""+length);
    }
}"
3,"import java.util.Scanner;


public class Main {
	public static void main(String[] args) {
		Scanner scn = new Scanner(System.in);
		String w = scn.next().toLowerCase();
		String reading = scn.next();
		int cnt = 0;
		while(!reading.equals(""END_OF_TEXT"")){
			//System.out.println(w + ""と"" + reading);
			if(reading.toLowerCase().equals(w)) cnt++;
			reading = scn.next();
		}
		System.out.println(cnt);
	}
}"
4,"import java.util.Scanner;

public class Main {
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		
		for(int i = 1;i <= n;i++){
			long x = i;
			if(x % 3 == 0){
				System.out.print("" ""+i);
				continue;
			}
			
			if(x % 10 == 3){
				System.out.print("" ""+i);
				continue;
			}
			
			for(x /= 10;x != 0;x /= 10){
				if(x % 10 == 3){
					System.out.print("" ""+i);
					break;
				}
			}
		}
		System.out.println();
	}
}"
5,"import java.util.*;
public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n=sc.nextInt();
		int[] a1=new int[n];
		int[] a2=new int[n];
		int[] s1=new int[n];
		int[] s2=new int[n];
	    int ans=0;
		
		for(int i=0;i<n;i++){
          a1[i]=sc.nextInt();
        }
		for(int i=0;i<n;i++){
          a2[i]=sc.nextInt();
        }
		
		s1[0]=a1[0]; 
      	s2[n-1]=a2[n-1];
		for(int i=1;i<n;i++){
          s1[i]=s1[i-1]+a1[i];
        }
		for(int i=n-2;i>=0;i--){
          s2[i]=s2[i+1]+a2[i];
        }
		
		for(int i=0;i<n;i++){
          score=Math.max(score, s1[i]+s2[i]);
        }
		
		System.out.println(ans);
	}
}"
6,"import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.next();
        char tmp;
        String ans = """";
        for (int i = 0; s.length() > i; i++) {
            if (i % 2 == 0) {
                tmp = s.charAt(i);
                ans += String.valueOf(tmp);
            }
        }
        System.out.println(ans);
    }
}
"
7,"import java.io.BufferedReader;
import java.io.InputStreamReader;

public class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String line = br.readLine();
        String[] word = line.split("" "");
        char c1 = word[0].charAt(word[0].length() - 1);
        char c2 = word[1].charAt(0);
        char c3 = word[1].charAt(word[1].length() - 1);
        char c4 = word[2].charAt(0);
        if(c1 == c2 && c3 == c4) {
            System.out.println(""YES"");
        } else {
            System.out.println(""NO"");
        }
    }
}"
8,"import java.util.*;

public class Main {

    private static int H;
    private static int W;
    private static int N;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        H = sc.nextInt();
        W = sc.nextInt();
        N = sc.nextInt();
        Set<Cord> all = new HashSet<>(N);
        for (int i = 0; i < N; i++) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            all.add( new Cord(b, a) );
        }

        long[] ans = solve(all);
        for (int i = 0; i < 10; i++) {
            System.out.println( ans[i] );
        }
    }


    private static long[] solve(Set<Cord> all) {
        Set<Cord> done = new HashSet<>(N);

        long[] ans = new long[10];
        ans[0] = (long)(W-2) * (H-2);
        for (Cord c : all) {
            count(c, ans, all, done);
            done.add(c);
        }
        return ans;
    }

    private static void count(Cord target, long[] ans, Set<Cord> all, Set<Cord> done) {
        for (int x = target.x - 1; x <= target.x + 1 ; x++) {
            for (int y = target.y - 1; y <= target.y+ 1 ; y++) {
                Cord c = new Cord(x, y);

                int count = count2(c, all, done);
                if( count != -1 ) {
                    ans[count]++;
                    ans[0]--;
                }
            }
        }
    }

    private static int count2(Cord center, Set<Cord> all, Set<Cord> done) {
        int cnt = 0;
        for (int x = center.x - 1; x <= center.x + 1 ; x++) {
            for (int y = center.y - 1; y <= center.y + 1 ; y++) {
                if( !xInRange(x) || !yInRange(y) ) return -1;

                Cord c = new Cord(x, y);
                if( done.contains(c) ) return -1;

                if( all.contains(c) ) {
                    cnt++;
                }
            }
        }
        return cnt;
    }

    private static boolean xInRange(int x) {
        return 1 <= x && x <= W;
    }

    private static boolean yInRange(int y) {
        return 1 <= y && y <= H;
    }

    private static class Cord {

        private final int x;
        private final int y;

        public Cord(int x, int y) {
            this.x = x;
            this.y = y;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Cord cord = (Cord) o;
            return x == cord.x &&
                    y == cord.y;
        }

        @Override
        public int hashCode() {
            return Objects.hash(x, y);
        }

        public String toString() {
            return ""("" +x + "","" + y + "")"";
        }
    }
}"
9,"import java.util.*;
 
public class Main {
 
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        String s = sc.next();
 
        int min = 0;
        for(int i = 0;i < n;i++){
            if(s.charAt(i) == '.'){
                min++;
            }
        }
        int num = min;
        for(int i = 0;i < n;i++){
            if(s.charAt(i) == '#'){
                num++;
            } else {
                num--;
            }
            min = Math.min(num,min);
        }
        System.out.println(min);
    }
}"
10,"import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		int K = sc.nextInt();


		if (N%2 == 0) {
			if (N/2 >= K) {
				System.out.println(""YES"");
			} else {
				System.out.println(""NO"");
			}
		} else {
			if ((N/2 + 1) >= K) {
				System.out.println(""YES"");
			}else {
				System.out.println(""NO"");
			}
		}
	}
}
"
11,"import java.util.Scanner;
public class Main{
	public static void main(String[] args) {
    	Scanner sc = new Scanner(System.in);
		long n = Long.parseLong(sc.next());
      	long a = Long.parseLong(sc.next());
      	long b = Long.parseLng(sc.next());
      	if(a==0){
        	System.out.println(0);
          return;
        }
        long c = a+b;
      	long d = n%c;
      	if(d>a) d = a;
        long e = n/c;
        long f = e*a+d;
        System.out.println(f);
    }
 
}"
12,"import java.util.*;
import java.io.*;
public class Main {
	static long[][] dp;
	static int[] array;
	static ArrayList<Integer> allSubsets = new ArrayList<Integer>();
	public static void main(String[] args) throws Exception{
		int num = 998244353;

		// TODO Auto-generated method stub
 		BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
 		PrintWriter out = new PrintWriter(System.out);
 		StringTokenizer st = new StringTokenizer(bf.readLine());
 		int n = Integer.parseInt(st.nextToken());
 		int s = Integer.parseInt(st.nextToken());
 		array = new int[n];
 		StringTokenizer st1 = new StringTokenizer(bf.readLine());
 		for(int i = 0;i<n;i++){
 			array[i] = Integer.parseInt(st1.nextToken());
 		}
 		long[][] dp = new long[n+1][s+1];
 		dp[0][0] = power(2, n, num);
 		for(int i = 1;i<n;i++)
 			dp[0][i] = 0;
 		for(int i = 0;i<n;i++){
 			for(int j = 0;j<=s;j++){
 				dp[i+1][j]+= dp[i][j];
 				dp[i+1][j]%= num;
 				if (j+array[i] <=s){
 					dp[i+1][j+array[i]] += dp[i][j]*power(2, num-2, num);
 					dp[i+1][j+array[i]]%= num;
 				}
 			}
 			
 		}
 		out.println(dp[n][s]);
 		out.close();
 		
	}
	public static int power(long x, long y, long mod){
		long ans = 1;
		while(y>0){
			if (y%2==1)
				ans = (ans*x)%mod;
			x = (x*x)%mod;
			y/=2;
		}
		return (int)(ans);
	}

}
 	
 
//StringJoiner sj = new StringJoiner("" ""); 
//sj.add(strings)
//sj.toString() gives string of those stuff w spaces or whatever that sequence is

 		
 		
 		
 		
	


"
13,"import java.util.*;
public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int i = (int)Math.round(Math.pow(n, 0.5));
		while(n % i != 0) {
			i--;			
		}
		int ii = n/i;
		System.out.println((ii + i - 2));
		sc.close();
	}
}
"
14,"import java.util.*;
public class Main {

	public static void main(String[] args) {
		Scanner input = new Scanner(System.in);
		int length = input.nextInt();
		input.nextLine();
		String list = input.nextLine();
		int[] intList = new int[length];
		int k = 0;
		for(int i = 0; i < list.length(); i++) {
			if(!list.substring(i, i+1).equals("" "")){
				int x = 1;
				for(int y = i; y < list.length(); y++){
					if(!list.substring(y, y+1).equals("" ""))
						x++;
				}
				intList[k] = Integer.parseInt(list.substring(i, x));
				k++;
			}
		}
		for(int m = 0; m < intList.length - 1; m++) {
			System.out.print(intList[m] + "" "");
		}
		System.out.println(intList[intList.length - 1]);
		for(int i = 1; i < intList.length; i++) {
			int key = intList[i];
			int j = i - 1;
			while(j >= 0 && intList[j] > key) {
				intList[j+1] = intList[j];
				j--;
			}
			intList[j+1] = key;
			for(int m = 0; m < intList.length - 1; m++) {
				System.out.print(intList[m] + "" "");
			}
			System.out.println(intList[intList.length - 1]);
		}
	}
}
"
15,"import java.util.*;
public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		double x1 = sc.nextInt();
		double y1 = sc.nextInt();
		double x2 = sc.nextInt();
		double y2 = sc.nextInt();
		System.out.printf(""%.8f\n"",Math.sqrt((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2)));
	}

}"
16,"import java.awt.geom.*;
import java.util.*;

public class Main {
	//0445 start
	//0536 cording end, last dataset is not matched
	//0538 stop and ready to go to school

	int INF = 1 << 24;
	final double EPS = 1.0e-08;
	double EPS2 = 1.0e-02;
	int n, s1, s2;
	Point2D s1p, s2p;
	Point2D [] toy;

	class Edge{
		int from, to;
		double cost;
		public Edge(int from, int to, double cost) {
			this.from = from;
			this.to = to;
			this.cost = cost;
		}
		@Override
		public String toString() {
			return ""Edge [from="" + from + "", to="" + to + "", cost="" + cost + ""]"";
		}

	}

	class C implements Comparable<C>{
		int ind;
		Point2D p;
		public C(int ind, Point2D p) {
			this.ind = ind;
			this.p = p;
		}
		@Override
		public int compareTo(C o) {
			if(this.p.getX() < o.p.getX()) return -1;
			else if(this.p.getX() > o.p.getX()) return 1;
			else if(this.p.getY() < o.p.getY()) return -1;
			else if(this.p.getY() > o.p.getY()) return 1;
			else return 0;
		}
	}
	Comparator< Point2D > com = new Comparator< Point2D >() {
		public int compare(Point2D o1, Point2D o2) {
			if(o1.getX() < o2.getX()) return -1;
			else if(o1.getX() > o2.getX()) return 1;
			else if(o1.getY() < o2.getY()) return -1;
			else if(o1.getY() > o2.getY()) return 1;
			else return 0;
		}
	};

	class State implements Comparable<State>{
		int now1, now2;
		double cost;
		public State(int now1, int now2, double cost) {
			super();
			this.now1 = now1;
			this.now2 = now2;
			this.cost = cost;
		}
		@Override
		public int compareTo(State o) {
			if(this.cost < o.cost ) return -1;
			if(this.cost > o.cost)   return 1;
			return 0;
		}
		@Override
		public String toString() {
			return ""State [now1="" + now1 + "", now2="" + now2 + "", cost="" + cost
					+ ""]"";
		}


	}

	private void doit(){
		Scanner sc = new Scanner(System.in);
		while(true){
			n = sc.nextInt();
			if(n == 0) break;
			Point2D [] plist = new Point2D[n];
			HashSet<Integer> ylist = new HashSet<Integer>();
			for(int i = 0 ; i < n; i ++){
				int x = sc.nextInt();
				int y = sc.nextInt();
				ylist.add(y);
				plist[i] = new Point2D.Double(x,y);
			}
			s1p = plist[0];
			s2p = plist[n-1];

			ArrayList<Line2D> llist = new ArrayList<Line2D>();
			for(int i = 1;i < n; i++){
				Line2D l = new Line2D.Double(plist[i-1], plist[i]);
				llist.add(l);
			}
			ArrayList<Line2D> l2list = new ArrayList<Line2D>();
			for(int y : ylist){
				Point2D p1 = new Point2D.Double(-1,y);
				Point2D p2 = new Point2D.Double(1001, y);
				Line2D ll = new Line2D.Double(p1, p2);
				l2list.add(ll);
			}

			ArrayList<ArrayList<Edge>> pass = segmentArrangement(llist, l2list);
			double ans = solve(pass);
			System.out.printf(""%f\n"",ans);
		}

	}

	private double solve(ArrayList<ArrayList<Edge>> pass) {
		double ans = INF;
		int passsize = pass.size();
		PriorityQueue<State> open = new PriorityQueue<State>();
		open.add(new State(s1, s2, 0.0));
		double [][] close = new double[passsize][passsize];
		boolean[][] close2 = new boolean[passsize][passsize];
		for(int i =0; i < passsize; i++) Arrays.fill(close[i], INF);
		close[s1][s2] = 0.0;
		close2[s1][s2] = true;
		while(! open.isEmpty()){
			State now = open.poll();
			if(now.now1 == now.now2){
				ans = Math.min(ans, now.cost);
				//break;
				continue;
			}

			for(int i = 0 ; i < pass.get(now.now1).size(); i++){
				for(int j = 0; j < pass.get(now.now2).size(); j++){
					int next1 = pass.get(now.now1).get(i).to;
					int next2 = pass.get(now.now2).get(j).to;
					if(next1 == now.now1 && next2 == now.now2)continue;
					if(Math.abs(toy[next1].getY() - toy[next2].getY()) < EPS){
						double value = pass.get(now.now1).get(i).cost+ pass.get(now.now2).get(j).cost;
						double nextcost = now.cost + value;
						if(close2[next1][next2]) continue;
						close2[next1][next2] = true;
						open.add(new State(next1, next2, nextcost));
					}
				}
			}
		}
		return ans;
	}

	private ArrayList<ArrayList<Edge>> segmentArrangement(ArrayList<Line2D> arg, ArrayList<Line2D> l2) {
		Line2D [] line = arg.toArray(new Line2D[arg.size()]);
		//交点リストを求める
		ArrayList<Point2D> intersectionlist = new ArrayList<Point2D>();
		for(int i = 0; i < line.length; i++){
			intersectionlist.add(line[i].getP1());
			intersectionlist.add(line[i].getP2());
			for(int j = i + 1; j < line.length; j++){
				if(line[i].intersectsLine(line[j])){
					Point2D p = intersectPtSS(line[i], line[j]);
					if(p == null) continue;
					intersectionlist.add(p);
				}
			}
		}

		for(int i = 0 ; i < l2.size(); i++){
			for(int j = 0; j < line.length; j++){
				if(l2.get(i).intersectsLine(line[j])){
					Point2D p = intersectPtSS(l2.get(i), line[j]);
					if(p == null) continue;
					intersectionlist.add(p);
				}
			}
		}

		//sortする。重複削除
		Collections.sort(intersectionlist, com);
		for(int i = 1; i < intersectionlist.size(); i++){
			if(issame(intersectionlist.get(i-1), intersectionlist.get(i))){
				intersectionlist.remove(i);
				i--;
			}
		}



		//交点リストから、線分を通過するもの同士でグラフを生成する。
		int len = intersectionlist.size();
		toy = new Point2D[len];
		for(int i = 0 ; i < len; i++){
			toy[i] = intersectionlist.get(i);
			if(issame(toy[i], s1p)){
				s1 = i;
			}
			if(issame(toy[i], s2p)){
				s2 = i;
			}
		}

		//double [][] res = new double[len][len];
		ArrayList<ArrayList<Edge>> res = new ArrayList<ArrayList<Edge>>();
		for(int i = 0; i < len; i++){
			res.add(new ArrayList<Main.Edge>());
			res.get(i).add(new Edge(i, i, 0.0));
		}
		for(int i = 0; i < line.length; i++){

			ArrayList<C> list = new ArrayList<C>();
			for(int j = 0; j < len; j++){
				if(line[i].ptSegDist(intersectionlist.get(j)) < EPS2){
					list.add(new C(j, intersectionlist.get(j)));
				}
			}
			Collections.sort(list);
			for(int j = 1; j < list.size(); j++){
				int from = list.get(j-1).ind;
				int to = list.get(j).ind;
				double cost = list.get(j).p.distance(list.get(j-1).p);
				res.get(from).add(new Edge(from, to, cost));
				res.get(to).add(new Edge(to, from, cost));
			}
		}
		return res;
	}

	private Point2D intersectPtSS(Line2D l, Line2D m) {
		Point2D lVec = sub(l.getP2(), l.getP1());
		Point2D mVec = sub(m.getP2(), m.getP1());
		Point2D m1l1Vec = sub(m.getP1(), l.getP1());
		double a = cross(m1l1Vec, lVec);
		double b = cross(lVec, mVec);
		if(Math.abs(a) < EPS && Math.abs(b) < EPS){
			//平行な直線同士の場合
			return null;
			//          if(l.getP1().distance(m.getP1()) < EPS) return l.getP1();
			//          if(l.getP1().distance(m.getP2()) < EPS) return l.getP1();
			//          return l.getP2();
		}
		double t = a / b;
		double resx = m.getX1() + t * mVec.getX();
		double resy = m.getY1() + t * mVec.getY();
		return new Point2D.Double(resx, resy);
	}

	private boolean issame(Point2D p1, Point2D p2) {
		if(Math.abs(p1.getX() - p2.getX()) < EPS && Math.abs(p1.getY() - p2.getY()) < EPS ){
			return true;
		}
		return false;
	}
	private double cross(Point2D p1, Point2D p2) {
		double res = p1.getX() * p2.getY() - p1.getY() * p2.getX();
		return res;
	}
	private Point2D sub(Point2D p2, Point2D p1) {
		double x = p2.getX() - p1.getX();
		double y = p2.getY() - p1.getY();
		return new Point2D.Double(x, y);
	}

	public static void main(String [] args){
		new Main().doit();
	}
}"
17,"        import java.util.*;
        class Main{
          public static void main(String[] args){
            Scanner sc = new Scanner(System.in);
            int a = sc.nextInt();
            int b = sc.nextInt();
            int c = sc.nextInt();
            int d = sc.nextInt();
            
            long x = a * c;
            long y = a * d;
            long z = b * c;
            long w = b * d;
            long[] aa = new long[4];
            
            aa[0] = x;
            aa[1] = y;
            aa[2] = z;
            aa[3] = w;
            int max = x;
         
            for(int i = 0; i < 4; i++){
              if(aa[i] > max){
                max = aa[i];
              }
            }
            System.out.println(max);
          }
        }"
18,"import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int x=sc.nextInt();
		int n=sc.nextInt();
		int hako[] = new int[102];
		for(int i=0;i<102;i++) {
			hako[i]=0;
		}
		for(int i=0;i<n;i++) {
			int a = sc.nextInt();
			hako[a] = 1;
		}
		
		if(hako[x]==0) {
			System.out.println(x);
			return;
		}
		int up=x+1;
		int down=x-1;
		
		while(up<=101 && down>=0) {
			if(hako[down] == 0) {
				System.out.println(down);
				return;
			}
			if(hako[up] == 0) {
				System.out.println(up);
				return;
			}
			up++;
			down--;
		}
		while(up==102) {
			if(hako[down] == 0) {
				System.out.println(down);
				return;
			}
			down--;
		}
		while(down==-1) {
			if(hako[up] == 0) {
				System.out.println(up);
				return;
			}
			up++;
		}
		
		
	}
}
"
19,"import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Scanner;

class Main {
	public static void main(String[] args) throws IOException {
		new Main().run();
	}

	void run() {
		Scanner sc = new Scanner(System.in);
		PrintWriter pw = new PrintWriter(System.out);
		int N = sc.nextInt();
		long L = sc.nextLong();
		double[] t = new double[N];
		double[] v = new double[N];
		for (int i = 0; i < N; ++i) {
			t[i] = sc.nextDouble();
			v[i] = sc.nextDouble();
		}
		class T {
			double water;
			double salt;

			public T(double water, double salt) {
				this.water = water;
				this.salt = salt;
			}
		}

		ArrayDeque<Double> dequeW = new ArrayDeque<>();
		ArrayDeque<Double> dequeS = new ArrayDeque<>();
		dequeS.add(0d);
		dequeW.add(0d);
		dequeS.addLast(t[0] * v[0]);
		dequeW.addLast(v[0]);
		T p = new T(0, 0);
		pw.println(t[0]);
		for (int i = 1; i < N; ++i) {
			p.water += v[i];
			p.salt += t[i] * v[i];
			dequeW.addFirst(-p.water);
			dequeS.addFirst(-p.water * p.salt);

			while (dequeS.size() >= 2) {
				double t2w = dequeW.pollLast();
				double t2s = dequeS.pollLast();
				double t1w = dequeW.pollLast();
				double t1s = dequeS.pollLast();
				if (t1w + p.water > L && t2w + p.water > L)
					continue;
				if (t1w + p.water == L) {
					dequeW.addLast(t1w);
					dequeS.addLast(t1s);
					break;
				}
				if (t1w + p.water < L && L < t2w + p.water) {
					double r1 = (t2w + p.water - L) / (t2w - t1w);
					double r2 = (L - (t1w + p.water)) / (t2w - t1w);
					double tLasts = r1 * (t1s + p.salt) + r2 * (t2s + p.salt);
					double tLastw = r1 * (t1w + p.water) + r2 * (t2w + p.water);

					tLastw -= p.water;
					tLasts -= p.salt;
					dequeS.addLast(t1s);
					dequeW.addLast(t1w);

					dequeS.addLast(tLasts);
					dequeW.addLast(tLastw);
					break;
				}
			}
			dequeS.pollFirst();
			dequeW.pollFirst();

			while (dequeS.size() >= 2) {
				double t1s = dequeS.pollFirst();
				double t1w = dequeW.pollFirst();
				double t2s = dequeS.pollFirst();
				double t2w = dequeW.pollFirst();
				if ((t1s + p.salt) / (t1w + p.water) > (t2s + p.salt) / (t2w + p.water)) {
					dequeS.addFirst(t2s);
					dequeW.addFirst(t2w);
					dequeS.addFirst(t1s);
					dequeW.addFirst(t1w);
					break;
				}
				dequeS.addFirst(t2s);
				dequeW.addFirst(t2w);
			}
			dequeS.addFirst(-p.salt);
			dequeW.addFirst(-p.water);

			pw.println((dequeS.peekLast() + p.salt) / (dequeW.peekLast() + p.water));
		}
		pw.close();

	}

	void tr(Object... objects) {
		System.out.println(Arrays.deepToString(objects));
	}
}"
20,"import java.util.*;
 
class Main{
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    
    String s = sc.next();
    char[] a = s.toCharArray();
    String ans = """";
    for(int i=0; i<a.length; i++){
      if(i%2 == 0){
        ans += a[i];
      }
    }
    System.out.println(ans);

    sc.close();
  }
}
"
21,"import java.util.*;

class Main{
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		int pieceNum = sc.nextInt();
		int goalNum = sc.nextInt();
		int[] nums = new int[goalNum];
        for(int i = 0; i < goalNum; i++)nums[i] = sc.nextInt();
        Arrays.sort(nums);
        int[] diffs = new int[goalNum-1];
        for(int i = 0; i < goalNum-1; i++)diffs[i] = Math.abs(nums[i+1]-nums[i]);

        int ans = 0;
        for(int i = 0; i < goalNum - pieceNum; i++){
            Arrays.sort(diffs);
            int min = diffs[0];

            ans += min;
            diffs[0] = diffs[goalNum-2];
        }

		System.out.println(ans);
	}
}"
22,"import java.util.Objects;
import java.util.Scanner;

public class Main {
    public static void main(final String[] args) {
        final int p = 2;
        switch (p) {
        case 1:
            P1.p1();
        case 2:
            P2.answer();
        case 3:
            P3.answer();
        }
    }
}

class P3 {
    static void answer() {
        final Scanner sc = new Scanner(System.in);
        final int a = sc.nextInt();
        final int b = sc.nextInt();
//        final int res = calc(a, b);
//        System.out.println(res);
    }

}

class P2 {
    static void answer() {
        final Scanner sc = new Scanner(System.in);
        final int a = sc.nextInt();
        final int b = sc.nextInt();
        final int res = calc(a, b);
        System.out.println(res);
    }

    static int calc(final int a, final int b) {
        final int per = a - 1;
        final int remain = b - 1;
        final int x = remain / per;
        System.out.println("""" + per + "","" + remain + "","" + x);
        if (remain - (per * x) > 0) {
            return x + 1;
        }
        return x;
    }
}

class P1 {

    static void p1() {
        final Scanner sc = new Scanner(System.in);
        final String yohou = sc.nextLine();
        final String jissai = sc.nextLine();

        final int res = calc(yohou, jissai);
        System.out.println(res);
    }

    static int calc(final String yohou, final String kekka) {
        int res = 0;
        for (int i = 0; i < 3; i++) {
            if (Objects.equals(yohou.charAt(i), kekka.charAt(i))) {
                res++;
            }
        }
        return res;
    }
}"
23,"

import java.text.DecimalFormat;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.stream.LongStream;
import java.util.stream.IntStream;
import java.io.*;
import java.util.*;

public class Main {

    public static void main(String[] args) {
        FastScanner sc = new FastScanner();
        PrintWriter out = new PrintWriter(System.out);

        final int N = sc.nextInt();
        int[][] a = new int[N][N];
        int ans = 0;
        for (int i = 0; i < N; i++) {
            int j = sc.nextInt();
            a[i][j-1] = 1;
        }
        
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                if (i != j && a[i][j] == 1 && a[j][i] == 1) {
                    ans++;
                }
            }
        }
        
        out.println(ans / 2);
        
        out.flush();
    }

}

// https://qiita.com/p_shiki37/items/a0f6aac33bf60f5f65e4
class FastScanner {

    private final InputStream in = System.in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        } else {
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }

    private int readByte() {
        if (hasNextByte()) {
            return buffer[ptr++];
        } else {
            return -1;
        }
    }

    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }

    public boolean hasNext() {
        while (hasNextByte() && !isPrintableChar(buffer[ptr])) {
            ptr++;
        }
        return hasNextByte();
    }

    public String next() {
        if (!hasNext()) {
            throw new NoSuchElementException();
        }
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while (isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    public long nextLong() {
        if (!hasNext()) {
            throw new NoSuchElementException();
        }
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            } else if (b == -1 || !isPrintableChar(b)) {
                return minus ? -n : n;
            } else {
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }

    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {
            throw new NumberFormatException();
        }
        return (int) nl;
    }

    public double nextDouble() {
        return Double.parseDouble(next());
    }
}
"
24,"import java.util.*;
import java.io.*;

public class Main {
	
	public static void main(String[] args) throws IOException {
		InputReader in = new InputReader(System.in);
		String s = in.readString(); 
		String ans = """";
		for(int i = 0; i<s.length(); i+=2) {
			ans += s.charAt(i);
		}
		System.out.println(ans);
	}
}
class InputReader {

	private InputStream stream;
	private byte[] buf = new byte[1024];
	private int curChar;
	private int numChars;
	private SpaceCharFilter filter;

	public InputReader(InputStream stream) {
		this.stream = stream;
	}

	public int read() {
		if (numChars == -1)
			throw new InputMismatchException();
		if (curChar >= numChars) {
			curChar = 0;
			try {
				numChars = stream.read(buf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (numChars <= 0)
				return -1;
		}
		return buf[curChar++];
	}

	public int readInt() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		int res = 0;
		do {
			if (c < '0' || c > '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}

	public String readString() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		StringBuilder res = new StringBuilder();
		do {
			res.appendCodePoint(c);
			c = read();
		} while (!isSpaceChar(c));
		return res.toString();
	}

	public long readLong() {
		int c = read();
		while (isSpaceChar(c)) {
			c = read();
		}
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		long res = 0;
		do {
			if (c < '0' || c > '9') {
				throw new InputMismatchException();
			}
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}
	
	public boolean isSpaceChar(int c) {
		if (filter != null)
			return filter.isSpaceChar(c);
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}

	public String next() {
		return readString();
	}

	public interface SpaceCharFilter {
		public boolean isSpaceChar(int ch);
	}
}
"
25,"import java.util.*;
import static java.lang.System.*;
public class Main {
    public static void main(String[] args){
        Scanner sc = new Scanner(in);
        int n=sc.nextInt();
        String[] a=new String[n+1];
        for (int i = 1; i <= n; i++) {
            a[i]=sc.next();
        }
        String ans=a[1];
        if(n%2==0){
            for (int i = 2; i <= n; i++) {
                if(i%2==0){
                    ans=a[i]+"" ""+ans;
                }else{
                    ans=ans+"" ""+a[i];
                }
            }
        }else{
            for (int i = 2; i <= n; i++) {
                if(i%2==0){
                    ans=ans+"" ""+a[i];
                }else{
                    ans=a[i]+"" ""+ans;
                }
            }
        }
        out.println(ans);
    }
}"
26,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.math.BigDecimal;
import java.text.DecimalFormat;
import java.util.AbstractMap;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Set;
import java.util.Stack;
import java.util.TreeMap;
import java.util.TreeSet;

import static java.util.Comparator.*;

public class Main {

    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        MyInput in = new MyInput(inputStream);
        PrintWriter out = new PrintWriter(outputStream);

        Solver solver = new Solver(in, out);
        solver.solve();

        out.close();
    }

    // ======================================================================

    static class Solver {
    	MyInput in;
    	PrintWriter out;
        public Solver(MyInput in, PrintWriter out) {
        	this.in = in;
        	this.out = out;
        }
        
        // -----------------------------------------
        //
 		public void solve() {
			int N = ni();
			int K = ni();
			PP[] sushi = new PP[N];
			int t,d;
			for (int i = 0; i < N; i++) {
				t = ni();
				d = ni();
				sushi[i] = new PP(d, t);
			}
			// おいしさの大きい順に並べる
			Arrays.sort(sushi, Comparator.comparing(PP::getKey).reversed());
			
			MapCounter mc = new MapCounter();		// 計算に含まれる種類とその数
													// 計算に含まれていない、おいしさと種類（おいしさ順に並ぶ）
			PriorityQueue<PP> PQ = new PriorityQueue<PP>(comparing(PP::getKey, reverseOrder())); 
			// 初期の値を計算する
			long ans = 0;
			for (int i = 0; i < N; i++) {
				// おいしさの大きいものを　Ｋ個　足す
				if(i < K) {
					ans += sushi[i].getKey();
					mc.add(sushi[i].getVal());		//　種類の数をカウントする
				} else if(mc.getCount(sushi[i].getVal()) == 0){
					PQ.add(sushi[i]);				// 残りの寿司を突っ込む（まだ計算していない種類だけ）
				}
			}
			long kindCount = mc.getKeyCount();
			ans += kindCount * kindCount;
//			prn(""1  ans = "" + ans + "" kindCount = "" + kindCount);
			long wk = ans;
			PP p;
			for (int i = K - 1; i >= 0; i--) {
//				prn(""sushi["" + i + ""]  おいしさ = "" + sushi[i].getKey() + ""  種類 = "" + sushi[i].getVal() + ""  計算済みの個数 = "" + mc.getCount(sushi[i].getVal()));
				if(mc.getCount(sushi[i].getVal()) > 1) {	// ２種類以上入っていたら、変更できる
					p = PQ.poll();
					if(mc.getCount(p.getVal()) == 0) {		// 残りの寿司がまだ計算していない種類ならば、計算する
						wk = wk - (long)sushi[i].getKey() - (kindCount * kindCount) + (long)p.getKey() + (kindCount + 1) * (kindCount + 1);
//						prn("" wk = "" + wk + "" <-- 前回値 - "" + sushi[i].getKey() 
//								+ "" - ((kindCount = "" + kindCount + ""}^2 = "" + (kindCount * kindCount) + "") + ""
//								+ p.getKey() + "" + ((kindCount+1)^2 = "" + ((kindCount + 1) * (kindCount + 1)) + "")"");
						if(wk > ans) {
							ans = wk;
						}
						kindCount++;						// 種類を増やす
						mc.add(p.getVal());					// 計算に含まれる種類を追加する
						mc.sub(sushi[i].getVal());			// 減らした種類のカウントを減らす
					}
				}
			}
			prn(ans);
		}
        // -----------------------------------------
 		
        void prn(String s) {
        	out.println(s);
        }
        void prn(int i) {
        	out.println(i);
        }
        void prn(long i) {
        	out.println(i);
        }
        void prr(String s) {
        	out.print(s);
        }
        int ni() {
        	return in.nextInt();
        }
        long nl() {
        	return in.nextLong();
        }
        double nd() {
        	return in.nextDouble();
        }
        String ns() {
        	return in.nextString();
        }
        int[] ndi(int n) {
        	int[] ans = new int[n];
        	for(int i=0; i < n; i++) {
        		ans[i] = ni();
        	}
        	return ans;
        }
        long[] ndl(int n) {
        	long[] ans = new long[n];
        	for(int i=0; i < n; i++) {
        		ans[i] = nl();
        	}
        	return ans;
        }
        double[] ndd(int n) {
        	double[] ans = new double[n];
        	for(int i=0; i < n; i++) {
        		ans[i] = nd();
        	}
        	return ans;
        }
        String[] nds(int n) {
        	String[] ans = new String[n];
        	for(int i=0; i < n; i++) {
        		ans[i] = ns();
        	}
        	return ans;
        }
        int[][] nddi(int n, int m) {
        	int[][] ans = new int[n][m];
        	for(int i=0; i < n; i++) {
            	for(int j=0; j < m; j++) {
            		ans[i][j] = ni();
            	}
        	}
        	return ans;
        }
        long[][] nddl(int n, int m) {
        	long[][] ans = new long[n][m];
        	for(int i=0; i < n; i++) {
            	for(int j=0; j < m; j++) {
            		ans[i][j] = nl();
            	}
        	}
        	return ans;
        }
    }

    static class MapCounter {
    	private Map<Integer, Integer> map = new HashMap<Integer, Integer>();
    	public MapCounter() {}
    	public void add(int key) {
    		add(key, 1);
    	}
       	public void add(int key, int cnt) {
    		Integer val = map.get(key);
    		if(val == null) {
    			map.put(key, cnt);
    		} else {
    			map.put(key,  val + cnt);
    		}
    	}
    	public void sub(int key) {
    		sub(key, 1);
    	}
    	public void sub(int key, int cnt) {
    		Integer val = map.get(key);
    		if(val == null) {
    			map.put(key, -cnt);
    		} else {
    			map.put(key,  val - cnt);
    		}
    	}
    	public Integer getCountwithNull(int key) {
    		return map.get(key);
    	}
    	public int getCount(int key) {
    		Integer val = map.get(key);
    		if(val == null)		return 0;
    		else 				return val;
    	}
    	public Set<Integer> getKey() {
    		return map.keySet();
    	}
    	public int getKeyCount() {
    		return map.keySet().size();
    	}
    }
    static class PP{
    	public int key, val;
    	public PP(int key, int val) {
    		this.key = key;
    		this.val = val;
    	}
		public int getKey() {
			return key;
		}
		public void setKey(int key) {
			this.key = key;
		}
		public int getVal() {
			return val;
		}
		public void setVal(int val) {
			this.val = val;
		}
    }
    static class PPL {
    	public long key, val;
    	public PPL(long key, long val) {
    		this.key = key;
    		this.val = val;
    	}
		public long getKey() {
			return key;
		}
		public void setKey(long key) {
			this.key = key;
		}
		public long getVal() {
			return val;
		}
		public void setVal(long val) {
			this.val = val;
		}
    }
    static class PPDL {
    	public long key;
    	public long[] val;
    	public PPDL(long key, long[] val) {
    		this.key = key;
    		this.val = val;
    	}
		public long getKey() {
			return key;
		}
		public void setKey(long key) {
			this.key = key;
		}
		public long[] getVal() {
			return val;
		}
		public void setVal(long[] val) {
			this.val = val;
		}
		public void dump(PrintWriter out) {
			out.print(""key = "" + key + ""  val "");
			for(int i=0; i < val.length; i++) {
				out.print(""["" + val[i] + ""] "");
			}
			out.println("""");
		}
    }
    // HashMap のキーに使う
    static final class PPKEY{
    	private final int key, val;
    	public PPKEY(int key, int val) {
    		this.key = key;
    		this.val = val;
    	}
		public int getKey() {
			return key;
		}
		public int getVal() {
			return val;
		}
	    @Override
	    public boolean equals(Object obj) {
	        if (obj instanceof PPKEY) {
	        	PPKEY dest = (PPKEY) obj;
	            return this.key == dest.key && this.val == dest.val;
	        } else {
	            return false;
	        }
	    }
	    @Override
	    public int hashCode() {
	        return Objects.hash(key, val);
	    }
    }
    // HashMap のキーに使う
    static final class PPLKEY{
    	private final long key, val;
    	public PPLKEY(long key, long val) {
    		this.key = key;
    		this.val = val;
    	}
		public long getKey() {
			return key;
		}
		public long getVal() {
			return val;
		}
	    @Override
	    public boolean equals(Object obj) {
	        if (obj instanceof PPKEY) {
	        	PPKEY dest = (PPKEY) obj;
	            return this.key == dest.key && this.val == dest.val;
	        } else {
	            return false;
	        }
	    }
	    @Override
	    public int hashCode() {
	        return Objects.hash(key, val);
	    }
    }
    // グラフのリンクリスト
    static class Graph {
        private Map<Integer, List<Integer>> data = new HashMap<Integer, List<Integer>>();
        void add(int key, int value) {
        	List<Integer> list = data.get(key);
        	if(list == null) {
        		list = new ArrayList<Integer>();
        		data.put(key, list);
        	}
        	list.add(value);
        }
        List<Integer> get(int key) {
        	return data.get(key);
        }
        Set<Integer> keySet() {
        	return data.keySet();
        }
        boolean contains(int key, int value) {
        	List<Integer> list = data.get(key);
        	if(list == null)	return false;
        	else 				return list.contains(value);
        }
        void dump(PrintWriter out) {
        	for(int key : data.keySet()) {
        		out.print(key + "" : "");
        		for(int val : data.get(key)) {
        			out.print(val + "" "");
        		}
        		out.println("""");
        	}
        }
    }
    // 重さを持ったグラフのリンクリスト
    static class GraphWith {
        private Map<Integer, List<PP>> data = new HashMap<Integer, List<PP>>();
        void add(int key, PP p) {
        	List<PP> list = data.get(key);
        	if(list == null) {
        		list = new ArrayList<PP>();
        		data.put(key, list);
        	}
        	list.add(p);
        }
        List<PP> get(int key) {
        	return data.get(key);
        }
        // グラフの存在チェック（重さは関係しない）
        boolean contains(int key, int value) {
        	List<PP> list = data.get(key);
        	if(list == null)	return false;
        	boolean ans = false;
        	for(PP p : list) {
        		if(p.getKey() == value) {
        			ans = true;
        			break;
        		}
        	}
        	return ans;
        }
    }
    // グラフのリンクリスト(Long)
    static class GraphLong {
        private Map<Long, List<Long>> G = new HashMap<Long, List<Long>>();
        void add(long key, long value) {
        	List<Long> list = G.get(key);
        	if(list == null) {
        		list = new ArrayList<Long>();
        		G.put(key, list);
        	}
        	list.add(value);
        }
        List<Long> get(long key) {
        	return G.get(key);
        }
    }
    // 重さを持ったグラフのリンクリスト(Long)
    static class GraphLongWith {
        private Map<Long, List<PPL>> G = new HashMap<Long, List<PPL>>();
        void add(long key, PPL p) {
        	List<PPL> list = G.get(key);
        	if(list == null) {
        		list = new ArrayList<PPL>();
        		G.put(key, list);
        	}
        	list.add(p);
        }
        List<PPL> get(long key) {
        	return G.get(key);
        }
    }

    // ======================================================================
    static class Pair<K, V> extends AbstractMap.SimpleEntry<K, V> {
        /** serialVersionUID. */
        private static final long serialVersionUID = 6411527075103472113L;

        public Pair(final K key, final V value) {
            super(key, value);
        }
     }
    static class MyInput {
        private final BufferedReader in;
        private static int pos;
        private static int readLen;
        private static final char[] buffer = new char[1024 * 8];
        private static char[] str = new char[500 * 8 * 2];
        private static boolean[] isDigit = new boolean[256];
        private static boolean[] isSpace = new boolean[256];
        private static boolean[] isLineSep = new boolean[256];

        static {
            for (int i = 0; i < 10; i++) {
                isDigit['0' + i] = true;
            }
            isDigit['-'] = true;
            isSpace[' '] = isSpace['\r'] = isSpace['\n'] = isSpace['\t'] = true;
            isLineSep['\r'] = isLineSep['\n'] = true;
        }

        public MyInput(InputStream is) {
            in = new BufferedReader(new InputStreamReader(is));
        }

        public int read() {
            if (pos >= readLen) {
                pos = 0;
                try {
                    readLen = in.read(buffer);
                } catch (IOException e) {
                    throw new RuntimeException();
                }
                if (readLen <= 0) {
                    throw new MyInput.EndOfFileRuntimeException();
                }
            }
            return buffer[pos++];
        }

        public int nextInt() {
            int len = 0;
            str[len++] = nextChar();
            len = reads(len, isSpace);
            int i = 0;
            int ret = 0;
            if (str[0] == '-') {
                i = 1;
            }
            for (; i < len; i++) ret = ret * 10 + str[i] - '0';
            if (str[0] == '-') {
                ret = -ret;
            }
            return ret;
        }

        public long nextLong() {
            int len = 0;
            str[len++] = nextChar();
            len = reads(len, isSpace);
            int i = 0;
            long ret = 0L;
            if (str[0] == '-') {
                i = 1;
            }
            for (; i < len; i++) ret = ret * 10 + str[i] - '0';
            if (str[0] == '-') {
                ret = -ret;
            }
            return ret;
        }

        public double nextDouble() {
            int len = 0;
            str[len++] = nextChar();
            len = reads(len, isSpace);
            int i = 0;
            double ret = 0;
            if (str[0] == '-') {
                i = 1;
            }
            int cnt = 0;
            for (; i < len; i++) {
            	if(str[i] == '.') {
            		cnt = 10;
            		continue;
            	}
            	if(cnt == 0) {
            		ret = ret * 10 + str[i] - '0';
            	} else {
            		ret = ret + ((double)(str[i] - '0') / cnt);
            		cnt *= 10;
            	}
            }
            if (str[0] == '-') {
                ret = -ret;
            }
            return ret;
        }

       public String nextString() {
        	String ret = new String(nextDChar()).trim();
            return ret;
        }

        public char[] nextDChar() {
            int len = 0;
            len = reads(len, isSpace);
            char[] ret = new char[len + 1];
            for (int i=0; i < len; i++)		ret[i] = str[i];
            ret[len] = 0x00;
            return ret;
        }

        public char nextChar() {
            while (true) {
                final int c = read();
                if (!isSpace[c]) {
                    return (char) c;
                }
            }
        }

        int reads(int len, boolean[] accept) {
            try {
                while (true) {
                    final int c = read();
                    if (accept[c]) {
                        break;
                    }
                    if (str.length == len) {
                        char[] rep = new char[str.length * 3 / 2];
                        System.arraycopy(str, 0, rep, 0, str.length);
                        str = rep;
                    }
                    str[len++] = (char) c;
                }
            } catch (MyInput.EndOfFileRuntimeException e) {
            }
            return len;
        }

        static class EndOfFileRuntimeException extends RuntimeException {
        }
    }
}
"
27,"import java.util.*;
 class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        long a = in.nextLong();
        long b = in.nextLong();
        long x = in.nextLong();
        long count=0;
        for(int i=a;i<b;i++){
            if(i%x==0){
                count++;
            }
        }
        System.out.println(count);
    }

}"
28,"public class Main {
  public static void main(String[] args) {
    scanner sc = new Scanner(System.in);
    int x = sc.nextInt();
    int answer = x*x*x;
System.out.println(answer);}
 }"
29,"
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		String s = sc.next();

		for (int i = 0; i < s.length(); i += 2) {
			System.out.print(s.charAt(i));
		}
		System.out.println();
	}

}
"
30,"import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Deque;
import java.util.Scanner;

public class Main {
	static int n;
	static int[][] m = new int[100000][100000];

	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int n = scan.nextInt();
		for (int i = 0; i < n; i++) {
			m[scan.nextInt() - 1][scan.nextInt() - 1] = 1;
		}
		int[] ansF = bfs(0);
		int[] ansS = bfs(n - 1);
		int f = 0;
		int s = 0;
		int flag = 1;
		for (int i = 0; i < n; i++) {
			if (ansF[i] < ansS[i]) {
				f++;
			} else if (ansF[i] > ansS[i]) {
				s++;
			} else {
				if (flag % 2 == 1) {
					f++;
				} else {
					s++;
				}
			}
		}
		if (f > s) {
			System.out.println(""Fennec"");
		} else {
			System.out.println(""Snuke"");
		}

	}

	public static int[] bfs(int a) {
		int[] ans = new int[100001];
		Deque<Integer> q = new ArrayDeque<>();
		q.offer(a);
		Arrays.fill(ans, -1);
		ans[a] = 0;
		while (!q.isEmpty()) {
			int b = q.poll();
			for (int i = 0; i < n; i++) {
				if (m[b][i] == 0) {
					continue;
				}
				if (ans[i] != -1) {
					continue;
				}
				ans[i] = ans[b] + 1;
				q.offer(i);
			}
		}
		return ans;
	}
}"
31,"import java.util.*;
class Charan
{
  public static void main(String args[])
  {
    	Scanner sc=new Scanner(System.in);
    	int x=sc.nextInt();
    	System.out.println(x>=30?""Yes"":""No"");
  }
}"
32,"import java.util.Scanner;

class Main {  
  public static void main(String[] args) {
    Scanner in = new Scanner(System.in);
    int N = in.nextInt();
    int count = 0;

    while (N != 0) {
      int num = in.nextInt();
      if (isPrime(num)) count++;
      N--;
    }
    
    System.out.println(count);
  }
  
  public static boolean isPrime(int x) {
    if      (x == 2)     return true;
    else if (x % 2 == 0) return false;
    else {
      for (int i = 3; i < x; i += 2) {
        if (x % i == 0) return false;
      }
      return true;
    }
  }
}"
33,"import java.util.Scanner;
import java.util.Arrays;
public class Main {
    public static void main (String[] args) {
    Scanner sc = new Scanner(System.in);
	int N = sc.nextInt();
    int[] P = new int[N];
    int[] Ps = new int[N];
    int[] Q = new int[N];
    int[] Qs = new int[N];
    int a = 0; 
    int b = 0;
    int rank = 1;
    for(int i=0; i>N; i++){
    	P[i] = sc.nextInt();
        Ps[i] = P[i];
    }
    for(int i=0; i>N; i++){
    	Q[i] = sc.nextInt();
        Qs[i] = Q[i];
    } 
    Arrays.sort(Ps);
    Arrays.sort(Qs);
      
   for(int i=0; i<N-1;i++){
     int searchNumber = P[i];
     int x = 0;
     for(int j=0; j<N; j++){
     	if(searchNumber = Ps[i]){
          x = N - j;
          break;
        }
     }
   	 rank *= x;
   }
   a = rank;
   rank = 1;
      
     for(int i=0; i<N-1;i++){
     int searchNumber = Q[i];
     int x = 0;
     for(int j=0; j<N; j++){
     	if(searchNumber = Qs[i]){
          x = N - j;
          break;
        }
     }
   	 rank *= x;
   }
   b = rank;
      
   int answer = a - b;
   if(answer < 0) answer = -answer;
   System.out.println(answer);   
    }
}"
34,"import java.util.Scanner;

class Main {
	public static void main(String[] args)
	{
		Scanner input = new Scanner(System.in);
		
		while (true){
			int N = input.nextInt();
			int X = input.nextInt();
			if (N == 0 && X == 0) break;
			
			System.out.println(pat(N, X, 3));
		}
		
	}
	
	static int pat(int n, int x, int cost)
	{
		if (cost == 0 && x == 0) return 1;
		else if (x == 0 || n == 0) return 0;
		
		
		return pat(n - 1, x - n, cost - 1) + pat(n - 1, x, cost);
	}
}"
35,"import java .util.*;
class Main 
{
public static void main (String[] args)
{
Scanner sc = new Scanner(System.in);
int n = sc.nextInt();
int[] a= new int[100];
int k =0;
do{
int m= n%4;
if(m==2) m=-2;
else if(m==3) m=-1;
n-=m;
n /=4;

if(m==0){a[k] =0; a[k++]=0;}
else if(m ==1){a[k] =1; a[k++]=0}
else if(m==-2){a[k]=0;a[k++]=1;}
else{a[k]=1;a[k++]=1;}
}while(n>0);
for(int i =k;i>=0;i--)
{
System.out.print(a[i]);
}
}
}"
36,"import java.util.Scanner;

public class Main{
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		String s = sc.next();
		long n = sc.nextLong();
		for(int i = 0; i < s.length(); i++) {
			if(s.charAt(i) != '1') {
				if(n < i+1) {
					System.out.println(1);
				} else {
					System.out.println(s.charAt(i));
				}
				return;
			}
		}
		System.out.println(1);
	}
}
"
37,"public class Main { //クラス名はMain
    public static void main(String[] args) {
      	Scanner sc = new Scanner(System.in);
		int n1 = Integer.parseInt(sc.next());
     	int n2 = Integer.parseInt(sc.next());
     	int n3 = Integer.parseInt(sc.next());
      	int cnt = 0;
      
      	if( n1 == n2 ){
          cnt++;
        }
      	if( n2 == n3 ){
          cnt++;
        }
      	if( n3 == n1 ){
          cnt++;
        }
      
      	if( cnt == 1 ){
       	 System.out.println(""Yes"");
        }else{
          System.out.println(""No"");
        }
    }
}"
38,"import java.util.Scanner;

public class Main {
	
	public Main(){
		Scanner sc = new Scanner(System.in);
		int a,b,k;
		int w[]=new int[7];

		for(k=0;k<7;k++){
	a = sc.nextInt();
	b = sc.nextInt();
	System.out.println(a - b);
}
}
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ
         Main w = new Main();
	}

}"
39,"import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int A = sc.nextInt();
		int B = sc.nextInt();
		String ans = """";

		if (A % 2 != B % 2) {
			ans = ""IMPOSSIBLE"";
		} else {
			ans = String.valueOf((A + B) / 2);

		}

		System.out.println(ans);
		sc.close();

	}
}
"
40,"import java.util.Scanner;

public class Haiku{
	public static void main(String[] args)
	{
		Scanner sc =new Scanner(System.in);
		String op=sc.next();

		op=op.replace("","","" "");
		
		System.out.println(op);	
	}
	
} "
41,"import java.util.Scanner;
 
class Main {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
 
        int n = scan.nextInt();
        int m = scan.nextInt();
        int [][]A;
        A = new int[n][m];
        int []b;
        b = new int[m];
        int []c;
        c = new int[n];
        int i,j;
 
        for(i = 0; i < n; i++){
            for(j = 0; j < m; j++){
            A[i][j] = scan.nextInt;
            }
        }
 
        for(j = 0; j < m ; j++){
        b[j] = scan.nextInt;
        }
 
        for(i = 0; i < n; i++){
            for(j = 0; j < m; j++){
            c[i] += A[i][j]*b[j];
            }
        }
        System.out.println(c[i]);
         
    }
}"
42,"
import java.util.Scanner;

public class Main {
    static Scanner sc = new Scanner(System.in);


    public static void main(String[] args) {
        String s = sc.next();
        int count = 0;
        for (int i = 0; i < s.length(); i++) {
            for (int j = 0; j < i; j++) {
                long value = Long.parseLong(s.substring(j, i + 1));
                if (value % 2019 == 0) {
                    count++;
                }
            }
        }
        System.out.println(count);
    }
}
"
43,"
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Deque;
import java.util.PriorityQueue;
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {

		new Main().run();
	}

	private void run() {
		Scanner scanner = new Scanner(System.in);
		while (true) {
			w = scanner.nextInt();
			h = scanner.nextInt();
			if ((w | h) == 0)
				break;
			int[][] map = new int[h][w];
			Point s = new Point();
			Point g = new Point();
			for (int i = 0; i < h; i++) {
				String str = scanner.next();
				for (int j = 0; j < w; j++) {
					char now = str.charAt(j);
					if (now == 'S') {
						s.y = i;
						s.x = j;
						map[i][j] = -1;
					} else if (now == 'G') {
						g.y = i;
						g.x = j;
						map[i][j] = -1;
					} else if (now == '#')
						map[i][j] = 0;
					else if (now == '.')
						map[i][j] = -1;
					else
						map[i][j] = -2;
				}
			}
			for (int i = 0; i < h; i++) {
				for (int j = 0; j < w; j++) {
					if (map[i][j] != -2)
						continue;
					int a = slove(i, j, map, -2);
					for (int k = 0; k < h; k++)
						for (int l = 0; l < w; l++)
							if (map[k][l] == -3)
								map[k][l] = a;

				}
			}
			PriorityQueue<Point> pq = new PriorityQueue<Point>();
			int[][] tmpMap = map.clone();
			int md = Math.abs(s.y - g.y) + Math.abs(s.x - g.x);
			boolean[][] b = new boolean[h][w];
			b[s.y][s.x] = true;
			pq.offer(new Point(s.y, s.x, 0, md, tmpMap, b));
			int ans = 0;
			while (!pq.isEmpty()) {
				Point point = pq.poll();
				if (point.y == g.y && point.x == g.x) {
					ans = point.step;
					break;
				}
				for (int[] mo : move) {
					int ny = point.y + mo[0];
					int nx = point.x + mo[1];
					if (!isOK(ny, nx))
						continue;
					if (point.map[ny][nx] == 0)
						continue;
					if (point.b[ny][nx])
						continue;
					int[][] tmp = new int[h][w];
					for (int i = 0; i < h; i++)
						tmp[i] = Arrays.copyOf(point.map[i], w);
					if (tmp[ny][nx] != -1) {
						slove(ny, nx, tmp, tmp[ny][nx]);
					}
					boolean[][] tb = new boolean[h][w];
					for(int i = 0;i<h;i++)
						tb[i] = Arrays.copyOf(point.b[i], w);
					tb[ny][nx] = true;
					int nmd = Math.abs(ny - g.y) + Math.abs(nx - g.x);
					pq.offer(new Point(ny, nx, point.step + 1, nmd + point.step
							+ 1, tmp, tb));
				}
			}
			System.out.println(ans);

		}
	}

	private int slove(int y, int x, int[][] map, int k) {
		Deque<Point> deque = new ArrayDeque<Main.Point>();
		int count = 1;
		deque.push(new Point(y, x));
		loop: while (!deque.isEmpty()) {
			Point point = deque.peek();
			map[point.y][point.x] = k - 1;
			for (int[] m : move) {
				int ny = point.y + m[0];
				int nx = point.x + m[1];
				if (!isOK(ny, nx))
					continue;
				if (map[ny][nx] != k)
					continue;
				deque.push(new Point(ny, nx));
				count++;
				continue loop;
			}
			deque.poll();
		}
		return count / 2;
	}

	boolean isOK(int y, int x) {
		if (0 <= y && y < h && 0 <= x && x < w)
			return true;
		return false;
	}

	int w, h;
	int[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };

	class Point implements Comparable<Point> {
		int y, x;
		int step, md;
		int[][] map;
		boolean[][] b;

		public Point(int y, int x, int step, int md, int[][] map, boolean[][] b) {
			super();
			this.y = y;
			this.x = x;
			this.step = step;
			this.md = md;
			this.map = map;
			this.b = b;
		}

		Point() {
		}

		public Point(int y, int x) {
			super();
			this.y = y;
			this.x = x;
		}

		@Override
		public String toString() {
			StringBuilder builder = new StringBuilder();
			for (int[] m : map)
				builder.append(Arrays.toString(m)).append('\n');
			for (boolean[] bb : b)
				builder.append(Arrays.toString(bb)).append('\n');
			return ""Point [y="" + y + "", x="" + x + "", step="" + step + "", md=""
					+ md + "", map=\n"" + builder + ""]"";
		}

		@Override
		public int compareTo(Point o) {
			if(this.md==o.md)
				return o.step-this.step;
			return this.md - o.md;
		}

	}
}"
44,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.StringTokenizer;
import java.io.PrintWriter;

public class Main {
    static class Scanner {
        BufferedReader br;
        StringTokenizer tk = new StringTokenizer("""");

        public Scanner(InputStream is) {
            br = new BufferedReader(new InputStreamReader(is));
        }

        public int nextInt() throws IOException {
            if (tk.hasMoreTokens())
                return Integer.parseInt(tk.nextToken());
            tk = new StringTokenizer(br.readLine());
            return nextInt();
        }

        public long nextLong() throws IOException {
            if (tk.hasMoreTokens())
                return Long.parseLong(tk.nextToken());
            tk = new StringTokenizer(br.readLine());
            return nextLong();
        }

        public String next() throws IOException {
            if (tk.hasMoreTokens())
                return (tk.nextToken());
            tk = new StringTokenizer(br.readLine());
            return next();
        }

        public String nextLine() throws IOException {
            tk = new StringTokenizer("""");
            return br.readLine();
        }

        public double nextDouble() throws IOException {
            if (tk.hasMoreTokens())
                return Double.parseDouble(tk.nextToken());
            tk = new StringTokenizer(br.readLine());
            return nextDouble();
        }

        public char nextChar() throws IOException {
            if (tk.hasMoreTokens())
                return (tk.nextToken().charAt(0));
            tk = new StringTokenizer(br.readLine());
            return nextChar();
        }

        public int[] nextIntArray(int n) throws IOException {
            int a[] = new int[n];
            for (int i = 0; i < n; i++)
                a[i] = nextInt();
            return a;
        }

        public long[] nextLongArray(int n) throws IOException {
            long a[] = new long[n];
            for (int i = 0; i < n; i++)
                a[i] = nextLong();
            return a;
        }

        public int[] nextIntArrayOneBased(int n) throws IOException {
            int a[] = new int[n + 1];
            for (int i = 1; i <= n; i++)
                a[i] = nextInt();
            return a;
        }

        public long[] nextLongArrayOneBased(int n) throws IOException {
            long a[] = new long[n + 1];
            for (int i = 1; i <= n; i++)
                a[i] = nextLong();
            return a;
        }


    }

    public static void main(String args[]) throws IOException {
        new Thread(null, new Runnable() {
            public void run() {
                try {
                    solve();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }, ""1"", 1 << 26).start();

    }
    static ArrayList<Integer> g[][];
    static int n, m;
    static int dp[][][][];
    static void solve() throws IOException {
        Scanner in = new Scanner(System.in);
        PrintWriter out = new PrintWriter(System.out);
        n=in.nextInt();
        m=in.nextInt();
        g=new ArrayList[n+1][4];
        for(int i=0;i<=n;i++)
            for(int j=0;j<4;j++)
                g[i][j]=new ArrayList<>();

        dp=new int[2][3][][];
        for(int i=0;i<2;i++){
            for(int j=0;j<3;j++){
                dp[i][j]=new int[n+2][];
                for(int k=0;k<n+2;k++)
                    dp[i][j][k]=new int[n+2];
            }
        }

        for(int i=0;i<m;i++){
            int l=in.nextInt();
            int r=in.nextInt();
            int x=in.nextInt();
            g[r][x].add(l);
            
        }

        for(int i=n+1;i>0;i--) {
            for(int lcu=0;lcu<3;lcu++){
                for(int c1=0;c1<i;c1++)
                    for(int c2=0;c2<i;c2++){
                        if(c1!=0 && c1==c2)
                            continue;
                        boolean val=true;
                        for(int ct=1;ct<=3;ct++){
                            for(int x:g[i-1][ct]){
                                int vv=1;
                                if(c1>=x)
                                    vv++;
                                if(c2>=x)
                                    vv++;
                                if(vv!=ct)
                                {
                                    val=false;
                                    ct=5;
                                    break;
                                }
                            }
                        }
                        if(!val){
                            dp[i&1][lcu][c1][c2]=0;
                            continue;
                        }

                        if(i==n+1) {
                            dp[i&1][lcu][c1][c2] = 1;
                            continue;
                        }
                        long rrx=0;
                        rrx+=dp[(i+1)&1][lcu][c1][c2];
                        rrx+=dp[(i+1)&1][(lcu+1)%3][c2][i-1];
                        rrx+=dp[(i+1)&1][(lcu+2)%3][i-1][c1];
                        dp[i&1][lcu][c1][c2]=(int)(rrx%mod);
                    }
            }
        }
        out.println(dp[1][0][0][0]);
        out.close();

    }
    static int mod=1000000007;
//    static int sol(int i, int lcu, int c1,int c2){
//        if(i!=n+1 && dp[i][lcu][c1][c2]!=-1)
//            return dp[i][lcu][c1][c2];
//        for(int ct=1;ct<=3;ct++){
//            for(int x:g[i-1][ct]){
//                int vv=1;
//                if(c1>=x)
//                    vv++;
//                if(c2>=x)
//                    vv++;
//                if(vv!=ct)
//                    if(i==n+1)
//                        return 0;
//                    else
//                        return dp[i][lcu][c1][c2]=0;
//            }
//
//
//        }
//        if(i==n+1)
//            return 1;
//        long rrx=sol(i+1,lcu,c1,c2);
//        rrx+=sol(i+1, (lcu+1)%3, c2, i-1);
//        rrx+=sol(i+1, (lcu+2)%3, i-1, c1);
//        return (dp[i][lcu][c1][c2]=(int)(rrx%mod));
//    }
}
"
45,"import java.util.Scanner;

class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int a = 0;
    char c = 0;
    int b = 0;
    while (true) {
      a = sc.nextInt();
      op = sc.next();
      b = sc.nextInt();
      if (op == '?') break;
      switch (op) {
        case '+' :
          System.out.println(a + b); break;
        case '-' :
          System.out.println(a - b); break;
        case '*' :
          System.out.println(a * b); break;
        case '/' :
          System.out.println(a / b); break;
       }
    }
}
"
46,"import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;

class Main {
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int n = Integer.parseInt(br.readLine());

        String[] input = br.readLine().split("" "");

        int[] from = new int[n];
        int[] to = new int[n];

        int max = -1;

        for (int i = 0; i < n; i++) {
            from[i] = Integer.parseInt(input[i]);
            max = Math.max(from[i], max);
        }

        CountingSort(from, to, max);

        StringBuilder sb = new StringBuilder();
        sb.append(to[0]);

        for (int i = 1; i < n; i++) {
                sb.append("" "" + to[i]);
        }

        System.out.println(sb);
    }

    static void CountingSort(int[] A, int[] B, int k) {
        int[] C = new int[k + 1];
        int length = A.length;

        /*
        for (int i = 0; i < k + 1; i++) 
            C[i] = 0;
        */
        int i; // to avoid TLE

        for (i = 0; i < length; i++) 
            C[A[i]]++;

        for (i = 1; i < k + 1; i++) 
            C[i] += C[i - 1];
        
        for (i = length - 1; i >= 0; i--)
            B[--C[A[i]]] = A[i];
        
    }

}
"
47,"import java.util.Scanner;

	public class Main {

		public static void main(String[] args) {

			Scanner sc = new Scanner(System.in);
			
			int n = sc.nextInt();
			long[] a = new long[n];
			long[] num = new long[n+1];
			
			for(int i=0;i<n;i++) {
				a[i] = sc.nextInt();
				num[(int)a[i]]++;
			}
			
			int aret = 0;
			
			for(int i=0;i<n;i++) {
				if(num[i]<=1) {
					continue;
				}else {
					aret+=num[i]*(num[i]-1)/2;
				}
				
			}
			
			for(int i=0;i<n;i++) {
				System.out.println(aret-num[(int)a[i]]+1);
			}
			
			
	    }
				
	}
"
48,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner std = new Scanner(System.in);
        String s = std.next();
        String reversed = new StringBuilder(s).reverse().toString();

        String[] texts = {""dream"", ""dreamer"", ""erase"", ""eraser""};
        String[] reversedText = new String[texts.length];
        for (int i = 0; i < texts.length; i++) {
            reversedText[i] = new StringBuilder(texts[i]).reverse().toString();
        }


        while (!reversed.isEmpty()) {
            boolean updated = false;
            for (int i = 0; i < reversedText.length; i++) {
                String r = reversedText[i];
                if (reversed.startsWith(r)) {
                    reversed = reversed.substring(r.length());
                    updated = true;
                }
            }

            if (!updated) {
                System.out.println(""NO"");
                return;
            }
        }

        System.out.println(""YES"");
    }
}
"
49,"import java.io.InputStream;
import java.io.IOException;
import java.io.FileNotFoundException;
import java.io.FileInputStream;
import java.util.PriorityQueue;
import java.util.HashSet;
import java.util.List;
import java.util.InputMismatchException;
import java.util.Set;
import java.io.PrintWriter;
import java.util.ArrayList;

public class Main {
    InputStream is;

    int __t__ = 1;
    int __f__ = 0;
    int __FILE_DEBUG_FLAG__ = __f__;
    String __DEBUG_FILE_NAME__ = ""src/main/java/F5"";

    FastScanner in;
    PrintWriter out;

    class State {
        final int id;
        final int cnt;

        public State(int id, int cnt) {
            this.id = id;
            this.cnt = cnt;
        }
    }

    public void solve() {
        int n = in.nextInt();
        int k = in.nextInt();
        int[] a = in.nextIntArray(n);
        PriorityQueue<State> pq = new PriorityQueue<>((st1, st2) -> {
            double b1 = (double) a[st1.id] / (st1.cnt + 1);
            double b2 = (double) a[st2.id] / (st2.cnt + 1);
            return Double.compare(b2, b1);
        });
        for (int i = 0; i < n; i++) {
            pq.add(new State(i, 0));
        }

        for (int i = 0; i < k; i++) {
            State st = pq.poll();
            pq.add(new State(st.id, st.cnt + 1));
        }
        State peek = pq.peek();
        System.out.println((a[peek.id] + peek.cnt) / (peek.cnt + 1));
    }

    public void run() {
        if (__FILE_DEBUG_FLAG__ == __t__) {
            try {
                is = new FileInputStream(__DEBUG_FILE_NAME__);
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            }
            System.out.println(""FILE_INPUT!"");
        } else {
            is = System.in;
        }
        in = new FastScanner(is);
        out = new PrintWriter(System.out);

        solve();
    }

    public static void main(final String[] args) {
        new Main().run();
    }
}


class FastScanner {
    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;

    public FastScanner(InputStream stream) {
        this.stream = stream;
        // stream = new FileInputStream(new File(""dec.in""));
    }

    int read() {
        if (numChars == -1)
            throw new InputMismatchException();
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            } catch (IOException e) {
                throw new InputMismatchException();
            }
            if (numChars <= 0)
                return -1;
        }
        return buf[curChar++];
    }

    public boolean isSpaceChar(int c) {
        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    public boolean isEndline(int c) {
        return c == '\n' || c == '\r' || c == -1;
    }

    public int nextInt() {
        return Integer.parseInt(next());
    }

    public int[] nextIntArray(int n) {
        int[] array = new int[n];
        for (int i = 0; i < n; i++)
            array[i] = nextInt();

        return array;
    }

    public int[][] nextIntMap(int n, int m) {
        int[][] map = new int[n][m];
        for (int i = 0; i < n; i++) {
            map[i] = nextIntArray(m);
        }
        return map;
    }

    public long nextLong() {
        return Long.parseLong(next());
    }

    public long[] nextLongArray(int n) {
        long[] array = new long[n];
        for (int i = 0; i < n; i++)
            array[i] = nextLong();

        return array;
    }

    public long[][] nextLongMap(int n, int m) {
        long[][] map = new long[n][m];
        for (int i = 0; i < n; i++) {
            map[i] = nextLongArray(m);
        }
        return map;
    }

    public double nextDouble() {
        return Double.parseDouble(next());
    }

    public double[] nextDoubleArray(int n) {
        double[] array = new double[n];
        for (int i = 0; i < n; i++)
            array[i] = nextDouble();

        return array;
    }

    public double[][] nextDoubleMap(int n, int m) {
        double[][] map = new double[n][m];
        for (int i = 0; i < n; i++) {
            map[i] = nextDoubleArray(m);
        }
        return map;
    }

    public String next() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        StringBuilder res = new StringBuilder();
        do {
            res.appendCodePoint(c);
            c = read();
        } while (!isSpaceChar(c));
        return res.toString();
    }

    public String[] nextStringArray(int n) {
        String[] array = new String[n];
        for (int i = 0; i < n; i++)
            array[i] = next();

        return array;
    }

    public String nextLine() {
        int c = read();
        while (isEndline(c))
            c = read();
        StringBuilder res = new StringBuilder();
        do {
            res.appendCodePoint(c);
            c = read();
        } while (!isEndline(c));
        return res.toString();
    }

    public int[][] nextPackedIntArrays(int packN, int size) {
        int[][] res = new int[packN][size];
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < packN; j++) {
                res[j][i] = nextInt();
            }
        }
        return res;
    }
}
"
50,"import java.util.Scanner;

public class Main{
    private static final int MOD = 1000000007;

    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] a = new int[n];
        int[] b = new int[n];
        long[][] p = new long[4002][4002];
        long[][] d = new long[4002][4002];
        for(int i=0;i<n;i++){
            a[i] = sc.nextInt();
            b[i] = sc.nextInt();
            p[2001-a[i]][2001-b[i]]++;
        }
        d[1][1]=1;
        for(int i=1;i<4002;i++)for(int j=1;j<4002;j++){
            p[i][j]+=(p[i-1][j]%MOD+p[i][j-1]%MOD)%MOD;
            d[i][j]+=(d[i-1][j]%MOD+d[i][j-1]%MOD)%MOD;
        }
        long ans = 0L;
        long dbl = 0L;
        for(int i=0;i<n;i++){
            ans=(ans+p[2001+a[i]][2001+b[i]])%MOD;
            dbl=(dbl+d[2*a[i]+1][2*b[i]+1])%MOD;
        }
        System.out.println((ans-dbl)*500000004%MOD);
    }
}"
51,"import java.util.*;

public class Main {
    public static void main(String[] args) throws Exception {
        // Your code here!
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] colors = new int[9];
        
        while (n-- > 0) {
            int rate = sc.nextInt();
            int colorNumber = getColor(rate);
            colors[colorNumber]++;
        }
        
        int min = 0;
        int max = 0;
        for (int i = 0; i < 8; i++) {
            if (colors[i] > 0) min++;
        }
        if (min == 0) {
            min = 1;
            max = Math.min(8, colors[8]);
            }
        } else {
            max = Math.min(8, min + colors[8]);
        }
        
        System.out.println(min + "" "" + max);
    }
    
    public static int getColor(int rate) {
        if (rate < 400) {
            return 0;
        } else if (rate < 800) {
            return 1;
        } else if (rate < 1200) {
            return 2;
        } else if (rate < 1600) {
            return 3;
        } else if (rate < 2000) {
            return 4;
        } else if (rate < 2400) {
            return 5;
        } else if (rate < 2800) {
            return 6;
        } else if (rate < 3200) {
            return 7;
        }
        return 8;
    }
}
"
52,"import java.util.*;

public class Test {
	public static void main(String[] args){
		Scanner scanner = new Scanner(System.in);
		String next;
		int op1, op2;
		Stack<Integer> stack = new Stack<Integer>();

		while(scanner.hasNext()){
			next = scanner.next();
			switch(next){
				case ""+"":
					op1 = stack.pop();
					op2 = stack.pop();
					stack.push(op2+op1);
					break;
				case ""-"":
					op1 = stack.pop();
					op2 = stack.pop();
					stack.push(op2-op1);
					break;
				case ""*"":
					op1 = stack.pop();
					op2 = stack.pop();
					stack.push(op2*op1);
					break;
				default :
					stack.push(Integer.parseInt(next));
			}
		}

		System.out.println(stack.pop());

	}
}"
53,"import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.util.NoSuchElementException;

public class Main {
	static FastScanner sc = new FastScanner();
	static PrintStream out = System.out;

	public static void main(String args[]) {
		int N = ni();
		int A = ni();
		int x[] = na(N);
		long sum = 0;
		for (int i=0;i<N;i++) {
			sum += x[i];
		}
		

		long ans = 0;
		for (int i=1;i<=N;i++) {
			long ret = 0;
			int size1 = A * i * i;
			int size2 = (int) ((sum - (A * i)) * (N-i));
			if (size1 < size2)
				ret = calc(A * i, i, x);
			else
				ret = calc((int) (sum - A * i), N - i, x);
			ans += ret;

		}

		System.out.println(ans);
	}

	private static long calc(int removeSum, int removeNum, int x[]) {
		int N = x.length;
		long dp[][][] = new long[N+1][removeNum+1][2600];

		for (int i=0;i<=removeNum;i++) {
			for (int j=0;j<2600;j++) {
				dp[0][i][j] = 0;
			}
		}
		dp[0][0][0] = 1;

		for (int i=0;i<N;i++) {
			for (int j=0;j<=removeNum;j++) {
				for (int k=0;k<2600;k++) {
					// dont choice
					dp[i+1][j][k] += dp[i][j][k];
					
					// choice
					if (k+x[i] < 2600 && j < removeNum)
						dp[i+1][j+1][k+x[i]] += dp[i][j][k];
				}
			}
		}
		
		return dp[N][removeNum][removeSum];
	}

	private static String next() {
		return sc.next();
	}

	private static int ni() {
		return sc.nextInt();
	}

	private static long nl() {
		return sc.nextLong();
	}

	private static int[] na(int n) {
		int[] a = new int[n];
		for(int i = 0;i < n;i++) a[i] = ni();
		return a;
	}

	private static long[] nal(int n) {
		long[] a = new long[n];
		for(int i = 0;i < n;i++) a[i] = ni();
		return a;
	}

    private static double nd() {
        return Double.parseDouble( next() );
    }
}

class FastScanner {
    private final InputStream in = System.in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}
    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}
    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}
    public boolean hasNext() { skipUnprintable(); return hasNextByte();}
    public String next() {
        if (!hasNext()) throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
    public int nextInt() {
        if (!hasNext()) throw new NoSuchElementException();
        int n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while(true){
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public long nextLong() {
        if (!hasNext()) throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while(true){
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
}
"
54,"

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		String s = sc.nextLine();
		int k = Integer.parseInt(sc.nextLine());

		List<String> dic = new ArrayList<>();

		String term = """";

		for(int i = 0; i < s.length(); i++){
			String sub = s.substring(i);
			for(int j = 1; j < sub.length() + 1; j++){
				term = sub.substring(0, j);
				if(!dic.contains(term)) dic.add(term);
				}
		}

		Collections.sort(dic);
		System.out.println(dic.get(k-1));
	}

}
"
55,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.StringTokenizer;

/**
 * Block
 */
public class Main {

	static int[][] board;
	final static int BLOCK_WIDTH = 4;
	final static int BLOCK_HEIGHT = 2;
	final static int EMPTY = 0;

	static int w, h;

	public static void main(String[] args) throws IOException {

		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String line = """";

		while (!(line = br.readLine()).equals(""0 0"")) {

			w = Integer.parseInt(line.substring(0, line.indexOf(' ')));
			h = Integer.parseInt(line.trim().substring(line.indexOf(' ') + 1));

			board = new int[w + 1][h + 1];

			line = br.readLine();
			int xs = Integer.parseInt(line.substring(0, line.indexOf(' ')));
			int ys = Integer.parseInt(line.substring(line.indexOf(' ') + 1));

			line = br.readLine();
			int xg = Integer.parseInt(line.substring(0, line.indexOf(' ')));
			int yg = Integer.parseInt(line.substring(line.indexOf(' ') + 1));

			int n = Integer.parseInt(br.readLine());
			for (int i = 0; i < n; ++i) {
				putBlock(br.readLine());
			}

			if (solve(xs, ys, xg, yg)) {
				System.out.println(""OK"");
			} else {
				System.out.println(""NG"");
			}

		}

	}

	static void putBlock(String info) {
		StringTokenizer st = new StringTokenizer(info);

		int c, d, x, y;
		c = Integer.parseInt(st.nextToken());
		d = Integer.parseInt(st.nextToken());
		x = Integer.parseInt(st.nextToken());
		y = Integer.parseInt(st.nextToken());

		putBlock(c, d, x, y);
	}

	static void putBlock(int c, int d, int x, int y) {

		if (d == 0) {
			for (int i = x; i < x + BLOCK_WIDTH; ++i) {
				for (int j = y; j < y + BLOCK_HEIGHT; ++j) {
					// assert board[i][j] == EMPTY;
					board[i][j] = c;
				}
			}
		} else {
			for (int i = x; i < x + BLOCK_HEIGHT; ++i) {
				for (int j = y; j < y + BLOCK_WIDTH; ++j) {
					// assert board[i][j] == EMPTY;
					board[i][j] = c;
				}
			}
		}
	}

	static boolean solve(int xs, int ys, int xg, int yg) {

		final int V[] = { 1, -1, 0, 0 };
		final int H[] = { 0, 0, 1, -1 };

		if (board[xs][ys] != board[xg][yg]) {
			return false;
		}

		int[] next, prev;
		int color = board[xs][ys];

		next = new int[] { xs, ys };
		ArrayDeque<int[]> queue = new ArrayDeque<int[]>();

		queue.offer(next);
		board[xs][ys] = EMPTY;

		while (!queue.isEmpty()) {

			prev = queue.poll();

			int px, py, nx, ny;
			px = prev[0];
			py = prev[1];
			board[px][py] = EMPTY;

			if (px == xg && py == yg) {
				return true;
			}

			for (int i = 0; i < 4; ++i) {
				nx = px + V[i];
				ny = py + H[i];
				if (nx > 0 && nx < w + 1 && ny > 0 && ny < h + 1) {
					if (board[nx][ny] == color) {
						queue.offer(new int[] { nx, ny });
						board[nx][ny] = EMPTY;
					}
				}
			}
		}

		return false;
	}
}"
56,"/* package whatever; // don't place package name! */

import java.util.*;
import java.lang.*;
import java.io.*;

/* Name of the class has to be ""Main"" only if the class is public. */
class Main
{
	public static void main (String[] args) throws java.lang.Exception
	{
		// your code goes here
		Scanner scanner = new Scanner(System.in);
		
		int n = Integer.parseInt(scanner.nextLine());
		
		ArrayList<Integer> num = new ArrayList<Integer>();
		for(int i = 0;i < n;i++){
			num.add(Integer.parseInt(scanner.nextLine()));
		}
		
		scanner.close();
		
		int max = Integer.MIN_VALUE;
		int num1,num2;
		int max_tmp = Integer.MIN_VALUE;
		
		for(int i = 0;i < n;i++){
			num1 = num.get(i);
			for(int j = i+1;j < n;j++){
				num2 = num.get(j);
				if(num2 - num1 > max_tmp){
					max_tmp = num2 - num1;
				}
			}
			if(max_tmp > max){
				max = max_tmp;
			}
		}
		System.out.println(max);
		
	}
}
"
57,"import java.util.Scanner;

public class Main{
  public static void main(String[] args){
    Scanner sc = new Scanner(System.in);
    while(true){
    int n = sc.nextInt();
    if(n==0){
      break;
    }
    for(int i=0;i<scores.length;i++){
      scores[i]=sc.nextInt();
    }
    double average=0;,variance=0;
    for(i=0;i<n;i++){
      average+=(double)score[i]/n;
      variance+=(double)(scores[i]-average)*(scores[i]-average)/n;
    }
    System.out.println(Math.sqrt(variance));
    }
  }
}"
58,"import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		String s = sc.next();
		String ans = """";
		for(int i=0;i<s.length();i+=2){
			ans += s.charAt(i);
		}
		System.out.println(ans);
		
	}

}
"
59,"import java.util.Scanner;

public class TaskA {

    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        String str = s.next();
        char[] ch = str.toCharArray();
        int i = 0;
        int maxcount = 0;
        while(i < ch.length) {
            if(ch[i] != 'R') {
                i++;
                continue;
            }
            int count= 0;
            while ( i < ch.length && ch[i] == 'R') {
                count++;
                i++;
            }

            maxcount = Math.max(maxcount, count);
            i++;
        }

        System.out.println(maxcount);
    }

}
"
60,"import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Scanner;


public class Main {

	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);

		long input = in.nextLong();
		Map<Long, Integer> m = primeFactorize(input);
		System.out.print(input+"":"");
		for(Entry<Long, Integer> e : m.entrySet()) {
			long prime = e.getKey();
			int ite = e.getValue();
			for (int i=0;i<ite;i++) {
				System.out.print("" ""+prime);
			}
		}
		System.out.println();
	}

	static public Map<Long, Integer> primeFactorize(long n) {
		Map<Long, Integer> res = new LinkedHashMap<Long, Integer>();
		long tmp=n;
		for (long i=2;i*i<=n;i++) {
			int count=0;
			while (tmp%i==0) {
				tmp/=i;
				count++;
			}
			if (count!=0) res.put(i, count);
		}
		if (tmp!=1) res.put(tmp, 1);
		if (res.size()==0) res.put(n, 1);
		return res;
	}
}"
61,"import java.util.*;
 
public class Main{
	public static void main(String [] args){
		Scanner sc = new Scanner(System.in);
		int people = sc.nextInt();
      	int firstPoint = sc.nextInt();
      	int correct = sc.nextInt();
      	int[] point = new int[people];
      	Arrays.fill(point, firstPoint-correct);
      	int correctPerson = 0;
      	for(int i = 0; i < correct; i++){
        	correctPerson = sc.nextInt();
          	point[correctPerson-1] += 1;
        }
      	for(int j = 0; j < correct; j++){
        	if(point[j] > 0){
            	System.out.println(""YES"");
            }else if(point[j] <= 0){
            	System.out.println(""NO"");
            }
        }     	
	}
}"
62,"import java.io.*;
import java.util.*;

public class Main
{
    public static void main(String[] args)
    {
        InputStreamReader isr = new InputStreamReader(System.in);
        BufferedReader br = new BufferedReader(isr);
//        Scanner scan = new Scanner(System.in);
//        int n = scan.nextInt();
        try{
            int n = Integer.parseInt(br.readLine());
            Deque<Integer> list = new ArrayDeque<Integer>();
            String[] num = new String[2];
            char c;
            for(int i=0; i<n; i++)
            {
                String command = br.readLine();
                c = command.charAt(0);
                if(c == 'i')
                {
                    num = command.split("" "",0);
                    list.offerFirst(Integer.parseInt(num[1]));
                }
                else if(c == 'd')
                {
                    c = command.charAt(6);
                    if(c == 'F')
                    {
                        list.pollFirst();
                    }
                    else if(c == 'L')
                    {
                        list.pollLast();
                    }
                    else
                    {
                        num = command.split("" "",0);
                        list.remove((Integer)(Integer.parseInt(num[1])));
                    }
                }
            }
            int size = list.size();
            for(int i=0; i<size-1; i++)
            {
                System.out.printf(""%d "",list.poll());
            }
            System.out.println(list.poll());
        }
        catch(Exception e)
        {

        }
    }
}"
63,"import java.util.Scanner;

class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        int n = sc.nextInt();
        int m = sc.nextInt();

        // 友達グループ
        int groups[] = new int[n];
        // 各友達グループの人数
        int counts[] = new int[n];
        for (int i = 0; i < n; ++i) {
            // 人i は グループiに属する
            groups[i] = i;
            counts[i] = 0;
        }

        for (int i = 0; i < m; ++i) {
            int a = sc.nextInt() - 1;
            int b = sc.nextInt() - 1;

            int group_a = groups[a];
            int group_b = groups[b];

            if (group_a != group_b) {
                for (int j = 0; j < n; ++j) {
                    if (groups[j] == group_b) {
                        groups[j] = group_a;
                    }
                }
            }
        }
        
        // 各グループの人数を数えて最大値を求める
        int max = 0;
        for (int i = 0; i < n; ++i) {
            int g = groups[i];
            counts[g] += 1;
        }
        for (int i = 0; i < n; ++i) {
            max = Math.max(max, counts[i]);
        }

        System.out.println(max);
    }
}"
64,"import java.util.*;

public class Main{
  public static void main(String[] args){
    Scanner sc=new Scanner(System.in);
    String[] s=sc.next().split("" "");
    for(int i=0;i<3,i++){
      s[i]=s[i].substring(0,1).toUpperCase();
    }
    System.out.println(s[0]+s[1]+s[2]);
  }
}"
65,"import java.util.*;

public class B{
    public static void main(String[]args){
	Scanner sc = new Scanner(System.in);
	int N = sc.nextInt();
	int count[] = new int[4];
	String s[] = new Sting[N];
	for(int i=0; i<N; i++){
	    s[i]= sc.nextLine();
	    switch(s[i]){
	    case ""AC"":
		count[0]++;
	    case ""WA"":
		count[1]++;
	    case ""TLE"":
		count[2]++;
	    case ""RE"":
		count[3]++;
	    }
	}
	System.out.println(""AC x ""+count[0]);
	System.out.println(""WA x ""+count[1]);
	System.out.println(""TLE x ""+count[2]);
	System.out.println(""RE x ""+count[3]);
    }
}"
66,"import java.util.*;
public class Main {
    public static void main (String[] args) {
      Scanner sc = new Scanner(System.in);
      int H = sc.nextInt(), W = nextInt();
      int ans = (H-1)*(W-1);
      
      System.out.println(ans);
    }
}"
67,"import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		double r = sc.nextInt();
		double area = r * r * Math.PI;
		double circumference = 2 * r * Math.PI;
		System.out.printf(""%f "", area);
		System.out.printf(""%f%n"", circumference);
		sc.close();
	}
}
"
68,"import java.awt.geom.Point2D;
import java.io.IOException;
import java.io.InputStream;
import java.util.*;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.IntStream;

public class Main {
  final static int INF = 1 << 28;
  final static long LNF = 1L << 60;
  final static long MOD = 1_000_000_007;
  final static double EPS = 1e-9;
  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;
  Scanner sc = new Scanner(System.in);

  public static void main(String[] args) {
    new Main().run();
  }

  class Node implements Comparable<Node> {
    int min = INF;
    int remain = 0;
    boolean[] done;

    @Override
    public int compareTo(Node node) {
      if (min != node.min) {
        return Integer.compare(min, node.min);
      }
      return -Integer.compare(remain, node.remain);
    }
  }

  Node solve(int n, int[] r) {
    Node node = new Node();
    int sum = IntStream.of(r).sum();
    int[] dp = new int[sum + 1];
    Arrays.fill(dp, INF);
    dp[0] = -1;
    for (int i = 0; i < n; ++i) {
      for (int j = sum; 0 <= j; --j) {
        if (j + r[i] > sum) {
          continue;
        }
        if (dp[j] == INF) {
          continue;
        }
        dp[j + r[i]] = i;
      }
    }
    for (int i = sum; 0 <= i; --i) {
      if (dp[i] == INF) {
        continue;
      }
      int me = 0;
      int vs = sum;
      int ok = i;
      boolean[] done = new boolean[n];
      while (dp[ok] != -1) {
        me += r[dp[ok]];
        vs -= r[dp[ok]];
        done[dp[ok]] = true;
        ok = ok - r[dp[ok]];
      }
      if (me < vs) {
        continue;
      }
      Node next = new Node();
      next.min = me;
      next.remain = me - vs;
      next.done = done;
      node = Util.min(node, next);
    }
    return node;
  }

  void run() {
    for (; ; ) {
      int n = ni();
      if (n == 0) {
        break;
      }
      int[] r = new int[n];
      int[] w = new int[n];
      int[][] t = new int[n][2];
      for (int i = 0; i < n; ++i) {
        r[i] = ni();
        w[i] = ni();
        t[i][0] = r[i];
        t[i][1] = w[i];
      }
      Arrays.sort(t, Comparator.comparingInt(a -> a[1] * 1000 + a[0]));
      for (int i = 0; i < n; ++i) {
        r[i] = t[i][0];
        w[i] = t[i][1];
      }
      Node node = solve(n, r);
      int sum = IntStream.of(w).sum();
      int[] dp = new int[node.remain + 1];
      Arrays.fill(dp, INF);
      dp[0] = -1;
      for (int i = 0; i < n; ++i) {
        if (node.done[i]) {
          continue;
        }
        for (int j = node.remain; 0 <= j; --j) {
          if (j + w[i] > node.remain) {
            continue;
          }
          if (dp[j] == INF) {
            continue;
          }
          dp[j + w[i]] = i;
        }
      }
      for (int i = node.remain; 0 <= i; --i) {
        if (dp[i] != INF) {
          sum -= i;
          break;
        }
      }
      System.out.println(node.min * 2 + sum);
    }
  }

  int ni() {
    return Integer.parseInt(sc.next());
  }

  void debug(Object... os) {
    System.err.println(Arrays.deepToString(os));
  }

  /**
   * ??????????????????????????????
   *
   * @return a ??¨ b ????????§??¬?´???°
   */
  long gcd(long a, long b) {
    if (b == 0) {
      return a;
    }
    return gcd(b, a % b);
  }

  /**
   * ????????????????????????????????????
   *
   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????
   */
  Pair<Long, Long> gcd_ex(long m, long n) {
    long[][] mat = _gcd_ex(m, n);
    return new Pair<>(mat[0][0], mat[0][1]);
  }

  long[][] _gcd_ex(long m, long n) {
    if (n == 0) {
      return new long[][]{{1, 0}, {0, 1}};
    }
    long k = m / n;
    long[][] K = new long[][]{{0, 1}, {1, -k}};
    long[][] r = _gcd_ex(n, m % n);
    long[][] dst = new long[2][2];
    for (int y = 0; y < 2; ++y)
      for (int x = 0; x < 2; ++x)
        for (int i = 0; i < 2; ++i)
          dst[y][x] += r[y][i] * K[i][x];
    return dst;
  }

  /**
   * ??°?????????2???????????¨??????????????????????£?
   *
   * @return a^r (mod 1,000,000,007)
   */
  long pow(long a, long r) {
    long sum = 1;
    while (r > 0) {
      if ((r & 1) == 1) {
        sum *= a;
        sum %= MOD;
      }
      a *= a;
      a %= MOD;
      r >>= 1;
    }
    return sum;
  }

  /**
   * ???????????????
   * O(n)
   *
   * @return {}_nC_r
   */
  long C(int n, int r) {
    long sum = 1;
    for (int i = n; 0 < i; --i) {
      sum *= i;
      sum %= MOD;
    }
    long s = 1;
    for (int i = r; 0 < i; --i) {
      s *= i;
      s %= MOD;
    }
    sum *= pow(s, MOD - 2);
    sum %= MOD;

    long t = 1;
    for (int i = n - r; 0 < i; --i) {
      t *= i;
      t %= MOD;
    }
    sum *= pow(t, MOD - 2);
    sum %= MOD;

    return sum;
  }

  /**
   * ??????????????¢?´¢
   *
   * @param left  ??????
   * @param right ??????
   * @param f     ??¢?´¢????????¢??°
   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)
   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()
   * @return ?\?????????§?¨?x
   */
  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {
    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);
    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);
    double d1 = f.apply(c1);
    double d2 = f.apply(c2);
    while (right - left > 1e-9) {
      if (comp.compare(d1, d2) > 0) {
        right = c2;
        c2 = c1;
        d2 = d1;
        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);
        d1 = f.apply(c1);
      } else {
        left = c1;
        c1 = c2;
        d1 = d2;
        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);
        d2 = f.apply(c2);
      }
    }
    return right;
  }

  /**
   * [a,b]???m:n???????????????????????????
   */
  double divideInternally(double a, double b, double m, double n) {
    return (n * a + m * b) / (m + n);
  }

  /**
   * http://alexbowe.com/popcount-permutations/
   * bit????????£???????????°????°?????????????????????????????????¨???????????????
   * ex)
   * <pre>
   * for (int i = 0; i < 25; ++i) {
   *   int bits = (1 << i) - 1;
   *   long m = C(25, num);
   *   for (j = 0; j < m; ++j) {
   *     ...(25???????????????i???bit????????£?????????)
   *     if (bits != 0)
   *       bits = next_perm(bits);
   *   }
   * }
   * </pre>
   *
   * @param v ?????¨???bit???
   * @return ?¬????bit???
   */
  int next_perm(int v) {
    int t = (v | (v - 1)) + 1;
    return t | ((((t & -t) / (v & -v)) >> 1) - 1);
  }

  static class Util {
    static <T extends Comparable<T>> T max(T a, T b) {
      if (a.compareTo(b) > 0) {
        return a;
      } else {
        return b;
      }
    }

    static <T extends Comparable<T>> T min(T a, T b) {
      if (a.compareTo(b) < 0) {
        return a;
      } else {
        return b;
      }
    }
  }

  /**
   * from http://gihyo.jp/dev/serial/01/geometry part 6
   */
  static class Line {
    double a;
    double b;
    double c;

    /**
     * ?????¬??¢??????????????????????????´??????????????????
     *
     * @param a x????????°
     * @param b y????????°
     * @param c ?????°???
     */
    Line(double a, double b, double c) {
      this.a = a;
      this.b = b;
      this.c = c;
    }

    /**
     * 2???(x1, y1), (x2, y2)???????????´??????????????????
     *
     * @param x1 1?????????x??§?¨?
     * @param y1 1?????????y??§?¨?
     * @param x2 2?????????x??§?¨?
     * @param y2 2?????????y??§?¨?
     * @return ??´???
     */
    static Line fromPoints(double x1, double y1, double x2, double y2) {
      double dx = x2 - x1;
      double dy = y2 - y1;
      return new Line(dy, -dx, dx * y1 - dy * x1);
    }

    /**
     * ?????????????????´?????¨??????????????????
     *
     * @param l ??´???
     * @return ?????????2??´?????????????????´??????null
     */
    Point2D getIntersectionPoint(Line l) {
      double d = a * l.b - l.a * b;
      if (d == 0.0) {
        return null;
      }
      double x = (b * l.c - l.b * c) / d;
      double y = (l.a * c - a * l.c) / d;
      return new Point2D.Double(x, y);
    }

    @Override
    public String toString() {
      return ""a = "" + a + "", b = "" + b + "", c = "" + c;
    }
  }

  static class Line1D {
    int x1;
    int x2;

    // [x1, x2) : ????????????
    Line1D(int x1, int x2) {
      this.x1 = x1;
      this.x2 = x2;
    }

    boolean isCross(Line1D l) {
      return isCross(l.x1, l.x2);
    }

    boolean isCross(int y1, int y2) {
      boolean ret = x1 < y2 && y1 < x2;
      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));
      return ret;
    }
  }

  /**
   * from http://gihyo.jp/dev/serial/01/geometry part 6
   */
  static public class LineSegment {
    double x1;
    double y1;
    double x2;
    double y2;

    LineSegment(double x1, double y1, double x2, double y2) {
      this.x1 = x1;
      this.y1 = y1;
      this.x2 = x2;
      this.y2 = y2;
    }

    Line toLine() {
      return Line.fromPoints(x1, y1, x2, y2);
    }

    boolean intersects(Line l) {
      double t1 = l.a * x1 + l.b * y1 + l.c;
      double t2 = l.a * x2 + l.b * y2 + l.c;
      return t1 * t2 <= 0;
    }

    boolean intersects(LineSegment s) {
      return bothSides(s) && s.bothSides(this);
    }

    // s???????????????????????´????????????????????????????????????
    private boolean bothSides(LineSegment s) {
      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);
      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);
      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???
        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§
        // true?????????
        return internal(s.x1, s.y1) || internal(s.x2, s.y2);
      } else { // ????????\????????´???
        // CCW???????¬?????????°????????´??????true?????????
        return ccw1 * ccw2 <= 0;
      }
    }

    // (x, y)?????????????????????????????????????????????????????????
    private boolean internal(double x, double y) {
      // (x, y)????????????????????????????????????????????????????????\?????§????????°????????¨?????????
      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;
    }

    public Point2D getIntersectionPoint(Line l) {
      if (!intersects(l)) {
        return null; // ?????????????????´??????null?????????
      }
      return l.getIntersectionPoint(toLine());
    }

    public Point2D getIntersectionPoint(LineSegment s) {
      if (!intersects(s)) {
        return null; // ?????????????????´??????null?????????
      }
      return s.toLine().getIntersectionPoint(toLine());
    }

    /**
     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point
     */
    double distance(double x0, double y0) {
      // ???????????§??????
      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {
        return GeomUtils.abs(x0 - x1, y0 - y1);
      }
      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {
        return GeomUtils.abs(x0 - x2, y0 - y2);
      }
      // ??´?????¨???????????¢
      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);
    }

    double distance(LineSegment l) {
      if (this.intersects(l)) {
        return 0.0;
      }
      double min = Double.MAX_VALUE;
      min = Math.min(min, distance(l.x1, l.y1));
      min = Math.min(min, distance(l.x2, l.y2));
      min = Math.min(min, l.distance(x1, y1));
      min = Math.min(min, l.distance(x2, y2));
      return min;
    }

    @Override
    public String toString() {
      return ""("" + x1 + "", "" + y1 + "") - ("" + x2 + "", "" + y2 + "")"";
    }
  }

  /**
   * from http://gihyo.jp/dev/serial/01/geometry part 6
   */
  static class GeomUtils {
    // ??????
    static double cross(double x1, double y1, double x2, double y2) {
      return x1 * y2 - x2 * y1;
    }

    // ??????
    static double dot(double x1, double y1, double x2, double y2) {
      return x1 * x2 + y1 * y2;
    }

    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????
    // ????¨????????????´???????????????????????´???????????´?????????????????????
    static double ccw(double x1, double y1, double x2, double y2,
                      double x3, double y3) {
      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);
    }

    static double ccw(Point2D p1, Point2D p2, Point2D p3) {
      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());
    }

    // ?????????????????????
    static double abs(double x, double y) {
      return Math.sqrt(x * x + y * y);
    }

    // ????§???¢???????????????
    // http://www.nttpc.co.jp/technology/number_algorithm.html
    boolean isIn(ArrayList<LineSegment> list, double x, double y) {
      int wn = 0;
      for (LineSegment l : list) {
        if (l.y1 <= y && l.y2 > y) {
          double vt = (y - l.y1) / (l.y2 - l.y1);
          if (x < l.x1 + (vt * (l.x2 - l.x1))) {
            ++wn;
          }
        }
        if (l.y1 > y && l.y2 <= y) {
          double vt = (y - l.y1) / (l.y2 - l.y1);
          if (x < (l.x1 + (vt * (l.x2 - l.x1)))) {
            --wn;
          }
        }
      }
      return wn > 0;
    }
  }

  /**
   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b
   */
  static class FastScanner {
    private final InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    public FastScanner(InputStream in) {
      this.in = in;
    }

    private static boolean isPrintableChar(int c) {
      return 33 <= c && c <= 126;
    }

    private boolean hasNextByte() {
      if (ptr < buflen) {
        return true;
      } else {
        ptr = 0;
        try {
          buflen = in.read(buffer);
        } catch (IOException e) {
          e.printStackTrace();
        }
        if (buflen <= 0) {
          return false;
        }
      }
      return true;
    }

    private int readByte() {
      if (hasNextByte()) return buffer[ptr++];
      else return -1;
    }

    private void skipUnprintable() {
      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
    }

    public boolean hasNext() {
      skipUnprintable();
      return hasNextByte();
    }

    public String next() {
      if (!hasNext()) throw new NoSuchElementException();
      StringBuilder sb = new StringBuilder();
      int b = readByte();
      while (isPrintableChar(b)) {
        sb.appendCodePoint(b);
        b = readByte();
      }
      return sb.toString();
    }

    public long nextLong() {
      if (!hasNext()) throw new NoSuchElementException();
      long n = 0;
      boolean minus = false;
      int b = readByte();
      if (b == '-') {
        minus = true;
        b = readByte();
      }
      if (b < '0' || '9' < b) {
        throw new NumberFormatException();
      }
      while (true) {
        if ('0' <= b && b <= '9') {
          n *= 10;
          n += b - '0';
        } else if (b == -1 || !isPrintableChar(b)) {
          return minus ? -n : n;
        } else {
          throw new NumberFormatException();
        }
        b = readByte();
      }
    }
  }

  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {
    F f;
    S s;

    Pair() {
    }

    Pair(F f, S s) {
      this.f = f;
      this.s = s;
    }

    Pair(Pair<F, S> p) {
      f = p.f;
      s = p.s;
    }

    @Override
    public int compareTo(Pair<F, S> p) {
      if (f.compareTo(p.f) != 0) {
        return f.compareTo(p.f);
      }
      return s.compareTo(p.s);
    }

    @Override
    public int hashCode() {
      return f.hashCode() ^ s.hashCode();
    }

    @Override
    public boolean equals(Object o) {
      if (this == o) {
        return true;
      }
      if (o == null || this.f == null || this.s == null) {
        return false;
      }
      if (this.getClass() != o.getClass()) {
        return false;
      }
      Pair p = (Pair) o;
      return this.f.equals(p.f) && this.s.equals(p.s);
    }

    @Override
    public String toString() {
      return ""{"" + f.toString() + "", "" + s.toString() + ""}"";
    }
  }

  class BIT<T> {
    int n;
    ArrayList<T> bit;
    BiFunction<T, T, T> bif;

    /**
     * 1-indexed ???Binary Indexed Tree????§??????????
     *
     * @param n   ??????
     * @param bif ?????¨???????????¢??°
     * @param sup ?????????
     */
    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {
      this.n = n;
      bit = new ArrayList<>(n + 1);
      for (int i = 0; i < n + 1; ++i) {
        bit.add(sup.get());
      }
      this.bif = bif;
    }

    /**
     * i??????????????????v??§??´??°??????
     *
     * @param i index
     * @param v ??°?????????
     */
    void set(int i, T v) {
      for (int x = i; x <= n; x += x & -x) {
        bit.set(x, bif.apply(bit.get(x), v));
      }
    }

    /**
     * ?????¨??????
     *
     * @param defaultValue ?????????
     * @param i            index
     * @return [1, i]?????§f????????¨????????????
     */
    T reduce(T defaultValue, int i) {
      T ret = defaultValue;
      for (int x = i; x > 0; x -= x & -x) {
        ret = bif.apply(ret, bit.get(x));
      }
      return ret;
    }
  }

  class SegmentTree<T> {
    int n;
    ArrayList<T> dat;
    BiFunction<T, T, T> bif;
    Supplier<T> sup;

    /**
     * 0-indexed ???Segment Tree????§??????????
     *
     * @param n_  ????±???????
     * @param bif ?????¨???????????¢??°
     * @param sup ?????????
     */
    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {
      n = 1;
      while (n < n_) n *= 2;

      dat = new ArrayList<>(2 * n - 1);
      for (int i = 0; i < 2 * n - 1; ++i) {
        dat.add(sup.get());
      }
      this.bif = bif;
      this.sup = sup;
    }

    /**
     * k??????????????????v??§??´??°??????
     *
     * @param k index
     * @param v ??°?????????
     */
    void set(int k, T v) {
      k += n - 1;
      dat.set(k, v);
      while (k > 0) {
        k = (k - 1) / 2;
        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));
      }
    }

    /**
     * ?????¨??????
     *
     * @param l ?????????
     * @param r ?????????
     * @return [l, r)??§?????????bif????????¨?????????????????????
     */
    T reduce(int l, int r) {
      return _reduce(l, r, 0, 0, n);
    }

    T _reduce(int a, int b, int k, int l, int r) {
      if (r <= a || b <= l) return sup.get();
      if (a <= l && r <= b) return dat.get(k);
      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);
      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);
      return bif.apply(vl, vr);
    }
  }

  class UnionFind {
    int[] par;

    UnionFind(int n) {
      par = new int[n];
      for (int i = 0; i < n; ++i) {
        par[i] = i;
      }
    }

    int find(int x) {
      if (par[x] == x) {
        return x;
      }
      return par[x] = find(x);
    }

    boolean same(int x, int y) {
      return find(x) == find(y);
    }

    void union(int x, int y) {
      x = find(x);
      y = find(y);
      if (x == y) {
        return;
      }
      par[x] = y;
    }
  }
}"
69,"
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.stream.LongStream;

public class Main {

	public static void main(String[] args) throws IOException {
		new Main().solve();
	}

	private void solve() throws IOException {
		try {
			//			solveA();
			//			solveB();
			//			solveC();
			solveD();
			//			 solveE();
			//			 solveF();
		} finally {
			if (in != null) {
				in.close();
			}
			if (out != null) {
				out.flush();
				out.close();
			}
		}

	}

	private void solveA() {
		int numA = nextInt();
		int numB = nextInt();
		int numC = nextInt();
		int numD = nextInt();
		int numE = nextInt();
		int numK = nextInt();

		int[] wk = new int[] { numA, numB, numC, numD, numE };
		Arrays.sort(wk);
		if (wk[4] - wk[0] > numK) {
			out.println("":("");
			return;
		}

		out.println(""Yay!"");
	}

	private static class SortComparator implements Comparator<Integer> {

		@Override
		public int compare(Integer o1, Integer o2) {
			int sabun1 = (o1 % 10);
			int sabun2 = (o2 % 10);

			if (sabun1 == 0) {
				return -1;
			}
			if (sabun2 == 0) {
				return 1;
			}
			sabun1 = 10 - sabun1;
			sabun2 = 10 - sabun2;
			if (sabun1 < sabun2) {
				return -1;
			} else if (sabun1 < sabun2) {
				return 1;
			} else {
				return 0;
			}
		}

	}

	private void solveB() {
		Integer[] wk = new Integer[5];
		for (int i = 0; i < wk.length; i++) {
			wk[i] = nextInt();
		}

		Arrays.sort(wk, new SortComparator());

		int res = 0;
		for (int i = 0; i < wk.length; i++) {

			if (res % 10 != 0) {
				int temp = 10 - res % 10;
				res += temp;
			}
			res += wk[i];
		}
		out.println(res);
	}

	private void solveC() {
		double numN = nextLong();

		long[] wk = new long[5];
		for (int i = 0; i < wk.length; i++) {
			wk[i] = nextLong();

		}

		Arrays.sort(wk);

		long res = (long) (Math.ceil(numN / (double) wk[0]) + (wk.length - 1));
		out.println(res);
	}

	private void solveD() {
		long numX = nextLong();
		long numY = nextLong();
		long numZ = nextLong();
		long numK = nextLong();

		long[] aX = LongStream.range(0, numX).map(i -> nextLong()).toArray();
		long[] aY = LongStream.range(0, numX).map(i -> nextLong()).toArray();
		long[] aZ = LongStream.range(0, numX).map(i -> nextLong()).toArray();

		Arrays.sort(aX);
		Collections.reverse(Arrays.asList(aX));
		Arrays.sort(aY);
		Collections.reverse(Arrays.asList(aY));
		Arrays.sort(aZ);
		Collections.reverse(Arrays.asList(aZ));

		List<Long> wkXY = new ArrayList<Long>();
		for (int i = 0; i < aX.length; i++) {
			for (int j = 0; j < aY.length; j++) {
				wkXY.add(aX[i] + aY[j]);
			}
		}

		Collections.sort(wkXY, (x, y) -> Long.compare(x, y) * -1);

		List<Long> wkXYZ = new ArrayList<Long>();
		for (int i = 0; i < Math.min(numK, wkXY.size()); i++) {
			for (int j = 0; j < aZ.length; j++) {
				wkXYZ.add(wkXY.get(i) + aZ[j]);
			}
		}

		Collections.sort(wkXYZ, (x, y) -> Long.compare(x, y) * -1);

		for (int i = 0; i < numK; i++) {
			out.println(wkXYZ.get(i));
		}

	}

	private void solveE() {
		int numN = nextInt();

		out.println("""");
	}

	private void solveF() {
		int numN = nextInt();

		out.println("""");
	}

	private final PrintWriter out = new PrintWriter(System.out);
	private final InputStream in = System.in;
	private final byte[] buffer = new byte[1024];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) {
			return true;
		} else {
			ptr = 0;
			try {
				buflen = in.read(buffer);
			} catch (IOException e) {
				e.printStackTrace();
			}
			if (buflen <= 0) {
				return false;
			}
		}
		return true;
	}

	private int readByte() {
		if (hasNextByte())
			return buffer[ptr++];
		else
			return -1;
	}

	private static boolean isPrintableChar(int c) {
		return 33 <= c && c <= 126;
	}

	private void skipUnprintable() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++;
	}

	public boolean hasNext() {
		skipUnprintable();
		return hasNextByte();
	}

	public int nextInt() {
		return Integer.parseInt(next());
	}

	public String next() {
		if (!hasNext())
			throw new NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		int b = readByte();
		while (isPrintableChar(b)) {
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}

	public long nextLong() {
		if (!hasNext())
			throw new NoSuchElementException();
		long n = 0;
		boolean minus = false;
		int b = readByte();
		if (b == '-') {
			minus = true;
			b = readByte();
		}
		if (b < '0' || '9' < b) {
			throw new NumberFormatException();
		}
		while (true) {
			if ('0' <= b && b <= '9') {
				n *= 10;
				n += b - '0';
			} else if (b == -1 || !isPrintableChar(b)) {
				return minus ? -n : n;
			} else {
				throw new NumberFormatException();
			}
			b = readByte();
		}
	}
}"
70,"import java.util.Scanner;
import java.util.Arrays;

public class Main{
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        String S = scan.next();
        StringBuffer S1 = new StringBuffer(S);
        String S2 = S1.reverse().toString();
        int flag = 0;
        String error = ""NO"";
        int a = 0;

        String[] T = {""dream"" ,""dreamer"" ,""erase"" ,""eraser""};

        for(int i = 0 ; i < T.length ; i++){
            StringBuffer T1 = new StringBuffer(T[i]);
            String T2 = T1.reverse().toString();
            T[i] = T2;
        }

//        System.out.println(Arrays.toString(T));

        do{
            
            a = a + 1;
//            System.out.println(a);
            for(int i = 0 ; i < T.length ; i++){
                
                if(S2.length() >= T[i].length() && S2.substring(0,T[i].length()).equals(T[i])){
//                    System.out.println(S2.length());
//                    System.out.println(T[i].length());

                    if(S2.length() == T[i].length()){
//                        System.out.println(S2.length());
//                        System.out.println(T[i].length());
                        flag = 1;
                        error = ""YES"";
                        break;
                    }

                    else{
                        S2 = S2.substring((T[i].length()));
//                        System.out.println(S2);
                        flag = 0;
                        break;
                    }
                }

                else{
                    flag = 1;
                    error = ""NO"";
//                    System.out.println(""MISS"");
                }
            }

        }while(flag == 0);


        System.out.println(error);
    }
}"
71,"import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int sx = Integer.parseInt(sc.next());
		int sy = Integer.parseInt(sc.next());
		int tx = Integer.parseInt(sc.next());
		int ty = Integer.parseInt(sc.next());

		int sumx = tx-sx;
		int sumy = ty-sy;

		String res="""";

		for(int i=0;i<sumy;i++) {
			res += ""U"";
		}
		for(int i=0;i<sumx;i++) {
			res += ""R"";
		}
		for(int i=0;i<sumy;i++) {
			res += ""D"";
		}
		for(int i=0;i<sumx+1;i++) {
			res += ""L"";
		}
		for(int i=0;i<sumy+1;i++) {
			res += ""U"";
		}
		for(int i=0;i<sumx+1;i++) {
			res += ""R"";
		}
		res += ""DR"";
		for(int i=0;i<sumy+1;i++) {
			res += ""D"";
		}
		for(int i=0;i<sumx+1;i++) {
			res += ""L"";
		}
		res += ""U"";

		System.out.println(res);

	}

}
"
72,"import java.util.Scanner;

public class Main {
	private Scanner sc;

	int[][] map;
	public static void main(String[] args) {
		new Main();
	}
	
	public Main() {
		sc = new Scanner(System.in);
		
		int[][][] map = new int[10][(int)Math.pow(2, 10)][400];
		
		for (int i = 0; i < map.length; i++) {
			for (int j = 0; j < map[0].length; j++) {
				for (int k = 0; k < map[0][0].length; k++) {
					map[i][j][k] = 0;
				}
			}
		}
		map[0][0][0] = 1;
		
		for (int j = 1; j < map.length; j++) {
			for (int i = 0; i < map[0][0].length; i++) {
				for (int k = 0; k < 10; k++) {
					for (int bit = 0; bit < map[0].length; bit++) {	
						if ((i - j * k) >= 0) {
							if ((bit >> k) % 2 == 1) {
								map[j][bit][i] = map[j][bit][i] + map[j - 1][bit - (int)Math.pow(2, k)][i - j * k];
							}
						} else {
							break;
						}
					}
				}
			}
		}
		
		int[][] ans = new int[map.length][map[0][0].length];
		for (int i = 0; i < map.length; i++) {
			for (int k = 0; k < map[0][0].length; k++) {
				int sum = 0;
				
				for (int j = 0; j < map[0].length; j++) {
					sum = sum + map[i][j][k];
				}
				
				ans[i][k] = sum;
			}
		}
		
		while (sc.hasNextLine() == true) {
			String[] nico = sc.nextLine().split("" "");
			int n = Integer.parseInt(nico[0]);
			int s = Integer.parseInt(nico[1]);
			
			System.out.println(ans[n][s]);
		}
	}
}"
73,"import java.io.*;
import java.util.*;

public class A {
	public static void main(String[] args) throws Exception {
		BufferedReader f = new BufferedReader(new InputStreamReader(System.in));
		PrintWriter out = new PrintWriter(System.out);
		Scanner s = new Scanner(System.in);
		
		String[] split = f.readLine().split(""\\s+"");
		String res = """";
		for(int i= 0; i < split.length; i++) {
			res += Character.toUpperCase(split[i].charAt(0));
		}
		System.out.println(res);
	}
}"
74,"import java.util.*;
import java.io.*;

class Main {
	static PrintStream out = System.out;
	static Scanner in = new Scanner(System.in);

	public static void main(String[] args) {
		Main main = new Main();
		main.solv();
	}
	private void solv() {
		int n = in.nextInt();
		int[] a = new int[n];
		long l = System.currentTimeMillis();
		for (int i = 0; i < n; i++) {
			a[i] = in.nextInt();
		}
		long ll = System.currentTimeMillis();
		int cnt = bubbleSort(a);
		long lll = System.currentTimeMillis();

		//out.println((ll-l)+""/""+(lll-ll));
		out.println(cnt);
	}

	private int bubbleSort(int[] a) {
		int cnt = 0;
		for (int i = 0; i < a.length; i++) {
			for (int j = a.length - 1; j > i; j--) {
				if (a[i] > a[j]) {
					cnt++;
				}
			}
		}
		return cnt;
	}

	private static class Scanner {
	    private BufferedReader in;

	    public Scanner(InputStream in) {
	        this.in = new BufferedReader(new InputStreamReader(in));
	    }

	    public String next() {
	        CharArrayWriter writer = new CharArrayWriter();
	        while (true) {
	            try {
	                int cp = in.read();
	                if (Character.isWhitespace(cp)) {
	                    return writer.toString();
	                }
	                writer.write(cp);
	            } catch (IOException e) {
	                throw new RuntimeException(e);
	            }
	        }
	    }

	    public int nextInt() {
	        String s = next();
	        return Integer.parseInt(s);
	    }
	}
}"
75,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;

public class Main {

	static BufferedReader reader;
	final static boolean MODE_DEBUG = false;
	//static field here
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		reader = new BufferedReader(new InputStreamReader(System.in));
		//code here
		int N = readLineInt()[0];
		ArrayList<TreeNode<Integer,Integer>> tn = new ArrayList<TreeNode<Integer,Integer>>();
		for(int n=0;n<N;n++) {
			TreeNode<Integer,Integer> tnp = new TreeNode<>();
			tnp.item = -1;
			tn.add(tnp);
		}
		for(int i=1;i<N;i++) {
			int[] uvw = readLineInt();
			int u = uvw[0]-1;
			int v = uvw[1]-1;
			int w = uvw[2];
			if(u>v) {
				int tmp = u;
				u = v;
				v = tmp;
			}
			tn.get(v).addNeighbor(tn.get(u),w);
		}
		int CNT = N-1;
		tn.get(0).item = 0;
		while(CNT>0) {
			for(TreeNode<Integer,Integer> tnc : tn) {
				if(tnc.item>=0) {continue;}
				for(TreeVertex<Integer,Integer> v : tnc.vertexes) {
					TreeNode<Integer,Integer> another = v.another(tnc);
					if(another.item>=0) {
						tnc.item = (another.item+v.item)%2;
						CNT--;
					}
				}
			}
		}
		for(int i=0;i<N;i++) {
			print(tn.get(i).item);
		}
	}
	
	//functions here
	//note that all methods should be STATIC
	static int getAnother(int v) {
		if(v==0) {return 0;}
		return 3-v;
	}

	private static <T> int arraySearch(T needle, T[] heystack) {
		for(int i=0;i<heystack.length;i++) {
			if(needle.equals(heystack[i])) {
				return i;
			}
		}
		return -1;
	}
	private static int[] sort(int[] base) {
		int[] copy = array_copy(base);
		Arrays.sort(copy);
		return copy;
	}
	private static int[] array_copy(int[] base) {
		int[] copy = new int[base.length];
		for(int i=0;i<base.length;i++) {
			copy[i] = base[i];
		}
		return copy;
	}
	private static int[] asArray(ArrayList<Integer> ints) {
		int[] intlist = new int[ints.size()];
		for(int i=0;i<intlist.length;i++) {
			intlist[i] = ints.get(i);
		}
		return intlist;
	}
	private static String[] readLine(){
		try{
			return reader.readLine().split("" "");
		}catch(Exception e){
			e.printStackTrace();
			return new String[]{e.getMessage()};
		}
	}
	private static int[] readLineInt(){
		try{
			String[] s = readLine();
			int[] ints = new int[s.length];
			for(int i=0;i<ints.length;i++) {
				ints[i] = Integer.parseInt(s[i]);
			}
			return ints;
		}catch(Exception e){
			e.printStackTrace();
			return null;
		}
	}
	private static byte[] readLineByte(){
		try{
			String[] s = readLine();
			byte[] bytes = new byte[s.length];
			for(int i=0;i<bytes.length;i++) {
				bytes[i] = Byte.parseByte(s[i]);
			}
			return bytes;
		}catch(Exception e){
			e.printStackTrace();
			return null;
		}
	}
	private static char[] readLineChar(){
		try{
			String[] s = readLine();
			char[] chars = new char[s.length];
			for(int i=0;i<chars.length;i++) {
				chars[i] = (char)Integer.parseInt(s[i]);
			}
			return chars;
		}catch(Exception e){
			e.printStackTrace();
			return null;
		}
	}
	private static void print(Object o){
		System.out.println(o);
	}
	private static void print(){
		System.out.println();
	}
	private static void printd(Object o){
		if(MODE_DEBUG)System.err.println(o);
	}
	private static void printd(){
		if(MODE_DEBUG)System.err.println();
	}
}

class TreeNode<V,E>{
	HashSet<TreeNode<V,E>> neighbor = new HashSet<>();
	HashSet<TreeVertex<V,E>> vertexes = new HashSet<>();
	V item;
	public void addNeighbor(TreeNode<V,E> neighbor, E item) {
		this.neighbor.add(neighbor);
		neighbor.neighbor.add(this);
		addVertex(neighbor,item);
		return;
	}
	public void addVertex(TreeNode<V,E> to, E item) {
		TreeVertex<V,E> v = new TreeVertex<>();
		v.item = item;
		v.node1 = this;
		v.node2 = to;
		this.vertexes.add(v);
		to.vertexes.add(v);
	}
	public TreeVertex<V,E> getVertexTo(TreeNode<V,E> node){
		for(TreeVertex<V,E> v : vertexes) {
			if(v.node1==this&&v.node2==node || v.node1==node&&v.node2==this) {
				return v;
			}
		}
		return null;
	}
	@Override
	public String toString(){ // TODO 自動生成されたメソッド・スタブ
	return item.toString(); }
}

class TreeVertex<V,E>{
	TreeNode<V,E> node1;
	TreeNode<V,E> node2;
	E item;
	public TreeNode<V,E> another(TreeNode<V,E> from){
		if(node1==from) {return node2;}
		else if(node2==from) {return node1;}
		else {return null;}
	}
	@Override
	public String toString(){ // TODO 自動生成されたメソッド・スタブ
	return node1.toString()+""<- [""+item.toString()+""] ->""+node2.toString(); }
}"
76,"import java.util.Arrays;
import java.util.Scanner;

class Main {
	int N, M;
	int[] X, Y;
	int[] pow2 = new int[30];

	public static void main(String[] args) {
		new Main().run();
	}

	void run() {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int m = sc.nextInt();
		int q = sc.nextInt();
		char[][] s = new char[n][m];
		for (int i = 0; i < n; ++i) {
			s[i] = sc.next().toCharArray();
		}
		int[][] a = new int[n][m];
		int[][] edgeV = new int[n][m];
		int[][] edgeH = new int[n][m];
		for (int i = 0; i < n; ++i) {
			for (int j = 0; j < m; ++j) {
				a[i][j] = (int) (s[i][j] - '0');
				if (i > 0 && a[i][j] == 1 && a[i - 1][j] == 1) {
					edgeV[i][j] = 1;
				}
				if (j > 0 && a[i][j] == 1 && a[i][j - 1] == 1) {
					edgeH[i][j] = 1;
				}
			}
		}
		// １：青
		// ０：白

		RectangleSum s1 = new RectangleSum(a, n, m);
		RectangleSum s2 = new RectangleSum(edgeH, n, m);
		RectangleSum s3 = new RectangleSum(edgeV, n, m);
		for (int i = 0; i < q; ++i) {
			int y1 = sc.nextInt() - 1;
			int x1 = sc.nextInt() - 1;
			int y2 = sc.nextInt();
			int x2 = sc.nextInt();
			int ans = 0;
			ans += s1.get(y1, y2, x1, x2);
			ans -= s2.get(y1, y2, x1 + 1, x2);
			ans -= s3.get(y1 + 1, y2, x1, x2);
			System.out.println(ans);
		}

	}

	class RectangleSum {
		int[][] a;
		int[][] sum;

		public RectangleSum(int[][] a, int h, int w) {
			this.a = a;
			sum = new int[h + 1][w + 1];
			for (int i = 1; i <= h; ++i) {
				for (int j = 1; j <= w; ++j) {
					sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + a[i - 1][j - 1];
				}
			}
		}

		// [l,r)
		// [t,b)
		int get(int t, int b, int l, int r) {
			return sum[b][r] - sum[b][l] - sum[t][r] + sum[t][l];
		}

	}

	static void tr(Object... objects) {
		System.out.println(Arrays.deepToString(objects));
	}

}"
77,"import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;
class Main
{
    public static void main(String[] args) {
        try {
            int cnt = 0;
            HashMap<Integer, Integer> hm = new HashMap<>();
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            int ar[] = new int[n];
            for (int i = 0; i < n; i++) {
                ar[i] = sc.nextInt();
            }
            for (int i = 0; i < n; i++) {
                hm.put(ar[i], 0);
            }
            for (int i = 0; i < n; i++) {
                hm.put(ar[i], hm.get(ar[i]) + 1);
            }
            for (Map.Entry<Integer, Integer> m : hm.entrySet()) {
                int v = m.getValue();
                int k = m.getKey();
                if (v < k)
                    cnt = cnt + v;
                else
                    cnt = cnt + v - k;
            }
            System.out.println(cnt);
        }
        catch (Exception e)
        {
            return;
        }
    }
}"
78,"import java.util.*;

public class Main{
  public static void main(String[] args){
    Scanner sc = new Scanner(System.in);
    String[] s = sc.next().split();
    int a = sc.nextInt();

    s[a-1] = s[a-1].ToLowerCase();
    
    System.out.println(s);
  }

}"
79,"import java.util.Scanner;
public class Main {
     
    static char[] k = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};
     
 
    public static void main(String[] args) {
        Scanner stdIn = new Scanner(System.in);
        String s = """";
        while(stdIn.hasNext()) {
        s += stdIn.nextLine();
        }
        s = s.toLowerCase();
        int[] ans = new int[k.length];
        for(int i = 0; i < s.length(); i++) {
            for(int j = 0; j < k.length; j++) {
                if(s.charAt(i) == k[j]) {
                    ans[j]++;
                }
            }
        }
         
        for(int i = 0; i < 26; i++) {
            System.out.println(k[i]+"" : "" + ans[i]);
        }
    }
}"
80,"import java.util.*;

public class Main{
	public static void main(String[] arg){
    
     Scanner sc = new Scanner(System.in);
     String s = sc.next();
     s = s.replaceAll(""0"","""");
     System.out.println(s.length())
    }

}"
81,"
import java.util.Arrays;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        // write your code here
        Scanner scanner=new Scanner(System.in);
        int N=scanner.nextInt();
        long[] ints=new long[N];
        for(int i=0;i<N;i++){
            ints[i]= scanner.nextLong();
        }
        long[] longs=new long[N+1];
        longs[0]=0;
        for(int i=1;i<N+1;i++){
            longs[i]=longs[i-1]+ints[i-1];
        }
        Arrays.sort(longs);
        long result=0;
        long count=0;
        for(int i=1;i<N+1;i++){
            if(longs[i-1]==longs[i]){
                count++;
            }else{
                if(count>0){
                    result+=count*(count+1)/2;
                    count=0;
                }
            }
        }
        if(count>0){
            result+=count*(count+1)/2;
        }
        System.out.println(result);
    }"
82,"import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		final Scanner sc = new Scanner(System.in);
		String s = sc.next();
		boolean ok = true;
		boolean AfterDream = false;
		while(!s.equals("""")) {
			if(s.startsWith(""dream"")) {
				//System.out.println(""dream"");
				s = s.substring(5);
				//System.out.println(""next:""+s);
				AfterDream = true;
				continue;
			} else 	if(s.startsWith(""eraser"")) {
				//System.out.println(""eraser"");
				s = s.substring(6);
				//System.out.println(""next:""+s);
			} else if(s.startsWith(""erase"")) {
				//System.out.println(""erase"");
				s = s.substring(5);
				//System.out.println(""next:""+s);
			} else if(AfterDream==true&&s.startsWith(""er"")) {
				//System.out.println(""er"");
				s = s.substring(2);
				//System.out.println(""next:""+s);
				AfterDream = false;
			} else {
				//System.out.println(s);
				ok = false;
				break;
			}
			AfterDream = false;
		}
		System.out.println(ok ? ""YES"" : ""NO"");
	}
}"
83,"import java.util.*;
import java.io.*;
public class Main {
	static boolean DEBUG;
	public static void main(String[] args) {
		DEBUG = args.length > 0 && args[0].equals(""-DEBUG"");
		Solver solver = new Solver();
		solver.solve();
		solver.exit();
	}

	static class FastScanner {
		private final InputStream in = System.in;
		private final byte[] buffer = new byte[1024];
		private int ptr = 0;
		private int buflen = 0;
		private boolean hasNextByte() {
			if (ptr < buflen) {
				return true;
			}else{
				ptr = 0;
				try {
					buflen = in.read(buffer);
				} catch (IOException e) {
					e.printStackTrace();
				}
				if (buflen <= 0) {
					return false;
				}
			}
			return true;
		}
		private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}
		private boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}
		private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}
		public boolean hasNext() { skipUnprintable(); return hasNextByte();}
		public String next() {
			if (!hasNext()) throw new NoSuchElementException();
			StringBuilder sb = new StringBuilder();
			int b = readByte();
			while(isPrintableChar(b)) {
				sb.appendCodePoint(b);
				b = readByte();
			}
			return sb.toString();
		}
		public long nextLong() {
			if (!hasNext()) throw new NoSuchElementException();
			long n = 0;
			boolean minus = false;
			int b = readByte();
			if (b == '-') {
				minus = true;
				b = readByte();
			}
			if (b < '0' || '9' < b) {
				throw new NumberFormatException();
			}
			while(true){
				if ('0' <= b && b <= '9') {
					n *= 10;
					n += b - '0';
				}else if(b == -1 || !isPrintableChar(b)){
					return minus ? -n : n;
				}else{
					throw new NumberFormatException();
				}
				b = readByte();
			}
		}
	}

	static class Solver {
		FastScanner sc = new FastScanner();
		public Solver() { }

		String ns() { return sc.next(); }
		String[] ns(int n) {
			String a[] = new String[n];
			for(int i = 0; i < n; i ++) { a[i] = ns(); }
			return a;
		}
		String[][] ns(int n, int m) {
			String a[][] = new String[n][m];
			for(int i = 0; i < n; i ++) { a[i] = ns(m); }
			return a;
		}
		char[] nc(int n) {
			String str = ns();
			char a[] = new char[max(n, str.length())];
			for(int i = 0; i < str.length(); i ++) { a[i] = str.charAt(i); }
			return a;
		}
		char[][] nc(int n, int m) {
			char a[][] = new char[n][m];
			for(int i = 0; i < n; i ++) { a[i] = nc(m); }
			return a;
		}
		boolean[] nb(int n, char t) {
			char c[] = nc(-1);
			if(n < 0) n = c.length;
			boolean a[] = new boolean[n];
			for(int i = 0; i < n; i ++) { a[i] = c[i] == t; }
			return a;
		}
		boolean[][] nb(int n, int m, char t) {
			boolean a[][] = new boolean[n][m];
			for(int i = 0; i < n; i ++) { a[i] = nb(m, t); }
			return a;
		}
		int ni() { return (int)sc.nextLong(); }
		int[] ni(int n) {
			int a[] = new int[n];
			for(int i = 0; i < n; i ++) { a[i] = ni(); }
			return a;
		}
		int[][] ni(int n, int m) {
			int a[][] = new int[n][m];
			for(int i = 0; i < n; i ++) { a[i] = ni(m); }
			return a;
		}
		long nl() { return sc.nextLong(); }
		long[] nl(int n) {
			long a[] = new long[n];
			for(int i = 0; i < n; i ++) { a[i] = nl(); }
			return a;
		}
		long[][] nl(int n, int m) {
			long a[][] = new long[n][m];
			for(int i = 0; i < n; i ++) { a[i] = nl(m); }
			return a;
		}
		double nd() { return Double.parseDouble(sc.next()); }
		double[] nd(int n) {
			double a[] = new double[n];
			for(int i = 0; i < n; i ++) { a[i] = nd(); }
			return a;
		}
		double[][] nd(int n, int m) {
			double a[][] = new double[n][m];
			for(int i = 0; i < n; i ++) { a[i] = nd(m); }
			return a;
		}

		PrintWriter out = new PrintWriter(System.out);
		PrintWriter err = new PrintWriter(System.err);
		void prt() { out.print(""""); }
		<T> void prt(T a) { out.print(a); }
		void prtln() { out.println(""""); }
		<T> void prtln(T a) { out.println(a); }
		void prtln(int... a) {
			StringBuilder sb = new StringBuilder();
			for(int element : a){ sb.append(element+"" ""); }
			prtln(sb.toString().trim());
		}
		void prtln(long... a) {
			StringBuilder sb = new StringBuilder();
			for(long element : a){ sb.append(element+"" ""); }
			prtln(sb.toString().trim());
		}
		void prtln(double... a) {
			StringBuilder sb = new StringBuilder();
			for(double element : a){ sb.append(element+"" ""); }
			prtln(sb.toString().trim());
		}
		void prtln(String... a) {
			StringBuilder sb = new StringBuilder();
			for(String element : a){ sb.append(element+"" ""); }
			prtln(sb.toString().trim());
		}
		void prtln(char... a) {
			StringBuilder sb = new StringBuilder();
			for(char element : a){ sb.append(element); }
			prtln(sb.toString().trim());
		}
		void prtln(int[][] a) { for(int[] element : a){ prtln(element); } }
		void prtln(long[][] a) { for(long[] element : a){ prtln(element); } }
		void prtln(double[][] a) { for(double[] element : a){ prtln(element); } }
		void prtln(String[][] a) { for(String[] element : a){ prtln(element); } }
		void prtln(char[][] a) { for(char[] element : a){ prtln(element); } }
		String errconvert(int a) { return isINF(a) ? ""_"" : String.valueOf(a); }
		String errconvert(long a) { return isINF(a) ? ""_"" : String.valueOf(a); }
		void errprt(int a) { if(DEBUG) { err.print(errconvert(a)); } }
		void errprt(long a) { if(DEBUG) { err.print(errconvert(a)); } }
		void errprt() { if(DEBUG) { err.print(""""); } }
		<T> void errprt(T a) { if(DEBUG) { err.print(a); } }
		void errprt(boolean a) { if(DEBUG) { errprt(a ? ""#"" : "".""); } }
		void errprtln() { if(DEBUG) { err.println(""""); } }
		void errprtln(int a) { if(DEBUG) { err.println(errconvert(a)); } }
		void errprtln(long a) { if(DEBUG) { err.println(errconvert(a)); } }
		<T> void errprtln(T a) { if(DEBUG) { err.println(a); } }
		void errprtln(boolean a) { if(DEBUG) { errprtln(a ? ""#"" : "".""); } }
		void errprtln(int... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(int element : a){ sb.append(errconvert(element)+"" ""); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(long... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(long element : a){ sb.append(errconvert(element)+"" ""); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(double... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(double element : a){ sb.append(element+"" ""); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(String... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(String element : a){ sb.append(element+"" ""); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(char... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(char element : a){ sb.append(element); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(boolean... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(boolean element : a){ sb.append((element ? ""#"" : ""."")+"" ""); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(int[][] a) { if(DEBUG) { for(int[] element : a){ errprtln(element); } } }
		void errprtln(long[][] a) { if(DEBUG) { for(long[] element : a){ errprtln(element); } } }
		void errprtln(double[][] a) { if(DEBUG) { for(double[] element : a){ errprtln(element); } } }
		void errprtln(String[][] a) { if(DEBUG) { for(String[] element : a){ errprtln(element); } } }
		void errprtln(char[][] a) { if(DEBUG) { for(char[] element : a){ errprtln(element); } } }
		void errprtln(boolean[][] a) { if(DEBUG) { for(boolean[] element : a){ errprtln(element); } } }

		void reply(boolean b) { prtln(b ? ""Yes"" : ""No""); }
		void REPLY(boolean b) { prtln(b ? ""YES"" : ""NO""); }

		void flush() { out.flush(); if(DEBUG) { err.flush(); } }
		void exit() { flush(); System.exit(0); }

		int min(int a, int b) { return Math.min(a, b); }
		long min(long a, long b) { return Math.min(a, b); }
		double min(double a, double b) { return Math.min(a, b); }
		int min(int... x) {
			int min = x[0];
			for(int val : x) { min = min(min, val); }
			return min;
		}
		long min(long... x) {
			long min = x[0];
			for(long val : x) { min = min(min, val); }
			return min;
		}
		double min(double... x) {
			double min = x[0];
			for(double val : x) { min = min(min, val); }
			return min;
		}
		int max(int a, int b) { return Math.max(a, b); }
		long max(long a, long b) { return Math.max(a, b); }
		double max(double a, double b) { return Math.max(a, b); }
		int max(int... x) {
			int max = x[0];
			for(int val : x) { max = max(max, val); }
			return max;
		}
		long max(long... x) {
			long max = x[0];
			for(long val : x) { max = max(max, val); }
			return max;
		}
		double max(double... x) {
			double max = x[0];
			for(double val : x) { max = max(max, val); }
			return max;
		}
		long sum(int... a) {
			long sum = 0;
			for(int element : a) { sum += element; }
			return sum;
		}
		long sum(long... a) {
			long sum = 0;
			for(long element : a) { sum += element; }
			return sum;
		}
		double sum(double... a) {
			double sum = 0;
			for(double element : a) { sum += element; }
			return sum;
		}
		long[] sums(int[] a) {
			long sum[] = new long[a.length + 1];
			sum[0] = 0;
			for(int i = 0; i < a.length; i ++) { sum[i + 1] = sum[i] + a[i]; }
			return sum;
		}
		long[] sums(long[] a) {
			long sum[] = new long[a.length + 1];
			sum[0] = 0;
			for(int i = 0; i < a.length; i ++) { sum[i + 1] = sum[i] + a[i]; }
			return sum;
		}
		double[] sums(double[] a) {
			double sum[] = new double[a.length + 1];
			sum[0] = 0;
			for(int i = 0; i < a.length; i ++) { sum[i + 1] = sum[i] + a[i]; }
			return sum;
		}

		long abs(double x) { return (long)Math.abs(x); }
		long round(double x) { return Math.round(x); }
		long floor(double x) { return (long)Math.floor(x); }
		long ceil(double x) { return (long)Math.ceil(x); }
		double sqrt(double x) { return Math.sqrt(x); }
		double pow(double x, double y) { return Math.pow(x, y); }
		long pow(long x, long y) { return (long)Math.pow(x, y); }
		int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }
		long gcd(long a, long b) { return b == 0 ? a : gcd(b, a % b); }
		long lcm(long a, long b) { return a * b / gcd(a, b); }

		int upperToInt(char a) { return a - 'A'; }
		int lowerToInt(char a) { return a - 'a'; }
		int numToInt(char a) { return a - '0'; }
		int charToInt(char a) { return a >= 'a' ? lowerToInt(a) : a >= 'A' ? upperToInt(a) : numToInt(a); }
		char intToUpper(int a) { return (char)(a + 'A'); }
		char intToLower(int a) { return (char)(a + 'a'); }
		char intToNum(int a) { return (char)(a + '0'); }

		long[] div(long a) {
			List<Long> divList = new ArrayList<Long>();
			for(long i = 1; i * i <= a; i ++) {
				if(a % i == 0) {
					divList.add(i);
					if(i * i != a) { divList.add(a / i); };
				}
			}

			long div[] = new long[divList.size()];
			for(int i = 0; i < divList.size(); i ++) { div[i] = divList.get(i); }
			return div;
		}

		long[][] factor(long a) {
			List<Long> factorList = new ArrayList<Long>();
			List<Long> degreeList = new ArrayList<Long>();
			for(long i = 2; i * i <= a; i ++) {
				if(a % i == 0) {
					long count = 0;
					while(a % i == 0) {
						a /= i;
						count ++;
					}
					factorList.add(i);
					degreeList.add(count);
				}
			}
			if(a > 1) {
				factorList.add(a);
				degreeList.add(1L);
			}
			long factor[][] = new long[factorList.size()][2];
			for(int i = 0; i < factorList.size(); i ++) {
				factor[i][0] = factorList.get(i);
				factor[i][1] = degreeList.get(i);
			}
			Arrays.sort(factor, (sort1, sort2) -> Long.compare(sort1[0], sort2[0]));
			return factor;
		}

		boolean isPrime(long x) {
			boolean ok = x > 1;
			for(long i = 2; i * i <= x; i ++) {
				ok &= x % i != 0;
				if(!ok) return ok;
			}
			return ok;
		}
		boolean[] prime(int num) {
			boolean prime[] = new boolean[num];
			fill(prime, true);
			prime[0] = false;
			prime[1] = false;
			for(int i = 2; i < num; i ++) {
				if(prime[i]) {
					for(int j = 2; i * j < num; j ++) {
						prime[i * j] = false;
					}
				}
			}
			return prime;
		}

		long[][] countElements(long[] a, boolean sort) {
			int len = a.length;
			long array[] = new long[len];
			for(int i = 0; i < len; i ++) {
				array[i] = a[i];
			}
			if(sort) { Arrays.sort(array); }
			List<Long> elem = new ArrayList<Long>();
			List<Long> cnt = new ArrayList<Long>();
			long tmp = 1;
			for(int i = 1; i <= len; i ++) {
				if(i == len || array[i] != array[i - 1]) {
					elem.add(array[i - 1]);
					cnt.add(tmp);
					tmp = 1;
				}else {
					tmp ++;
				}
			}
			long counts[][] = new long[elem.size()][2];
			for(int i = 0; i < elem.size(); i ++) {
				counts[i][0] = elem.get(i);
				counts[i][1] = cnt.get(i);
			}
			return counts;
		}
		long[][] countElements(String str, boolean sort) {
			int len = str.length();
			char array[] = str.toCharArray();
			if(sort) { Arrays.sort(array); }
			List<Long> elem = new ArrayList<Long>();
			List<Long> cnt = new ArrayList<Long>();
			long tmp = 1;
			for(int i = 1; i <= len; i ++) {
				if(i == len || array[i] != array[i - 1]) {
					elem.add((long)array[i - 1]);
					cnt.add(tmp);
					tmp = 1;
				}else {
					tmp ++;
				}
			}
			long counts[][] = new long[elem.size()][2];
			for(int i = 0; i < elem.size(); i ++) {
				counts[i][0] = elem.get(i);
				counts[i][1] = cnt.get(i);
			}
			return counts;
		}

		int numDigits(long a) { return Long.toString(a).length(); }
		long bitFlag(int a) { return 1L << (long)a; }
		boolean isFlagged(long x, int a) { return (x & bitFlag(a)) != 0; }

		long countString(String str, String a) { return (str.length() - str.replace(a, """").length()) / a.length(); }
		long countStringAll(String str, String a) { return str.length() - str.replaceAll(a, """").length(); }

		int lowerBound(long array[], long key) {
			return BS(array, key, true, true, true);
		}
		int lowerBound(long array[], long key, int ng, int ok) {
			return BS(array, key, true, true, true, ng, ok);
		}
		int upperBound(long array[], long key) {
			return BS(array, key, true, true, false);
		}
		int upperBound(long array[], long key, int ng, int ok) {
			return BS(array, key, true, true, false, ng, ok);
		}
		int cntBS(long array[], long key, boolean ascending, boolean greater, boolean equals) {
			return BS(array, key, ascending, greater, equals, true);
		}
		int cntBS(long array[], long key, boolean ascending, boolean greater, boolean equals, int ng, int ok) {
			return BS(array, key, ascending, greater, equals, true, ng, ok);
		}
		int BS(long array[], long key, boolean ascending, boolean greater, boolean equals) {
			return BS(array, key, ascending, greater, equals, false);
		}
		int BS(long array[], long key, boolean ascending, boolean greater, boolean equals, int ng, int ok) {
			return BS(array, key, ascending, greater, equals, false, ng, ok);
		}
		int BS(long array[], long key, boolean ascending, boolean greater, boolean equals, boolean count) {
			int ng = ascending ^ greater ? array.length : -1;
			int ok = ascending ^ greater ? -1 : array.length;
			return BS(array, key, ascending, greater, equals, count, ng, ok);
		}
		int BS(long array[], long key, boolean ascending, boolean greater, boolean equals, boolean count, int ng, int ok) {
			int index = binarySearch(array, key, greater, equals, ng, ok);
			return count ? (int)abs(ok - index) : index;
		}
		int binarySearch(long array[], long key, boolean greater, boolean equals, int ng, int ok) {
			while (abs(ok - ng) > 1) {
				int mid = (ok + ng) / 2;
				if(isOKforBinarySearch(array, mid, key, greater, equals)) {
					ok = mid;
				}else {
					ng = mid;
				}
			}
			return ok;
		}
		boolean isOKforBinarySearch(long array[], int index, long key, boolean greater, boolean equals) {
			return (array[index] > key && greater)
				|| (array[index] < key && !greater)
				|| (array[index] == key && equals);
		}

		void reverse(String array[]) {
			String reversed[] = new String[array.length];
			for(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }
			for(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }
		}
		void reverse(int array[]) {
			int reversed[] = new int[array.length];
			for(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }
			for(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }
		}
		void reverse(long array[]) {
			long reversed[] = new long[array.length];
			for(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }
			for(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }
		}
		void reverse(double array[]) {
			double reversed[] = new double[array.length];
			for(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }
			for(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }
		}
		void reverse(boolean array[]) {
			boolean reversed[] = new boolean[array.length];
			for(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }
			for(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }
		}
		void fill(int array[], int x) { Arrays.fill(array, x); }
		void fill(long array[], long x) { Arrays.fill(array, x); }
		void fill(double array[], double x) { Arrays.fill(array, x); }
		void fill(boolean array[], boolean x) { Arrays.fill(array, x); }
		void fill(int array[][], int x) { for(int a[] : array) { fill(a, x); } }
		void fill(long array[][], long x) { for(long a[] : array) { fill(a, x); } }
		void fill(double array[][], double x) { for(double a[] : array) { fill(a, x); } }
		void fill(boolean array[][], boolean x) { for(boolean a[] : array) { fill(a, x); } }
		void fill(int array[][][], int x) { for(int a[][] : array) { fill(a, x); } }
		void fill(long array[][][], long x) { for(long a[][] : array) { fill(a, x); } }
		void fill(double array[][][], double x) { for(double a[][] : array) { fill(a, x); } }
		void fill(boolean array[][][], boolean x) { for(boolean a[][] : array) { fill(a, x); } }

		void shuffleArray(int[] array){
			int n = array.length;
			Random rnd = new Random();
			for(int i = 0; i < n; i ++){
				int tmp = array[i];
				int randomPos = i + rnd.nextInt(n - i);
				array[i] = array[randomPos];
				array[randomPos] = tmp;
			}
		}
		void shuffleArray(long[] array){
			int n = array.length;
			Random rnd = new Random();
			for(int i = 0; i < n; i ++){
				long tmp = array[i];
				int randomPos = i + rnd.nextInt(n - i);
				array[i] = array[randomPos];
				array[randomPos] = tmp;
			}
		}
		void shuffleArray(double[] array){
			int n = array.length;
			Random rnd = new Random();
			for(int i = 0; i < n; i ++){
				double tmp = array[i];
				int randomPos = i + rnd.nextInt(n - i);
				array[i] = array[randomPos];
				array[randomPos] = tmp;
			}
		}

		long INF = (long)1e18 + 7;
		boolean isINF(long a) { return abs(a) > INF / 1000; }
		boolean isPlusINF(long a) { return a > 0 && isINF(a); }
		boolean isMinusINF(long a) { return isPlusINF(- a); }
		int I_INF = (int)1e9 + 7;
		boolean isINF(int a) { return abs(a) > I_INF / 1000; }
		boolean isPlusINF(int a) { return a > 0 && isINF(a); }
		boolean isMinusINF(int a) { return isPlusINF(- a); }


		// mods
		long MOD = (long)1e9 + 7; // 998244353;
		public long mod(long i) { i %= MOD; return i + (i < 0 ? MOD : 0); }

		long pow_m(long x, long y) {
			if (y == 0) { return 1;
			}else {
				long tmp = pow_m(x, y / 2);
				return mod(mod(tmp * tmp) * (y % 2 == 0 ? 1 : x));
			}
		}
		long[] pows_m(long x, int max) {
			long pow[] = new long[max + 1];
			pow[0] = 1;
			for(int i = 0; i < max; i ++) {
				pow[i + 1] = mod(pow[i] * x);
			}
			return pow;
		}

		int MAX_INV_SIZE = 100_100;
		HashMap<Long, Long> invMap = new HashMap<>();
		long inv(long x) {
			x = mod(x);
			if(invMap.containsKey(x)) { return invMap.get(x); }
			if(invMap.size() >= MAX_INV_SIZE) { return calInv(x); }
			invMap.put(x, calInv(x));
			return invMap.get(x);
		}
		long calInv(long x) { return pow_m(x, MOD - 2); }

		int MAX_FACT = 5_000_100;
		long fact[];
		long invFact[];
		boolean isFactPrepared = false;
		HashMap<Integer, long[]> factMap;
		void prepareFact() {
			fact = new long[MAX_FACT];
			Arrays.fill(fact, 0);
			invFact = new long[MAX_FACT];
			Arrays.fill(invFact, 0);
			fact[0] = 1;
			int maxIndex = min(MAX_FACT, (int)MOD);
			for(int i = 1; i < maxIndex; i ++) { fact[i] = mod(fact[i - 1] * i); }
			invFact[maxIndex - 1] = inv(fact[maxIndex - 1]);
			for(int i = maxIndex - 1; i > 0; i --) { invFact[i - 1] = mod(invFact[i] * i); }

			factMap = new HashMap<>();
			isFactPrepared = true;
		}

		long P(int n, int r) {
			if(!isFactPrepared) { prepareFact(); }
			if(n < 0 || r < 0 || n < r) { return 0; }
			if(n >= MAX_FACT) {
				if(!factMap.containsKey(n)) {
					long largeFact[] = new long[MAX_FACT];
					factMap.put(n, largeFact);
					fill(largeFact, -INF);
					largeFact[0] = 1;
				}
				long largeFact[] = factMap.get(n);
				int i = r;
				while(isINF(largeFact[i])) { i --; }
				for(; i < r; i ++) { largeFact[i + 1] = mod(largeFact[i] * (n - i)); }
				return largeFact[r];
			}
			return mod(fact[n] * invFact[n - r]);
		}
		long C(int n, int r) {
			if(!isFactPrepared) { prepareFact(); }
			if(n < 0 || r < 0 || n < r) { return 0; }
			return mod(P(n, r) * invFact[r]);
		}
		long H(int n, int r) { return C((n - 1) + r, r); }


		// grid
		class Grids {
			int h;
			int w;
			Grid[][] gs;
			Grids(int h, int w) {
				this.h = h;
				this.w = w;
				gs = new Grid[h][w];
				for(int i = 0; i < h; i ++) {
					for(int j = 0; j < w; j ++) {
						gs[i][j] = new Grid(i, j, h, w);
					}
				}
			}

			void init(boolean[][] b) {
				for(int i = 0; i < h; i ++) {
					for(int j = 0; j < w; j ++) {
						gs[i][j].b = b[i][j];
					}
				}
			}
			void init(long[][] val) {
				for(int i = 0; i < h; i ++) {
					for(int j = 0; j < w; j ++) {
						gs[i][j].val = val[i][j];
					}
				}
			}

			int dx[] = {0, -1, 1, 0, 0, -1, 1, -1, 1};
			int dy[] = {0, 0, 0, -1, 1, -1, -1, 1, 1};
			Grid next(Grid g, int i) {
				return isValid(g.x + dx[i], g.y + dy[i], g.h, g.w)
					? gs[g.x + dx[i]][g.y + dy[i]]
					: null;
			}
		}
		class Grid implements Comparable<Grid> {
			int x;
			int y;
			int h;
			int w;
			int i;
			boolean b;
			long val;

			Grid() {  }
			Grid(int x, int y, int h, int w) { init(x, y, h, w, false, 0); }
			Grid(int x, int y, int h, int w, boolean b) { init(x, y, h, w, b, 0); }
			Grid(int x, int y, int h, int w, long val) { init(x, y, h, w, false, val); }
			Grid(int x, int y, int h, int w, boolean b, long val) { init(x, y, h, w, b, val); }

			void init(int x, int y, int h, int w, boolean b, long val) {
				this.x = x;
				this.y = y;
				this.h = h;
				this.w = w;
				this.b = b;
				this.val = val;
				i = x * w + y;
			}

			@Override
			public int compareTo(Grid g) {
				return Long.compare(this.val, g.val);
			}
		}

		boolean isValid(int x, int y, int h, int w) {
			return x >= 0 && x < h && y >= 0 && y < w;
		}
		boolean isValid(Grid g) {
			return isValid(g.x, g.y, g.h, g.w);
		}

		// graph
		class Graph {
			int numNode;
			int numEdge;
			boolean directed;
			Edge edges[];
			Node nodes[];
			Node reversedNodes[];

			Graph(int numNode, int numEdge, Edge edges[], boolean directed) {
				this.numNode = numNode;
				this.numEdge = numEdge;
				this.directed = directed;
				this.edges = edges;
				nodes = new Node[numNode];
				reversedNodes = new Node[numNode];
				for(int i = 0; i < numNode; i ++) {
					nodes[i] = new Node(i);
					reversedNodes[i] = new Node(i);
				}

				for(Edge edge : edges) {
					nodes[edge.source].add(edge.target, edge.cost);
					if(directed) {
						reversedNodes[edge.target].add(edge.source, edge.cost);
					}else {
						nodes[edge.target].add(edge.source, edge.cost);
					}
				}
			}

			void clearNodes() {
				for(Node n : nodes) { n.clear(); }
				for(Node n : reversedNodes) { n.clear(); }
			}
		}

		class Node {
			int id;
			ArrayList<Edge> edges = new ArrayList<Edge>();

			Node(int id) {
				this.id = id;
			}
			void add(int target, long cost) {
				edges.add(new Edge(id, target, cost));
			}
			void clear() {
				edges.clear();
			}
		}

		class Edge implements Comparable<Edge> {
			int source;
			int target;
			long cost;
			Edge(int source, int target, long cost) {
				this.source = source;
				this.target = target;
				this.cost = cost;
			}

			@Override
			public int compareTo(Edge e) {
				return Long.compare(this.cost, e.cost);
			}
		}

public void solve() {
	int numNode = ni();
	int num = numNode;
	int n = num;
	int numEdge = numNode - 1;
	Edge edges[] = new Edge[numEdge];
	for(int i = 0; i < numEdge; i ++) {
		int a = ni() - 1;
		int b = ni() - 1;
		long c = 1;
		edges[i] = new Edge(a, b, c);
	}
	Graph g = new Graph(numNode, numEdge, edges, false);
	long dist[] = bfs(g.nodes, 0);
	int cnt[] = {0, 0};
	for(int i = 0; i < numNode; i ++) {
		cnt[(int)(dist[i] % 2)] ++;
		dist[i] %= 2;
	}
	long ans[] = new long[num];
	// errprtln(cnt);
	if(min(cnt) <= num / 3) {
		int k = cnt[0] < cnt[1] ? 0 : 1;
		int tmp = 1;
		int tmp3 = 1;
		for(int i = 0; i < num; i ++) {
			if(dist[i] == k) {
				ans[i] = tmp3 * 3;
				tmp3 ++;
			}else {
				ans[i] = tmp;
				tmp ++;
				if(tmp % 3 == 0) tmp ++;
			}
		}
	}else {
		int tmp1 = 0;
		int tmp2 = 0;
		int tmp3 = 1;
		for(int i = 0; i < num; i ++) {
			if(dist[i] == 0) {
				if(tmp1 * 3 + 1 <= n) {
					ans[i] = tmp1 * 3 + 1;
					tmp1 ++;
				}else {
					ans[i] = tmp3 * 3;
					tmp3 ++;
				}
			}else if(dist[i] == 1) {
				if(tmp2 * 3 + 2 <= n) {
					ans[i] = tmp2 * 3 + 2;
					tmp2 ++;
				}else {
					ans[i] = tmp3 * 3;
					tmp3 ++;
				}
			}
		}
	}
	prtln(ans);
	Arrays.sort(ans);
	for(int i = 0; i < num; i ++) {
		if(ans[i] != i + 1) throw new RuntimeException();
	}
}

long[] bfs(Node nodes[], int start) {
	long dist[] = new long[nodes.length];
	Arrays.fill(dist, INF);

	Deque<Integer> s = new ArrayDeque<>();
	s.addLast(start);
	dist[start] = 0;
	while(!s.isEmpty()) {
		int crt = s.removeFirst();
		for(Edge e : nodes[crt].edges) {
			if(isINF(dist[e.target])) {
				dist[e.target] = dist[e.source] + 1;
				s.addLast(e.target);
			}
		}
	}

	return dist;
}

	}
}"
84,"
public class Main {

  private static void solve() {
    int h = ni();
    int w = ni();
    int k = ni();
    char[][] map = new char[h + 1][w];
    for (int i = 0; i < h; i++) {
      map[i] = ns();
    }

    int idx = 1;
    int top = 0;
    int[][] ret = new int[h][w];
    int cnt = 0;
    int total = 0;
    for (int i = 0; i < h; i++) {
      for (int j = 0; j < w; j++) {
        if (map[i][j] == '#') {
          cnt++;
          total++;
        }
      }
      if (total < k && cnt > 0 || i == h - 1) {
        for (int j = 0; j < w; j++) {
          boolean flg = false;
          for (int s = top; s <= i; s++) {
            ret[s][j] = idx;
            if (map[s][j] == '#') {
              flg = true;
            }
          }
          if (flg) {
            cnt--;
            if (cnt > 0) {
              idx++;
            }
          }
        }
        idx++;
        top = i + 1;
        cnt = 0;
      }
    }
    for (int i = 0; i < h; i++) {
      for (int j = 0; j < w; j++) {
        System.out.print(ret[i][j] + "" "");
      }
      System.out.println();
    }
  }

  public static int lowerBound(int[] a, int u, int v) {
    int low = u, high = a.length;
    while (high - low > 1) {
      int h = high + low >>> 1;
      if (a[h] >= v) {
        high = h;
      } else {
        low = h;
      }
    }
    return high;
  }

  public static void main(String[] args) {
    new Thread(null, new Runnable() {
      @Override
      public void run() {
        long start = System.currentTimeMillis();
        String debug = args.length > 0 ? args[0] : null;
        if (debug != null) {
          try {
            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));
          } catch (Exception e) {
            throw new RuntimeException(e);
          }
        }
        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);
        solve();
        out.flush();
        tr((System.currentTimeMillis() - start) + ""ms"");
      }
    }, """", 64000000).start();
  }

  private static java.io.InputStream is = System.in;
  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);
  private static java.util.StringTokenizer tokenizer = null;
  private static java.io.BufferedReader reader;

  public static String next() {
    while (tokenizer == null || !tokenizer.hasMoreTokens()) {
      try {
        tokenizer = new java.util.StringTokenizer(reader.readLine());
      } catch (Exception e) {
        throw new RuntimeException(e);
      }
    }
    return tokenizer.nextToken();
  }

  private static double nd() {
    return Double.parseDouble(next());
  }

  private static long nl() {
    return Long.parseLong(next());
  }

  private static int[] na(int n) {
    int[] a = new int[n];
    for (int i = 0; i < n; i++)
      a[i] = ni();
    return a;
  }

  private static char[] ns() {
    return next().toCharArray();
  }

  private static long[] nal(int n) {
    long[] a = new long[n];
    for (int i = 0; i < n; i++)
      a[i] = nl();
    return a;
  }

  private static int[][] ntable(int n, int m) {
    int[][] table = new int[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        table[i][j] = ni();
      }
    }
    return table;
  }

  private static int[][] nlist(int n, int m) {
    int[][] table = new int[m][n];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        table[j][i] = ni();
      }
    }
    return table;
  }

  private static int ni() {
    return Integer.parseInt(next());
  }

  private static void tr(Object... o) {
    if (is != System.in)
      System.out.println(java.util.Arrays.deepToString(o));
  }
}

"
85,"import java.util.Scanner;

public class AtCoder {
	public static void main(String[] args){
		Scanner keyboard = new Scanner(System.in);
		int input = keyboard.nextInt();
		System.out.println(input*input*input); //Math.pow would output double
	}
}"
86,"import java.util.Scanner;
class Main{
  public static void main(String[] args){
    Scanner sc = new Scanner(System.in);
    int w = sc.next();
    int h = sc.next();
    int x = sc.next();
    int y = sc.next();
    int b = 0;
    double a = ((double)w * (double)h) / 2;
    if(w / 2 == x && h / 2 == y){
      b = 1;
    }
   
    System.out.println(a + "" "" + b);
  }
}"
87,"import java.math.BigInteger;
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		int n = scanner.nextInt();
		BigInteger p = new BigInteger(scanner.next());
		String s = scanner.next();

		int count = 0;

		for (int i = 0; i < n; i++) {
			for (int j = i + 1; j < n + 1; j++) {
				if (new BigInteger(s.substring(i, j)).remainder(p).equals(BigInteger.ZERO))
					count++;
			}
		}
		System.out.println(count);

	}

}
"
88,"import java.util.*;

class Main {

    static int gcd(int a, int b) {
        return b > 0 ? gcd(b, a % b) : a;
    }

    static int lcm(int a, int b) {
        return a * b / gcd(a, b);
    }

    public static void main(String[] args) {

        long a = 0;
        long b = 0;
        Scanner sc = new Scanner(System.in);
        long x = sc.nextLong();

        for (int i = -256; i < 255; i++) {
            for (int j = -256; j < 255; j++) {
                if (i != j && x % (i - j) == 0) {
                    long tmpx = x / ((long) i - (long) j);
                    if ((long) (i * i * i * i) + (long) (i * i * i * j) + (long) (i * i * j * j)
                            + (long) (i * j * j * j) + (long) (j * j * j * j) == tmpx) {
                        a = i;
                        b = j;
                    }
                }
            }
        }

        System.out.println(a + "" "" + b);
        sc.close();
    }
}
"
89,"import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.next();
        String ans = """";
        for (int i = 0 ; i < s.length() ; i ++) {
            if (i % 2 == 0) {
                ans += String.valueOf(s.charAt(i));
            }
        }
        System.out.println(ans);
    }

}"
90,"import java.util.*;
import java.io.*;

public class Main {
	
	public void sort(int[][] data){
		for(int i = 0; i < data.length; i++){
			int min = i;
			for(int j = i+1; j < data.length; j++){
				if( data[min][2] > data[j][2] ){
					min = j;
				} else if( data[min][2] == data[j][2] ){
					if( data[min][1] > data[j][1] ){
						min = j;
					}
				}
			}
			for(int j = 0; j < 3; j++){
				int temp = data[min][j];
				data[min][j] = data[i][j];
				data[i][j] = temp;
			}
		}
	}
	public int[] nextPermutation(int[] x, int index){
		int max = index;
		boolean[] temp = new boolean[x.length];
		for(int i = index; i < x.length; i++){
			temp[x[i]-1] = true;
			if( x[i] > x[max] ){
				max = i;
			}
		}
		int key = index+1;
		if( max == index ){
			for(; index > 0; index--){
				temp[x[index-1]-1] = true;
				if( x[index] > x[index-1] ){
					break;
				}
			}
			if( index == 0 ){
				x[0] = -1;
				return x;
			}
			key = index;
		} 

		for(int i = x[key-1]; i < temp.length; i++){
			if( temp[i] ){
				x[key-1] = i+1;
				temp[i] = false;
				break;
			}
		}		
		int count = 0;
		for(int i = 0; i < temp.length; i++){
			if( temp[i] ){
				x[key+count] = i+1;
				count++;
			}
		}			
		return x;
	}
			
	public  void solve() throws IOException{
		int n = nextInt();
		int[][] data = new int[n][3];		
		for(int i = 0; i < n; i++){
			data[i][0] = nextInt();
			data[i][1] = nextInt();
			data[i][2] = nextInt();			
		}
		sort(data);		
		int[] x = new int[n];
		for(int i = 0; i < x.length; i++){
			x[i] = i+1;
		}
		double min = 1000000001;
		int[] ans = new int[n];
		System.arraycopy(x, 0, ans, 0, n);
	//	int count = 0;
		while( x[0] > 0 ){
		//	count++;
			int[] total = new int[n];
			int high = data[x[n-1]-1][1];
			int low = high;
			for(int i = n-2; i >= 0; i--){
				high = Math.max(high, data[x[i]-1][1]);
				low = Math.min(low, data[x[i]-1][1]);
				total[i] = high-low;
			}		
			double sum = 0;
			double w = 0;
			double v = (double)2000/70;	
			int i = 0;		
			for(; i < x.length-1; i++){
				if( sum + total[i]/v > min ){
	//				writer.println(""cut at "" + i + "", v = "" + v + "", sum = "" + sum);
					sum = min;
					break;
				}
				int len = Math.abs(data[x[i]-1][1]-data[x[i+1]-1][1]);
				w += 20*data[x[i]-1][2];
				v = 2000/(70+w);
				sum += len/v;								
			}
			if( sum < min ){
				System.arraycopy(x, 0, ans, 0, n);
				min = sum;
			}
			i = Math.min(i, n-1);
			x = nextPermutation(x, i);			
		}
//		writer.println(count);
//		writer.println(min);
		writer.print(data[ans[0]-1][0]);
		for(int i = 1; i < n; i++){
			writer.print("" "" + data[ans[i]-1][0]);
		}
		writer.println();		
		writer.flush();			
	}
	public static void main (String args[]) throws IOException{
		new Main().run();
	}
	
	BufferedReader reader;
	StringTokenizer tokenizer;
	PrintWriter writer;
	
	public void run() throws IOException{
		try{
			reader = new BufferedReader(new InputStreamReader(System.in));
			tokenizer = null;
			writer = new PrintWriter(System.out);
			solve();
			reader.close();
			writer.close();
		} catch (Exception e){
			e.printStackTrace();
			System.exit(1);
		}
	}
	public int nextInt() throws IOException{
		return Integer.parseInt(nextToken());
	}		
	public String nextToken() throws IOException{
		while( tokenizer == null || !tokenizer.hasMoreTokens() ){
			tokenizer = new StringTokenizer(reader.readLine());
		}
		return tokenizer.nextToken();
	}
}"
91,"import java.util.*;
                   
class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        int[] R = new int[t];
        int i, min, bnf;
        for(i=0; i<t; i++) R[i] = sc.nextInt();
        min = R[0];
        bnf = Integer.MIN_VALUE;
        for(i=1; i<t; i++){
            bnf = Math.max(bnf, R[i]-min);
            min = Math.min(min, R[i]);
        }
                    
        System.out.println(bnf);
    }
}"
92,"import java.util.Scanner;
public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		String[] s = sc.next().split("""");
		int count = 0;
		for (int i = 1; i< s.length; i++)
			if (!s[i].equals(s[i - 1]))
				count++;
		System.out.println(count);
	}
}"
93,"import java.util.Scanner;

public class ABC141A {

    public static void main(String args[]){
        Scanner scan = new Scanner(System.in);
        String today = scan.nextLine();

        String tomorrow = """";
        switch (today){
            case ""Sunny"":
                tomorrow = ""Cloudy"";
                break;
            case ""Cloudy"":
                tomorrow = ""Rainy"";
                break;
            case ""Rainy"":
                tomorrow = ""Sunny"";
                break;
        }

        System.out.println(tomorrow);
    }
}
"
94,"import java.io.*;
import java.util.*;

class Main{
	public static void main(String[] args){
		solve();
	}
	public static void solve(){
		Scanner sc = new Scanner(System.in);
		long n = sc.nextLong();
		long m = sc.nextLong();
		long count = Math.abs((n-2)*(m-2));
		
		System.out.println(count);
	}
}"
95,"// -*- coding: utf-8 -*-
//import java.awt.*;
import java.io.*;
import java.math.*;
import java.text.*;
import java.util.*;

public class Main {
  public static void main(String[] args) {
    InputStream inputStream;
    if (args.length > 0 && args[0].equals(""devTesting"")) {
      try {
        inputStream = new FileInputStream(args[1]);
      } catch(FileNotFoundException e) {
        throw new RuntimeException(e);
      }
    } else {
      inputStream = System.in;
    }
    OutputStream outputStream = System.out;
    InputReader in = new InputReader(inputStream);
    PrintWriter out = new PrintWriter(outputStream);
    TaskE solver = new TaskE();
    solver.solve(1, in, out);
    out.close();
  }
  
  static class TaskE {    
    int n, l, q, xi, ai, bi;
    int[] hotelsPos;
    int[][] right, left;
    
    void solve(int testNumber, InputReader in, PrintWriter out) {
      n = in.nextInt();
      hotelsPos = new int[n];
      for (int i = 0; i < n; ++i) {
        hotelsPos[i] = in.nextInt();
      }
      l = in.nextInt();
      q = in.nextInt();
      pre();
      for (int i = 0; i < q; ++i) {
        ai = in.nextInt();
        bi = in.nextInt();
        --ai;
        --bi;
        out.println(query(ai, bi));
      }
    }
    
    void pre() {
      right = new int[32][n];
      left = new int[32][n];
      right[0][n - 1] = n;
      left[0][0] = -1;
      for (int i = 0; i < n - 1; ++i) {
        right[0][i] = Arrays.binarySearch(hotelsPos, hotelsPos[i] + l);
        if (right[0][i] < 0) {
          right[0][i] = ~right[0][i]; 
          --right[0][i];
        }
      }
      for (int i = 1; i < n; ++i) {
        left[0][i] = Arrays.binarySearch(hotelsPos, hotelsPos[i] - l);
        if (left[0][i] < 0) {
          left[0][i] = ~left[0][i]; 
        }
      }
      for (int i = 1; i < 32; ++i) { // f^(2^m)[i] = f^(2^(m - 1))[f^(2^(m - 1))[i]] -- O(n log(2^(max m))) = O(nm)
        for (int j = 0; j < n; ++j) {
          if (right[i - 1][j] < n) {
            right[i][j] = right[i - 1][right[i - 1][j]];
          } else {
            right[i][j] = n;
          }
          if (left[i - 1][j] > -1) {
            left[i][j] = left[i - 1][left[i - 1][j]];
          } else {
            left[i][j] = -1;
          }
        }
      }
    }
    
    int query(int a, int b) {
      int lo = 1, hi = Integer.MAX_VALUE / 2;
      while (true) {
        int mid = (lo + hi) / 2;
        if (can(a, b, mid)) {
          if (lo == hi) {
            return mid;
          }
          hi = mid;
        } else {
          lo = mid + 1;
        }
      }
    }
    
    boolean can(int a, int b, int val) {
      int ptr = a;
      for (int i = 31; ptr > -1 && ptr < n && i >= 0; --i) {
        if ((val & 1 << i) != 0) {
          ptr = a < b ? right[i][ptr] : left[i][ptr];
        }
      }
      if (a < b) {
        return ptr >= b;
      }
      return ptr <= b;
    }    
    
  }
      
  static class InputReader {
    public BufferedReader reader;
    public StringTokenizer tokenizer;

    public InputReader(InputStream stream) {
      reader = new BufferedReader(new InputStreamReader(stream));
      tokenizer = null;
    }

    public String next() {
      while (tokenizer == null || !tokenizer.hasMoreTokens()) {
        try {
          tokenizer = new StringTokenizer(reader.readLine());
        } catch (IOException e) {
          throw new RuntimeException(e);
        }
      }
      return tokenizer.nextToken();
    }
    
    public String nextLine() {
      try {
        return reader.readLine();
      } catch(IOException e) {
        throw new RuntimeException(e);
      }
    }

    public int nextInt() {
      return Integer.parseInt(next());
    }

    public long nextLong() {
      return Long.parseLong(next());
    }
    
    public double nextDouble() {
      return Double.parseDouble(next());
    }

    public boolean hasInput() {
      try {
        if (tokenizer != null && tokenizer.hasMoreTokens()) {
          return true;
        }
        reader.mark(1);
        int ch = reader.read();
        if (ch != -1) {
          reader.reset();
          return true;
        }
        return false;
      } catch(IOException e) {
        throw new RuntimeException(e);
      }
    }
    
  }
}
"
96,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.StringTokenizer;


public class Main {
	
	public static void main(String[] args){
		try(final Scanner sc = new Scanner(System.in)){
			int a_count = 0, b_count = 0, c_count = 0;
			for(final char c : sc.next().toCharArray()){
				switch (c) {
				case 'a': a_count++; break;
				case 'b': b_count++; break;
				case 'c': c_count++; break;
				}
			}
			
			final int sum = a_count + b_count + c_count;
			final int max_count = Math.max(a_count, Math.max(b_count, c_count));
			final int min_count = Math.min(a_count, Math.min(b_count, c_count));
			final int mid_count = sum - max_count - min_count;
			
			final int rest_count = sum - max_count;
			
			if(max_count >= rest_count){
				final int diff = max_count - rest_count;
				
				if(min_count == 0){
					System.out.println(diff <= 0 ? ""YES"" : ""NO"");
				}else{
					System.out.println(diff <= 1 ? ""YES"" : ""NO"");
				}
				
				throw new RuntimeException();
				
				// min_count >= 1
			}else{
				final int must_fill = mid_count - min_count;
				final int req_must_fill = must_fill;
				final int max_must_fill = must_fill;
				
				final int common_fill = min_count;
				final int req_common_fill = common_fill + 1;
				final int max_common_fill = common_fill + 2;
				
				//System.out.println(req_must_fill);
				//System.out.println(req_must_fill + req_common_fill);
				//System.out.println(max_must_fill + "" "" + max_common_fill);
				//System.out.println(max_must_fill + max_common_fill);
				
				if(req_must_fill + req_common_fill > max_count){
					System.out.println(""NO"");
				}else if(max_must_fill + max_common_fill < max_count){
					System.out.println(""NO"");
				}else{
					System.out.println(""YES"");
				}
			}
		}
	}
	
	public static class Scanner implements AutoCloseable {
		private BufferedReader br;
		private StringTokenizer tok;

		public Scanner(InputStream is) {
			br = new BufferedReader(new InputStreamReader(is));
		}

		private void getLine() {
			try {
				while (!hasNext()) {tok = new StringTokenizer(br.readLine());}
			} catch(IOException e){ /* ignore */ }
		}

		private boolean hasNext() {
			return tok != null && tok.hasMoreTokens();
		}

		public String next() {
			getLine(); return tok.nextToken();
		}

		public int nextInt(){
			return Integer.parseInt(next());
		}
		public long nextLong(){
			return Long.parseLong(next());
		}
		public double nextDouble(){
			return Double.parseDouble(next());
		}
		
		public int[] nextIntArray(int n){
			int[] ret = new int[n];
			for(int i = 0; i < n; i++){ ret[i] = nextInt(); }
			return ret;
		}
		public long[] nextLongArray(int n){
			long[] ret = new long[n];
			for(int i = 0; i < n; i++){ ret[i] = nextLong(); }
			return ret;
		}
		public double[] nextDoubleArray(int n){
			double[] ret = new double[n];
			for(int i = 0; i < n; i++){ ret[i] = nextDouble(); }
			return ret;
		}

		public void close() {
			try{ br.close(); } catch (IOException e){ /*ignore*/ }
		}
	}
}
"
97,"import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while (true) {
			int x = sc.nextInt();
			int y = sc.nextInt();
			if (x == 0 && y == 0)
				break;
			else
				opi(x, y);
			System.out.println();
		}
		sc.close();
	}

	static void opi(int x, int y) {
		for (int i = 0; i < x; i++) {
			for (int j = 0; j < y; j++) {
				System.out.print(""#"");
			}
			System.out.println();
		}
	}
}

"
98,"
import java.util.*;
import java.io.*;

public class Main {

	private static final int mod =(int)1e9+7;
	public static void main(String[] args) throws Exception  {
	      Scanner  sc=new Scanner(System.in);
	      PrintWriter out=new PrintWriter(System.out);
	  int n=sc.nextInt();
	  int k=sc.nextInt();
	  Map<Integer,Integer> map=new TreeMap<>();

	  for(int i=0;i<n;i++) {
	    int a=sc.nextInt();
	   int b=sc.nextInt();
	   
	   map.put(a, map.getOrDefault(a,0)+b);
	  
	     
	}
	for(int i=1;i<=100001;i++) {
	   if(map.containsKey(i)) {
	      if(map.get(i)>=k) {
	        System.out.println(i);
	  break;
	      }else {
	        k=k-map.get(i);
	      }
	   }
	  }
	}


	static boolean vis[]=new boolean[10001];
	      static long gcd(long a, long b) 
	      { 
	          if (a == 0) 
	              return b; 
	          return gcd(b % a, a); 
	      } 

static long nCr(int n,int r) {
  int dp[][]=new int[2001][2001];
  for(int i=0;i<2001;i++) {
    dp[0][i]=0;
  }
  for(int i=0;i<2001;i++) {
    dp[i][0]=1;
  }
  for(int i=1;i<2001;i++) {
    for(int j=1;j<2001;j++) {
      if(i==j) {
        dp[i][j]=1;
      }else {
        dp[i][j]=dp[i-1][j-1]+dp[i][j-1];
      }
    }
  }
  return dp[n][r];
}


      
}
"
99,"import java.util.*;
import java.io.*;

public class B{

	
	
	public static void main(String[] args) throws IOException {
		Scanner sc=new Scanner(System.in);
		PrintWriter  out=new PrintWriter(System.out);
		int n=sc.nextInt();
		int []a=new int [n];
		int hi=0;
		for(int i=0;i<n;i++)
		{
			a[i]=sc.nextInt();
			hi=Math.max(hi,a[i]);
		}
		int lo=0;
		long min=(n*1L*(n-1)/2+1)/2;
		int ans=-1;
		// binary search on the greatest x such that the # of pairs(l,r) such that m(l,r) is >=x is>= (n*(n-1)/2)/2
		while(lo<=hi) 
		{
			int mid=(lo+hi)/2;
			long pairs=0;
			for(int l=0;l<n;l++) 
			{
				
				for(int r=l;r<n;r++)
				{
					int cnt=0;
					for(int k=l;k<=r;k++)
						if(a[k]>=mid)
							cnt++;
						else
							cnt--;
					if(cnt>=0)
						pairs++;
					
				}
			}
			if(pairs>=min) 
			{
				ans=mid;
				lo=mid+1;
			}
			else 
				hi=mid-1;
			
				
			/*int []s=new int [n+1];
			for(int i=1;i<=n;i++)
			{
				if(a[i-1]>=mid)
					s[i]=1;
				else
					s[i]=-1;
				s[i]+=s[i-1];
			}
			long inversions=0;*/
			
					
		}
		out.println(ans);
		out.close();
	}
	
	
	static class Scanner {
        StringTokenizer st;
        BufferedReader br;
 
        public Scanner(InputStream s) {
            br = new BufferedReader(new InputStreamReader(s));
        }
 
        public Scanner(FileReader s) {
            br = new BufferedReader(s);
        }
 
        public String next() throws IOException {
            while (st == null || !st.hasMoreTokens())
                st = new StringTokenizer(br.readLine());
            return st.nextToken();
        }
 
        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }
 
        public long nextLong() throws IOException {
            return Long.parseLong(next());
        }
 
        public String nextLine() throws IOException {
            return br.readLine();
        }
        public boolean ready() throws IOException {return br.ready();}
        public double nextDouble() throws IOException {return Double.parseDouble(next());}
       
    }

}"
100,"import java.util.Scanner;
public class Main {
	public static void main(String[] args){
		Scanner scan=new Scanner(System.in);
		int r;
		r=scan.nextInt();
		System.out.println(r*r*Math.PI+"" ""+2*r*Math.PI);
	scan.close();		
	}
}
"
101,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;


public class Main {

	/**
	 * @param args
	 * @throws IOException 
	 */
	public static void main(String[] args) throws IOException {
		// TODO Auto-generated method stub
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		String[] tmpArray = br.readLine().split("" "");
		int h = Integer.parseInt(tmpArray[0]);
		int w = Integer.parseInt(tmpArray[1]);

		char[][] matrix = new char[h][w];
		
		for(int i = 0; i < h; i++){
			String tmpStr = br.readLine();
			for(int j = 0; j < w; j++){
				matrix[i][j] = tmpStr.charAt(j);
			}
		}

		tmpArray = br.readLine().split("" "");
		int r = Integer.parseInt(tmpArray[0]);
		int c = Integer.parseInt(tmpArray[1]);

		char[][] pattern = new char[r][c];
		for(int i = 0; i < r; i++){
			String tmpStr = br.readLine();
			for(int j = 0; j < c; j++){
				pattern[i][j] = tmpStr.charAt(j);
			}
		}
		
		int complexRow = complexRow(pattern);
		
		//??¢?´¢????§?
		for(int i = 0; i + r <= h ; i++){
			char[] str1char = Arrays.copyOf(matrix[i+complexRow], w);
			char[] str2char = Arrays.copyOf(pattern[complexRow], c);
			int sumOfIndex = 0;
			while(true){
				//System.out.println(""str1 "" + new String(str1char) + ""str2 ""+ new String(str2char));
				int index = BMSearcher.indexOf(str1char, str2char);
				
				if(index == -1){
					break;
				}
				
				sumOfIndex += index;
				//System.out.println(sumOfIndex);
				if(isMatch(matrix, pattern, i, sumOfIndex)){
					System.out.println(i+"" ""+sumOfIndex);
				}
				
				str1char = Arrays.copyOfRange(str1char, index + 1, str1char.length);
				sumOfIndex++;
				if(str1char.length == 0 || str1char.length < str2char.length){
					break;
				}
				
			}
			
		}
	}
	
	static int complexRow (char[][] pattern){
		int charType = 0;
		int index = 0;
		for(int i = 0; i < pattern.length; i++){
			int tmp = countCharType(pattern[i]);
			
			//??£??´???????????????????????°??????
			if(tmp >= 5){
				//System.out.println(""enough at ""+i);
				return i;
			}
			else if (tmp > charType){
				charType = tmp;
				index = i;
			}
		}
		
		//System.out.println(""max charType = ""+charType);
		return index;
	}
	
	static int countCharType(char[] str){
		int[] countArray = new int[255];
		int count = 0;
		
		for(int i = 0; i < str.length ; i++){
			char tmp = str[i];
			if(countArray[tmp] == 0){
				count++;
			}
			countArray[tmp]++;
		}
		
		return count;
	}
	
	static int countCharType(String str){
		int[] countArray = new int[255];
		int count = 0;
		
		char[] strChar = str.toCharArray();
		
		for(int i = 0; i < strChar.length ; i++){
			char tmp = strChar[i];
			if(countArray[tmp] == 0){
				count++;
			}
			countArray[tmp]++;
		}
		
		return count;
	}
	
	static boolean isMatch(char[][] matrix, char[][] pattern, int y, int x){
		for(int i = y; i < y + pattern.length ; i++){
			for(int j = x; j < x + pattern[0].length ; j++){
				if(matrix[i][j] != pattern[i - y][j - x]){
					return false;
				}
			}
		}
		return true;
	}

}

class BMSearcher {
	public static int indexOf(char[] str1, char[] str2){
		if (str2.length == 0){
			return 0;
		}
		
		int charTable[] = makeCharTable(str2);
		int offsetTable[] = makeOffsetTable(str2);
		for(int i = str2.length - 1, j; i < str1.length ;){
			for(j = str2.length - 1; str2[j] == str1[i] ; i--, j--){
				if(j == 0){
					return i;
				}
			}
			
			i += Math.max(offsetTable[str2.length - 1 - j], charTable[str1[i]]);
			
		}
		return -1;
	}
	
	private static int[] makeCharTable(char[] str) {
		final int ALPHABET_SIZE = 256;
		int[] table = new int[ALPHABET_SIZE];
		for(int i = 0; i < table.length ; i++){
			table[i] = str.length;
		}
		for(int i = 0; i < str.length - 1; i++){
			table[str[i]] = str.length - 1 - i;
		}
		return table;
	}
	
	private static int[] makeOffsetTable(char[] str){
		int[] table = new int[str.length];
		int lastPrefixPosition = str.length;
		for(int i = str.length - 1; i >= 0; i--){
			if(isPrefix(str, i + 1)) {
				lastPrefixPosition = i + 1;
			}
			table[str.length - 1 - i] = lastPrefixPosition - i + str.length - 1;
		}
		for(int i = 0; i < str.length - 1; i++){
			int slen = suffixLength(str, i);
			table[slen] = str.length - 1 - i + slen;
		}
		return table;
	}
	
	private static boolean isPrefix(char[] str, int p){
		for (int i = p, j = 0; i < str.length; i++, j++){
			if(str[i] != str[j]){
				return false;
			}
		}
		return true;
	}
	
	private static int suffixLength(char[] str, int p){
		int len = 0;
		for(int i = p, j = str.length - 1;
				i >= 0 && str[i] == str[j]; i--, j--){
			len += 1;
		}
		return len;
	}
}"
102,"
import java.io.PrintWriter;
import java.util.LinkedList;
import java.util.Scanner;


public class Main {

	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ

		Scanner scan = new Scanner(System.in);

		int N=Integer.parseInt(scan.next());
		int M=Integer.parseInt(scan.next());

		Root[] root = new Root[N+1];
		for(int i=0;i<N+1;i++){
			root[i] = new Root();
		}
		int F=-1;
		int L=-1;

		boolean[] contain = new boolean[N+1];
		LinkedList<Integer> path = new LinkedList<Integer>();
			for(int i=0;i<M;i++){
				int a=Integer.parseInt(scan.next());
				int b=Integer.parseInt(scan.next());

				root[a].add(b);
				root[b].add(a);

				if(i==0){
					path.add(a);
					path.add(b);
					F=a;
					L=b;
					contain[a]=true;
					contain[b]=true;
				}
			}

/*			root[F].removeFirstOccurrence(L);
			root[L].removeFirstOccurrence(F);*/



			int nextF;



outside:	while(true){
//			F = path.getFirst();
		for(int i=0;i<root[F].size();i++){
				nextF = root[F].get(i);
					//先頭と繋がれた場所がパス内にあるかどうか
					if(contain[nextF]){
						continue;//パス内にあれば次の場所について調べる
					}else{
						path.addFirst(nextF);
//						root[nextF].removeFirstOccurrence(F);
//						root[nextF].removeFirstOccurrence(L);
//						root[L].removeFirstOccurrence(nextF);
						contain[nextF]=true;
						F=nextF;
						continue outside;//無ければ追加して先頭を更新し、先頭について調べなおす
					}

				}
			break;
		}


outside:	while(true){
//			F = path.getLast();
			for(int i=0;i<root[L].size();i++){
				nextF = root[L].get(i);
				//先頭と繋がれた場所がパス内にあるかどうか
				if(contain[nextF]){
					continue;//パス内にあれば次の場所について調べる
				}else{
					path.addLast(nextF);
//					root[nextF].removeFirstOccurrence(F);
					contain[nextF]=true;
					L=nextF;
					continue outside;//無ければ追加して先頭を更新する
				}


				}
			break;
	}

		PrintWriter out =new PrintWriter(System.out);
		out.println(path.size());
		for(int i=0;i<path.size();i++){
			out.print(path.get(i)+"" "");
		}
		out.println("""");
		out.flush();
		out.close();
	}

}

class Root extends LinkedList<Integer>{

}

"
103,"
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int n = Integer.parseInt(br.readLine());

        Deque<Integer> list = new ArrayDeque<>();

        for (int i = 0; i < n; i++) {
            String sp = br.readLine();
            if (sp.startsWith(""insert"")) {
                list.addFirst(Integer.parseInt(sp.substring(sp.indexOf("" "") + 1)));
            } else if (sp.equals(""deleteFirst"")) {
                list.removeFirst();
            } else if (sp.equals(""deleteLast"")) {
                list.removeLast();
            } else {
                list.remove(Integer.parseInt(sp.substring(sp.indexOf("" "") + 1)));
            }
        }
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringBuilder ans = new StringBuilder();
        ans.append(list.poll());
        for (Integer s : list) {
            ans.append("" "");
            ans.append(s);
        }
        bw.write(ans.toString());
        bw.newLine();
        bw.close();
        br.close();
    }
}

"
104,"import java.util.Scanner;

class Main0001 {

	public static void main(String[] a) {
		// 入力
		Scanner sc = new Scanner(System.in);
		int result[] = new int[10];
		for (int i = 0; i < 10; i++) {
			result[i] = sc.nextInt();
		}
		sc.close();

		// 出力
		for (int i = 0; i < 3; i++) {
			int maxIndex = i;
			for (int j = i + 1; j < result.length; j++) {
				if (result[maxIndex] < result[j]) {
					maxIndex = j;
				}
			}
			System.out.print(result[maxIndex]);
			result[maxIndex] = 0;
			if (i < 2) {
				System.out.println();
			}
		}
	}
}"
105,"import java.util.*;

class Main{
  public static void main(String[] args){
    Scanner sc = new Scanner(System.in);
    String s = sc.nextLine();
    String r = ""R"";
    int count = s.indexOf(r);
    int lastcount = s.lastIndexOf(r);
    if(s.contentEquals(""RRR"")){
      System.out.println(""3"");
    }else if(s.contentEquals(""SSR"")){
      System.out.println(""1"");
    }else if(s.contentEquals(""SRS"")){
      System.out.println(""1""); 
    }else if(s.contentEquals(""RSS"")){
      System.out.println(""1"");
    }else if(count == 0 && lastcount == 1 || count == 1 && lastcount == 2){
      System.out.println(""2"");
    }else if(count == 0 && lastcount == 2 || count == 2 && lastcount == -1|| count == 0 && lastcount == -1|| count == 1 && lastcount == -1 ){
      System.out.println(""1"");
    }else if(s.contentEquals(""SSS"")){
      System.out.println(""0"");

    }
  }
}

"
106,"import java.io.*;
import java.util.*;

public class Main {

    private static FastReader in = new FastReader(System.in);
    private static PrintWriter out = new PrintWriter(System.out);

    public static void main(String[] args) {
        solve();
        out.flush();
    }

    private static void solve() {
        int h = in.nextInt();
        int w = in.nextInt();
        // true if '#' (wall)
        boolean[][] maze = new boolean[h][w];

        for (int i = 0; i < h; i++) {
            char[] row = in.nextLine().toCharArray();
            for (int j = 0; j < w; j++) {
                maze[i][j] = row[j] == '#';
            }
        }

        int max = 0;
        for (int i = 0; i < h; i++) {
            for (int j = 0; j < w; j++) {
                max = Math.max(max, searchFarthest(maze, i, j));
            }
        }
        out.println(max);
    }

    private static final List<Map.Entry<Integer, Integer>> dCoordsSet;

    static {
        dCoordsSet = new ArrayList<>();
        dCoordsSet.add(
                new AbstractMap.SimpleEntry<>(-1, 0)
        );
        dCoordsSet.add(new AbstractMap.SimpleEntry<>(1, 0));
        dCoordsSet.add(new AbstractMap.SimpleEntry<>(0, 1));
        dCoordsSet.add(new AbstractMap.SimpleEntry<>(0, -1));
    }

    private static int searchFarthest(boolean[][] maze, int startI, int startJ) {
        if (maze[startI][startJ]) return 0;

        int height = maze.length;
        int width = maze[0].length;
        boolean[][] visited = new boolean[height][width];

        Queue<Map.Entry<Integer, Map.Entry<Integer, Integer>>> bfs = new ArrayDeque<>();
        bfs.add(new AbstractMap.SimpleEntry<>(0,
                new AbstractMap.SimpleEntry<>(startI, startJ)));

        int max = 0;
        while (!bfs.isEmpty()) {
            Map.Entry<Integer, Map.Entry<Integer, Integer>> next = bfs.poll();
            max = Math.max(next.getKey(), max);
            int i = next.getValue().getKey();
            int j = next.getValue().getValue();
            // out.println(""Searching i = "" + i + "", j = "" + j + "", length = "" + next.getKey());
            visited[i][j] = true;

            for (Map.Entry<Integer, Integer> dCoord : dCoordsSet) {
                int nextI = i + dCoord.getKey();
                int nextJ = j + dCoord.getValue();
                if (nextI < 0 || height <= nextI
                        || nextJ < 0 || width <= nextJ
                        || maze[nextI][nextJ]
                        || visited[nextI][nextJ]) {
                    continue;
                }

                bfs.add(
                        new AbstractMap.SimpleEntry<>(next.getKey() + 1,
                                new AbstractMap.SimpleEntry<>(nextI, nextJ)
                        )
                );
            }
        }
        // out.println(""For i = "" + startI + "", j = "" + startJ + "", max was "" + max);
        return max;
    }

    // https://www.geeksforgeeks.org/fast-io-in-java-in-competitive-programming/
    static class FastReader {
        BufferedReader br;
        StringTokenizer st;

        FastReader(InputStream inputStream) {
            br = new BufferedReader(new
                    InputStreamReader(inputStream));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException  e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        // https://qiita.com/masakinpo/items/5f77f2a879578a85a0bb
        public int[] nextIntArray(int n) {
            int[] a = new int[n];
            for (int i = 0; i < n; i++)
                a[i] = nextInt();
            return a;
        }

        public long[] nextLongArray(int n) {
            long[] a = new long[n];
            for (int i = 0; i < n; i++)
                a[i] = nextLong();
            return a;
        }
    }
}
"
107,"import java.util.Scanner;

/**
 * Longest Path
 */
public class Main {

    public static void main(String[] args) throws Exception {
        try (Scanner sc = new Scanner(System.in)) {
            int N = sc.nextInt();
            int M = sc.nextInt();

            int[] X = new int[M];
            int[] Y = new int[M];
            for (int i = 0; i < M; i++) {
                X[i] = sc.nextInt();
                Y[i] = sc.nextInt();
            }

            long[] dp = new long[N + 1];

            for (int k = 0; k < N; k++) {
                for (int i = 0; i < M; i++) {
                    if (dp[X[i]] == k) {
                        dp[Y[i]] = k + 1;
                    }
                }
            }

            long max = 0;
            for (int i = 1; i <= N; i++) {
                max = Math.max(max, dp[i]);
            }

            System.out.println(max);
        }
    }

}
"
108,"import java.util.*;

public class Main{
	public static void main(Sting[]args){
	Scannner in = new Scanner(System.in);
	int x = in.nextInt();
	System.out.println(Math.pow(x,3));
}
}
"
109,"import java.util.*;

class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int card = sc.nextInt();
        int gate = sc.nextInt();
        int[] l = new int[gate];
        int[] r = new int[gate];
        int ans = 0;

        for(int i = 0;i < gate;i++){
            l[i] = sc.nextInt();
            r[i] = sc.nextInt();
        }
        for(int i = 1;i <= card;i++){
            boolean jud = true;
            for(int j = 0;j < gate;j++){
                if((l[j] > i)||(i > r[j])){
                    jud = false;
                    break;
                }
            }
            if(jud == true)
            ans++;
        }
        System.out.println(ans);

    }
}"
110,"import java.util.*;
import java.util.Map.Entry;

import javax.swing.text.Segment;
import javax.xml.ws.WebEndpoint;

import java.io.*;
import java.lang.reflect.Array;
import java.math.BigInteger;

import static java.lang.Math.*;
import static java.util.Arrays.*;
import static java.util.Collections.*;
 
public class Main //implements Runnable
{
//    static int dx[]={-1,0,1,0};
//    static int dy[]={0,-1,0,1};
	static double s;
	
    public static void main(String[] args)   throws Exception, IOException{        
//        long mod=1000000007;
        Reader sc = new Reader(System.in);
        PrintWriter out=new PrintWriter(System.out);

        int n=sc.nextInt();
        int k=sc.nextInt();
        int a[]=sc.nextIntArray(n);
        int d[]=new int[n];
        HashMap<Integer, Integer> map = new HashMap<>();
        LinkedList<Integer> l=new LinkedList<>();
        long ans=0;
        for (int i = 0; i < d.length; i++) {
        	a[i]%=k;
			if(i>0) {a[i]+=a[i-1];a[i]%=k;}
        	if((i+1)==a[i])ans++;
		}
        
//        map.put(1, 1);
//        l.addFirst(1);
        for (int i = 0,t,md,c,v; i < d.length; i++) {
			t=i%k;
			md=(a[i]-t)%k;
			md+=k;md%=k;
			if(map.containsKey(md)) {
				c=map.get(md);
				ans+=c;
				map.put(md, c+1);
			} else {
				map.put(md, 1);				
			}
			if(l.size()==k-2) {
				v=l.pollLast();
				c=map.get(v);
				map.put(v, c-1);
			} 
			l.addFirst(md);
//			db(t,md,ans);
		}
//        db(a);

        out.println(ans);
     	out.flush();
    }


    static void ret(String ans) {
    	System.out.println(ans);
    	System.exit(0);
    }
    
    static boolean validpos(int x,int y,int r, int c){
        return x<r && 0<=x && y<c && 0<=y;
    }

    static void db(Object... os){
        System.err.println(Arrays.deepToString(os));
    }
}

//
//class P {
//	int x, y, d;
//	P(int  x, int y, int d) {
//	  this.x=x;
//	  this.y=y;
//	  this.d=d;
//	}
//}

class P implements Comparable<P>{
    int a,b;
    P(int a, int b) {
    	this.b=b;
    	this.a=a;
    }

    public int compareTo(P p){
        return -p.a+a;//as
    }
}

class Reader
{ 
    private BufferedReader x;
    private StringTokenizer st;
    
    public Reader(InputStream in)
    {
        x = new BufferedReader(new InputStreamReader(in));
        st = null;
    }
    public String nextString() throws IOException
    {
        while( st==null || !st.hasMoreTokens() )
            st = new StringTokenizer(x.readLine());
        return st.nextToken();
    }
    public int nextInt() throws IOException
    {
        return Integer.parseInt(nextString());
    }
    public int[] nextIntArray(int size) throws IOException{
        int r[] = new int[size];
        for (int i = 0; i < size; i++) {
            r[i] = this.nextInt(); 
        }
        return r;
    }
    public long[] nextLongArray(int size) throws IOException{
        long r[] = new long[size];
        for (int i = 0; i < size; i++) {
            r[i] = this.nextLong(); 
        }
        return r;
    }
    public char[] getCharSet() throws IOException{
        return this.nextString().toCharArray();
    }    
    public long nextLong() throws IOException
    {
        return Long.parseLong(nextString());
    }
    public double nextDouble() throws IOException
    {
        return Double.parseDouble(nextString());
    }
}
"
111,"import java.util.*;		
import java.util.function.Function;
import java.util.stream.Collectors;
import java.io.*;
import java.math.*;
public class Main{
	static public void main(String args[])throws IOException{
		int tt=1;
		StringBuilder sb=new StringBuilder();
		for(int ttt=1;ttt<=tt;ttt++){
			int n=i();
			int[]a=new int[n];
			for(int i=0;i<n;i++){
				a[i]=i();
			}
			ArrayList<Integer> ar=new ArrayList<>();
			int min=0,max=1;
			if(a[0]<a[1]){
				ar.add(a[0]);
				min=1;
				max=0;
			}
			int i=1;
			while(i<n){
				if(min==1){
					while(i+1<n && a[i]<=a[i+1]){
						i++;
					}
					ar.add(a[i]);
					i++;
					max=1;
					min=0;
				}else{
					while(i+1<n && a[i]>=a[i+1]){
						i++;
					}
					ar.add(a[i]);
					i++;
					max=0;
					min=1;
				}
			}
			long curr=1000;
			long stocks=0;
			long maxx=1000L;
			for(i=0;i<ar.size();i++){
				if(i%2==0){
					stocks=stocks+curr/ar.get(i);
					curr=curr%ar.get(i);
				}else{
					curr=curr+stocks*ar.get(i);
					stocks=0;
					maxx=Math.max(curr,maxx);
				}
			}
			pln(maxx+"""");
		}
		System.out.print(sb.toString());
	}
	static InputReader in=new InputReader(System.in);
	static OutputWriter out=new OutputWriter(System.out);
	static ArrayList<ArrayList<Integer>> graph;
	static int mod=1000000007;
	static class Pair{
		int x;
		int y;
		Pair(int x,int y){
			this.x=x;
			this.y=y;
		}
		/*@Override
		public int hashCode() 
		{ 
			final int temp = 14; 
			int ans = 1; 
			ans =x*31+y*13; 
			return (int)ans;
		}
       @Override
        public boolean equals(Object o) 
        { 
            if (this == o) { 
                return true; 
            } 
            if (o == null) { 
                return false; 
            } 
            if (this.getClass() != o.getClass()) { 
                return false; 
            } 
            Pair other = (Pair)o; 
            if (this.x != other.x || this.y!=other.y) { 
                return false; 
            } 
            return true; 
        }*/
	}
	public static long[] sort(long[] a){
		int n=a.length;
		ArrayList<Long> ar=new ArrayList<>();
		for(int i=0;i<a.length;i++){
			ar.add(a[i]);
		}
		Collections.sort(ar);
		for(int i=0;i<n;i++){
			a[i]=ar.get(i);
		}
		return a;
	}
	public static long pow(long a, long b){
        long result=1;
        while(b>0){
            if (b % 2 != 0){
                result=(result*a);
                b--;
            } 
            a=(a*a);
            b /= 2;
        }   
        return result;
    }
	public static long gcd(long a, long b){
        if (a == 0){
            return b;
		}
        return gcd(b%a, a);
    }
	public static long lcm(long a, long b){
		return a*(b/gcd(a,b));
	}
	public static long l(){
		String s=in.String();
		return Long.parseLong(s);
	}
	public static void pln(String value){
		System.out.println(value);
	}
	public static int i(){
		return in.Int();
	}
	public static String s(){
		return in.String();
	}
}
class InputReader 
{
	private InputStream stream;
	private byte[] buf = new byte[1024];
	private int curChar;
	private int numChars;
	private SpaceCharFilter filter;
	public InputReader(InputStream stream) {
		this.stream = stream;
	}
	public int read() {
		if (numChars== -1)
			throw new InputMismatchException();
		if (curChar >= numChars) {
			curChar = 0;
			try {
				numChars = stream.read(buf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (numChars <= 0)
				return -1;
		}
		return buf[curChar++];
	}
	public int Int() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		int res = 0;
		do {
			if (c < '0' || c > '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}
	public String String() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		StringBuilder res = new StringBuilder();
		do {
			res.appendCodePoint(c);
			c = read();
		} while (!isSpaceChar(c));
		return res.toString();
	} 
	public boolean isSpaceChar(int c) {
		if (filter != null)
			return filter.isSpaceChar(c);
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	} 
	public String next() {
		return String();
	} 
	public interface SpaceCharFilter {
		public boolean isSpaceChar(int ch);
	}
}
class OutputWriter {
	private final PrintWriter writer;
	public OutputWriter(OutputStream outputStream) {
		writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
	}
	public OutputWriter(Writer writer) {
		this.writer = new PrintWriter(writer);
	}
	public void print(Object...objects) {
		for (int i = 0; i < objects.length; i++) {
			if (i != 0)
				writer.print(' ');
			writer.print(objects[i]);
		}
	}
	public void printLine(Object...objects) {
		print(objects);
		writer.println();
	}
	public void close() {
		writer.close();
	}
	public void flush() {
		writer.flush();
	}
 }
class IOUtils {
	public static int[] readIntArray(InputReader in, int size) {
		int[] array = new int[size];
		for (int i = 0; i < size; i++)
			array[i] = in.Int();
		return array;
	}
} "
112,"import java.util.*;

public class Main {
	Scanner in = new Scanner(System.in);
	public static void main(String[] args) {
		new Main();
	}
	public Main() {
		new AOJ0565();
	}

	class AOJ0565{
		public AOJ0565() {
			int a = Integer.MAX_VALUE;
			int b = Integer.MAX_VALUE;
			for(int i=0;i<3;i++)a = Math.min(a,in.nextInt());
			for(int i=0;i<2;i++)b = Math.min(b, in.nextInt());
			System.out.println(a+b-50);
		}
	}

}"
113,"import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class Main {

	static int[][] field1,field2;
	static boolean[][][][] dp;
	static int sXL,sXR,sYL,sYR;
	static boolean ans;
	static int[] v1={0,1,0,-1};
	static int[] v2={1,0,-1,0};
	static int w,h;
	public static void main(String[] args) {
		Scanner cin=new Scanner(System.in);
		while(true){

			w=cin.nextInt();
			h=cin.nextInt();
			if(w+h==0){
				return ;
			}
			ans=false;
			field1=new int[h][w];
			field2=new int[h][w];
			dp=new boolean[h][w][h][w];
			for(int i=0;i<h;i++){
				for(int j=0;j<2;j++){
					String s=cin.next();
					int[][] a;
					if(j==0){
						a=field1;
					}
					else{
						a=field2;
					}
					for(int k=0;k<s.length();k++){
						int b=0;
						if(s.charAt(k)=='%'){
							b=1;
						}
						else if(s.charAt(k)=='#'){
							b=-1;
						}
						else if(s.charAt(k)=='L'){
							sXL=i;
							sYL=k;
						}
						else if(s.charAt(k)=='R'){
							sXR=i;
							sYR=k;
						}
						a[i][k]=b;
					}
				}
			}
			Queue<int[]> q=new LinkedList<int[]>();
			q.add(new int[]{sXL,sYL,sXR,sYR});
			while(!q.isEmpty()){
				int[] poll=q.poll();
				int a=poll[0];
				int b=poll[1];
				int c=poll[2];
				int d=poll[3];
				if(dp[a][b][c][d]||ans){
					continue;
				}
				dp[a][b][c][d]=true;
				if(field1[a][b]==1&&field2[c][d]==1){
					ans=true;
					break;
				}
				if(field1[a][b]==1){
					continue;
				}
				if(field2[c][d]==1){
					continue;
				}
				for(int i=0;i<4;i++){
					int aa=a+v1[i];
					int bb=b+v2[i];
					int cc=c+v1[i];
					int dd=d+-v2[i];
//					System.out.println(aa+"" ""+bb+"" ""+cc+"" ""+dd+"" ""+i);
					if(aa<0||aa>=h){
						aa-=v1[i];
					}
					if(bb<0||bb>=w){
						bb-=v2[i];
					}
					if(cc<0||cc>=h){
						cc-=v1[i];
					}
					if(dd<0||dd>=w){
						dd-=-v2[i];
					}
//					System.out.println(aa+"" ""+bb+"" ""+cc+"" ""+dd+"" ""+i);
					if(field1[aa][bb]==-1){
						aa-=v1[i];
						bb-=v2[i];
					}
					if(field2[cc][dd]==-1){
						cc-=v1[i];
						dd-=-v2[i];
					}
					q.add(new int[]{aa,bb,cc,dd});
				}

			}
//			bt(sXL,sYL,sXR,sYR);
			if(ans){
				System.out.println(""Yes"");
			}
			else{
				System.out.println(""No"");
			}
		}
	}
	static void bt(int a,int b,int c,int d){
		if(dp[a][b][c][d]||ans){
			return ;
		}
		dp[a][b][c][d]=true;
		if(field1[a][b]==1&&field2[c][d]==1){
			ans=true;
		}
		if(field1[a][b]==1){
			return;
		}
		if(field2[c][d]==1){
			return;
		}
		for(int i=0;i<4;i++){
			int aa=a+v1[i];
			int bb=b+v2[i];
			int cc=c+v1[i];
			int dd=d+-v2[i];
//			System.out.println(aa+"" ""+bb+"" ""+cc+"" ""+dd+"" ""+i);
			if(aa<0||aa>=h){
				aa-=v1[i];
			}
			if(bb<0||bb>=w){
				bb-=v2[i];
			}
			if(cc<0||cc>=h){
				cc-=v1[i];
			}
			if(dd<0||dd>=w){
				dd-=-v2[i];
			}
//			System.out.println(aa+"" ""+bb+"" ""+cc+"" ""+dd+"" ""+i);
			if(field1[aa][bb]==-1){
				aa-=v1[i];
				bb-=v2[i];
			}
			if(field2[cc][dd]==-1){
				cc-=v1[i];
				dd-=-v2[i];
			}
			bt(aa,bb,cc,dd);
		}
	}
}"
114,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        long h = in.nextLong(), w = in.nextLong();
        int n = in.nextInt();
        Map<String, Integer> map = new HashMap<>();
        int[] dx = {0, 0, 1, 1, 1, 0, -1, -1, -1};
        int[] dy = {0, -1, -1, 0, 1, 1, 1, 0, -1};
        for(int i = 0; i < n; i++) {
            int a = in.nextInt() - 1, b = in.nextInt() - 1;
            for(int k = 0; k < 9; k++) {
                int y = a + dy[k], x = b + dx[k];
                if(x < 1 || w-1 <= x || y < 1 || h-1 <= y) {
                    continue;
                }
                String str = new StringBuilder().append(y).append(' ').append(x).toString();
                Integer val = map.get(str);
                map.put(str, val == null ? 1 : val + 1);
            }
        }
        System.out.println((h-2) * (w-2) - map.size());
        print(1, map);
    }

    public static void print(final int val, Map<String, Integer> map) {
        if(val == 10) return;
        System.out.println(map.keySet().stream()
                .mapToInt(key -> map.get(key))
                .filter(v -> v == val)
                .count());
        print(val + 1, map);
        
    }
}"
115,"public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ
		Scanner sc = new Scanner(System.in);

		int[] numbers = new int[220];
		int num;

		int N = sc.nextInt();
		for (int i=0; i<N; i++) {
			num = sc.nextInt();
			numbers[i] = num;
		}
		sc.close();

		int cnt=0;
		String judge = ""all_even"";
		while(true) {

			for (int i=0; i<N; i++) {
				if (numbers[i]%2!=0) {
					judge = ""has_odd"";
				}
			}
			if(judge==""has_odd"") break;

			for (int i=0; i<N; i++) {
				numbers[i]/=2;
			}

			cnt ++;
		}
		System.out.println(cnt);


	}"
116,"

import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        while (sc.hasNext()) {
            String s = sc.next();
            boolean prevIsDream = false;
            boolean prevIsErase = false;

            while (!s.isEmpty()) {
                if (s.startsWith(""erase"")) {
                    s = s.substring(5);
                    prevIsErase = true;
                    prevIsDream = false;
                } else if (s.startsWith(""dream"")) {
                    s = s.substring(5);
                    prevIsErase = false;
                    prevIsDream = true;
                } else if (s.startsWith(""er"") && prevIsDream) {
                    s = s.substring(2);
                    prevIsErase = false;
                    prevIsDream = false;
                } else if (s.startsWith(""r"") && prevIsErase) {
                    s = s.substring(1);
                    prevIsErase = false;
                    prevIsDream = false;
                } else {
                    break;
                }
            }

            if (s.isEmpty()) {
                System.out.println(""YES"");
            } else {
                System.out.println(""NO"");
            }
        }
    }
}
"
117,"import java.util.*;
import java.io.*;

public class Main {
	
	public static void main (String[] args) {
	   InputReader in = new InputReader(System.in);
	   int n = in.readInt();
	   int arr[] = new int[100000000];
	   for(int i = 0; i<n; i++) {
		   int a = in.readInt();
		   if(a == 0) {
			   arr[a] = 0;
		   }
		   else {
			   arr[a]++; 
			   arr[a-1]++; 
			   arr[a+1]++;
		   }
	   }
	   int max = 0; 
	   for(int i : arr) {
		 max = Math.max(max, i);
	   }
	   System.out.println(max);
	}
}

class InputReader {

	private InputStream stream;
	private byte[] buf = new byte[1024];
	private int curChar;
	private int numChars;
	private SpaceCharFilter filter;

	public InputReader(InputStream stream) {
		this.stream = stream;
	}

	public int read() {
		if (numChars == -1)
			throw new InputMismatchException();
		if (curChar >= numChars) {
			curChar = 0;
			try {
				numChars = stream.read(buf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (numChars <= 0)
				return -1;
		}
		return buf[curChar++];
	}

	public int readInt() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		int res = 0;
		do {
			if (c < '0' || c > '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}

	public String readString() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		StringBuilder res = new StringBuilder();
		do {
			res.appendCodePoint(c);
			c = read();
		} while (!isSpaceChar(c));
		return res.toString();
	}

	public long readLong() {
		int c = read();
		while (isSpaceChar(c)) {
			c = read();
		}
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		long res = 0;
		do {
			if (c < '0' || c > '9') {
				throw new InputMismatchException();
			}
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}
	
	public boolean isSpaceChar(int c) {
		if (filter != null)
			return filter.isSpaceChar(c);
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}

	public String next() {
		return readString();
	}

	public interface SpaceCharFilter {
		public boolean isSpaceChar(int ch);
	}
}
"
118,"import java.io.*;
import java.math.*;
import java.util.*;
import java.lang.*;

public class Main implements Runnable {
    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private SpaceCharFilter filter;
        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1)
                throw new InputMismatchException();

            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }

                if (numChars <= 0)
                    return -1;
            }
            return buf[curChar++];
        }

        public String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        public int nextInt() {
            int c = read();

            while (isSpaceChar(c))
                c = read();

            int sgn = 1;

            if (c == '-') {
                sgn = -1;
                c = read();
            }

            int res = 0;
            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            while (!isSpaceChar(c));

            return res * sgn;
        }

        public long nextLong() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            long res = 0;

            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            while (!isSpaceChar(c));
            return res * sgn;
        }

        public double nextDouble() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            double res = 0;
            while (!isSpaceChar(c) && c != '.') {
                if (c == 'e' || c == 'E')
                    return res * Math.pow(10, nextInt());
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            if (c == '.') {
                c = read();
                double m = 1;
                while (!isSpaceChar(c)) {
                    if (c == 'e' || c == 'E')
                        return res * Math.pow(10, nextInt());
                    if (c < '0' || c > '9')
                        throw new InputMismatchException();
                    m /= 10;
                    res += (c - '0') * m;
                    c = read();
                }
            }
            return res * sgn;
        }

        public String readString() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = read();
            }
            while (!isSpaceChar(c));

            return res.toString();
        }

        public boolean isSpaceChar(int c) {
            if (filter != null)
                return filter.isSpaceChar(c);
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public String next() {
            return readString();
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);
        }
    }

    public static void main(String args[]) throws Exception {
        new Thread(null, new Main(), ""Main"", 1 << 26).start();
    }

     long modPow(long a, long p, long m) {
        if (a == 1) return 1;
        long ans = 1;
        while (p > 0) {
            if (p % 2 == 1) ans = (ans * a) % m;
            a = (a * a) % m;
            p >>= 1;
        }
        return ans;
    }

     long modInv(long a, long m) {
        return modPow(a, m - 2, m);
    }


    long gcd(long a,long b){
        if(b==0)return a;
        return gcd(b,a%b);
    }



    public void run() {
        InputReader sc = new InputReader(System.in);
        // Scanner sc=new Scanner(System.in);
        //  Random sc=new Random();
        PrintWriter out = new PrintWriter(System.out);

        int n=sc.nextInt();
        wantSum=sc.nextInt();
        int a[]=new int[n];
        for (int i = 0; i <n ; i++) {
            a[i]=sc.nextInt();
        }
        dp=new Long[n+1][n+1][25001];
        out.println(f(0,0,0,a)+(wantSum!=0?-1:0));
        out.close();

    }

    int wantSum;
    Long dp[][][];
    long f(int i,int eis,int sum,int a[]){
        if(dp[i][eis][sum]!=null)return dp[i][eis][sum];
        if(i==a.length){
            if(eis*wantSum==sum)return dp[i][eis][sum]=1L;
            else return dp[i][eis][sum]=0L;
        }
        return dp[i][eis][sum]=f(i+1,eis,sum,a)+f(i+1,eis+1,sum+a[i],a);
    }





}"
119,"public class Main {
    private static java.util.Scanner scanner = new java.util.Scanner(System.in);

    public static void main(String[] args) {
        int n = scanner.nextInt(), q = scanner.nextInt();
        long ans = 0;
        String s = scanner.next();
        char[] t = new char[q], d = new char[q];
        for (int i = 0; i < q; i++) {
            t[i] = scanner.next().charAt(0);
            d[i] = scanner.next().charAt(0);
        }


        {
            boolean b = false;
            int a = 0;
            for (int i = q - 1; i >= 0; i--) {
                if (t[i] == s.charAt(a) && d[i] == 'L') {
                    ans++;
                    a++;
                    b = false;
                }
                if (a != 0 && t[i] == s.charAt(a - 1) && d[i] == 'R') {
                    b = true;
                }
            }
            if (b) ans--;
        }

        {
            boolean b = false;
            int a = n - 1;
            for (int i = q - 1; i >= 0; i--) {
                if (t[i] == s.charAt(a) && d[i] == 'R') {
                    ans++;
                    a--;
                    b = false;
                }
                if (a != n - 1 && t[i] == s.charAt(a + 1) && d[i] == 'L') {
                    b = true;
                }
            }
            if (b) ans--;
        }
        System.out.println(n - ans);
    }
}"
120,"import java.util.*;
 
public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int a = sc.nextInt();
    int b = sc.nextInt();
    int sum = 1;
    
    for(int i; b < sum; i++) {
      sum += a - 1;
    }
    System.out.println(i-1);
  }
}"
121,"import java.util.*;
public class Main {
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		
		 String S = sc.next();
      	 int N=S.length();
         x = s.substring(0,N/2);
      	 y = s.substring(N/2+1,N);
        if(x.equals(y)){
        System.out.println(""Yes"");}
      	else{
        System.out.println(""No"");}
	}
}"
122,"import org.apache.lucene.search.spell.JaroWinklerDistance;
import org.apache.lucene.search.spell.LevensteinDistance;
import java.util.Scanner;

public class Main {

    public static void main(String argv[]){
        Scanner sc = new Scanner(System.in);
        String S = sc.next();
        String T = sc.next();
        System.out.println( getSimilarScoreByLevenshteinDistance(S, T)+S.length()-T.length() );

        


    }

    
    private static int getSimilarScoreByLevenshteinDistance(String s1, String s2){

        
        LevensteinDistance dis =  new LevensteinDistance();
        return (dis.getDistance(s1, s2)*S.length());
    }

    
}
"
123,"import java.io.IOException;
import java.util.Scanner;

public class Main {
	static int time = 0;

	public static void main(String[] args) throws IOException {

		Scanner scan = new Scanner(System.in);
		// Scanner scan = new Scanner(new
		// File(""D:\\UserArea\\J0124567\\Downloads\\ALDS1_6_A-in9.txt""));

		int n = scan.nextInt();
		Sns sns = new Sns(n);

		int m = scan.nextInt();
		for (int i = 0; i < m; i++)
			sns.addRel(scan.nextInt(), scan.nextInt());

		int q = scan.nextInt();
		for (int i = 0; i < q; i++)
			if (sns.isFriends(scan.nextInt(), scan.nextInt()))
				System.out.println(""yes"");
			else
				System.out.println(""no"");

		scan.close();
		System.exit(0);
	}
}

class Sns {

	int[] leader;

	public Sns(int n) {
		leader = new int[n];
		for (int i = 0; i < n; i++)
			leader[i] = i;
	}

	public boolean isFriends(int s, int t) {
		if (top(s) == top(t))
			return true;
		else
			return false;
	}

	private int top(int s) {
		if (leader[s] == s)
			return s;
		else
			return top(leader[s]);
	}

	public void addRel(int s, int t) {
		if (isFriends(s, t))
			return;
		leader[top(s)] = top(t);
	}

}"
124,"
import java.util.*;
import java.io.*;

public class Main{
    static final Reader sc = new Reader();
    static final PrintWriter out = new PrintWriter(System.out,false);

    public static void main(String[] args) throws Exception {
    	while(true){
    		int n = sc.nextInt();
    		int m = sc.nextInt();
    		if(n==0 && m==0){
    			break;
    		}
            int left = 1000000000;
            int right = 0;
    		int[] s = new int[m];
    		int[] d = new int[m];
            boolean[] judge = new boolean[n+1];
            int ans = 1;
            judge[1] = true;
            HashMap<Integer,Integer> time = new HashMap<Integer,Integer>();
    		for(int i=0;i<m;i++){
    			int t = sc.nextInt();
    			left = Math.min(left,t);
                right = Math.max(right,t);
                time.put(t,i);
                s[i] = sc.nextInt();
    			d[i] = sc.nextInt();
    		}
            for(int i=left;i<=right;i++){
                if(time.containsKey(i)){
                    int x = time.get(i);
                    if(judge[s[x]] && !judge[d[x]]){
                        judge[d[x]] = true;
                        ans++;
                    }
                }
            }
            out.println(ans);
            out.flush();
    	}
        sc.close();
        out.close();
    }

    static void trace(Object... o) { System.out.println(Arrays.deepToString(o));}
}

class Reader {

    private final InputStream in;
    private final byte[] buf = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    public Reader() { this(System.in);}
    public Reader(InputStream source) { this.in = source;}

    private boolean hasNextByte() {
        if (ptr < buflen) return true;
        ptr = 0;
        try{
            buflen = in.read(buf);
        }catch (IOException e) {e.printStackTrace();}
        if (buflen <= 0) return false;
        return true;
    }

    private int readByte() { if (hasNextByte()) return buf[ptr++]; else return -1;}

    private boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}

    private void skip() { while(hasNextByte() && !isPrintableChar(buf[ptr])) ptr++;}

    public boolean hasNext() {skip(); return hasNextByte();}

    public String next() {
        if (!hasNext()) throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while (isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    public long nextLong() {
        if (!hasNext()) throw new NoSuchElementException();
        boolean minus = false;
        long num = readByte();

        if(num == '-'){
            num = 0;
            minus = true;
        }else if (num < '0' || '9' < num){
            throw new NumberFormatException();
        }else{
            num -= '0';
        }

        while(true){
            int b = readByte();
            if('0' <= b && b <= '9')
                num = num * 10 + (b - '0');
            else if(b == -1 || !isPrintableChar(b))
                return minus ? -num : num;
            else
                throw new NoSuchElementException();
        }
    }

    public int nextInt() {
        long num = nextLong();
        if (num < Integer.MIN_VALUE || Integer.MAX_VALUE < num)
            throw new NumberFormatException();
        return (int)num;
    }

    public double nextDouble() {
        return Double.parseDouble(next());
    }

    public char nextChar() {
        if (!hasNext()) throw new NoSuchElementException();
        return (char)readByte();
    }

    public String nextLine() {
        while (hasNextByte() && (buf[ptr] == '\n' || buf[ptr] == '\r')) ptr++;
        if (!hasNextByte()) throw new NoSuchElementException();

        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while (b != '\n' && b != '\r') {
            sb.appendCodePoint(b);
            b = readByte();
        }

        return sb.toString();
    }

    public int[] nextIntArray(int n) {
        int[] res = new int[n];
        for (int i=0; i<n; i++) res[i] = nextInt();
        return res;
    }

    public char[] nextCharArray(int n) {
        char[] res = new char[n];
        for (int i=0; i<n; i++) res[i] = nextChar();
        return res;
    }

    public void close() {try{ in.close();}catch(IOException e){ e.printStackTrace();}};
}"
125,"import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		char[] s = scan.nextLine().toCharArray();
		char[] t = scan.nextLine().toCharArray();
		Map<Character, List<Integer>> map = new HashMap<>();

		int lastIndex = -1;
		int loopCnt = 0;
		boolean notExists = false;
		boolean tmpFlg = false;
		List<Integer> tmpL = new ArrayList<>();

		// 最大値を超えるような条件は与えられない
//		double max = Math.pow(10, 100);

		// 文字と要素番号をマップに格納
		for (int i = 0; i < s.length; i++) {
			tmpL = map.get(s[i]);
			if (tmpL == null) {
				tmpL = new ArrayList<>();
				map.put(s[i], tmpL);
			}
			tmpL.add(i);
		}

		// 文字が存在するかチェック
		for (char c : t) {
			if (!map.containsKey(c)) {
				notExists = false;
				break;
			}
		}
		if (notExists) {
			System.out.println(-1);
		}

		// 文字列tの文字を前方から順次比較
		for (char c : t) {
			tmpL = map.get(c);
			for (int i : tmpL) {
				if (i > lastIndex) {
					lastIndex = i;
					tmpFlg = true;
					break;
				}
			}
			if (!tmpFlg) {
				loopCnt++;
				lastIndex = tmpL.get(0);
			}
			tmpFlg = false;
		}
		System.out.println((s.length * loopCnt) + lastIndex + 1);
	}
}
"
126,"import java.io.IOException;
import java.io.InputStream;
import java.util.Arrays;
import java.util.NoSuchElementException;
import java.util.Random;
import java.util.Scanner;

class UnionFind{
	int Parent[];
	UnionFind(int n){//Initialize by -1
		Parent=new int[n];
		Arrays.fill(Parent, -1);
	}
	int root(int A) {//In which tree is A?
		if(Parent[A]<0)return A;
		return Parent[A]=root(Parent[A]);
	}
	int size(int A) {//size of tree which is include A
		return -Parent[root(A)];
	}
	boolean connect(int A,int B) {//Connect A and B
		A=root(A);
		B=root(B);
		if(A==B) return false;
		if(size(A)<size(B)) {int C=0;C=B;B=A;A=C;}//SWAP
		Parent[A]+=Parent[B];
		Parent[B]=A;
		return true;
	}
}

public class Main {
	static FastScanner scan=new FastScanner();
	static Scanner scanner=new Scanner(System.in);
	static Random rand=new Random();
	static long mod=1000000007;
	static double eps=0.0000000001;
	static int big=Integer.MAX_VALUE;
	static long modlcm(long a,long b) {return a*b*modint(gcd(a,b),mod);}
	static long gcd (long a, long b) {return b>0?gcd(b,a%b):a;}
	static long lcm (long a, long b) {return a*b/gcd(a,b);}
	static int max(int a,int b) {return a>b?a:b;}
	static int min(int a,int b) {return a<b?a:b;}
	static long lmax(long a,long b) {return Math.max(a, b);}
	static long lmin(long a,long b) {return Math.min(a, b);}
	static long factorial(int i) {return i==1?1:i*factorial(i-1);}
	public static void main(String[] args) throws IOException {
		int a=scan.nextInt();
		int b=scan.nextInt();
		int c=scan.nextInt();
		System.out.println(a*b/2);
		}
	}
	static int lower_bound(int a[],int key) {
		int right=a.length;
		int left=0;
		while(right-left>1) {
			int mid=(right+left)/2;
			if(a[mid]<key) {
				left=mid;
			}
			else {
				right=mid;
			}
		}
		return left;
	}
	static int upper_bound(int a[],int key) {
		int right=a.length;
		int left=0;
		while(right-left>1) {
			int mid=(right+left)/2;
			if(a[mid]<=key) {
				left=mid;
			}
			else {
				right=mid;
			}
		}
		return left;
	}
	static boolean isPrime (long n) {
		if (n==2) return true;
		if (n<2 || n%2==0) return false;
		double d = Math.sqrt(n);
		for (int i=3; i<=d; i+=2)if(n%i==0){return false;}
		return true;
	}
	static int upper_division(int a,int b) {
		if(a%b==0) {
			return a/b;
		}
		else {
			return a/b+1;
		}
	}
	static long lupper_division(long a,long b) {
		if(a%b==0) {
			return a/b;
		}
		else {
			return a/b+1;
		}
	}
	static int[] setArray(int a) {
		int b[]=new int[a];
		for(int i=0;i<a;i++) {
			b[i]=scan.nextInt();
		}
		return b;
	}
	static long[] lsetArray(int a) {
		long b[]=new long[a];
		for(int i=0;i<a;i++) {
			b[i]=scan.nextLong();
		}
		return b;
	}
	static String reverce(String str) {
		String strr="""";
		for(int i=str.length()-1;i>=0;i--) {
			strr+=str.charAt(i);
		}
		return strr;
	}
	public static void printArray(int[] que) {
		for(int i=0;i<que.length-1;i++) {
			System.out.print(que[i]+"" "");
		}
		System.out.println(que[que.length-1]);
	}
	public static int[][] doublesort(int[][]a) {
		Arrays.sort(a,(x,y)->Integer.compare(x[0],y[0]));
		return a;
	}
	public static long[][] ldoublesort(long[][]a) {
		Arrays.sort(a,(x,y)->Long.compare(x[0],y[0]));
		return a;
	}
	static long modpow(long x,long n,long mo) {
		long sum=1;
		while(n>0) {
			if((n&1)==1) {
				sum=sum*x%mo;
			}
			x=x*x%mo;
			n>>=1;
		}
		return sum;
	}
	public static char[] revch(char ch[]) {
		char ret[]=new char[ch.length];
		for(int i=ch.length-1,j=0;i>=0;i--,j++) {
			ret[j]=ch[i];
		}
		return ret;
	}
	public static int[] revint(int ch[]) {
		int ret[]=new int[ch.length];
		for(int i=ch.length-1,j=0;i>=0;i--,j++) {
			ret[j]=ch[i];
		}
		return ret;
	}
	public static void warshall_floyd(int v[][],int n) {
		for(int k=0;k<n;k++)
			for(int i=0;i<n;i++)
				for(int j=0;j<n;j++)
					v[i][j]=min(v[i][j],v[i][k]+v[k][j]);
	}
	public static long modint(long a,long m) {
		long b=m,u=1,v=0;
		while(b!=0) {
			long t=a/b;
			a-=t*b;
			long x=a;
			a=b;
			b=x;

			u-=t*v;
			x=u;
			u=v;
			v=x;
		}
		u%=m;
		if(u<0)u+=m;
		return u;
	}
}
class FastScanner {
	private final InputStream in = System.in;
	private final byte[] buffer = new byte[1024];
	private int ptr = 0;
	private int buflen = 0;
	private boolean hasNextByte() {
		if (ptr < buflen) {
			return true;
		}else{
			ptr = 0;
			try {
				buflen = in.read(buffer);
			} catch (IOException e) {
				e.printStackTrace();
			}
			if (buflen <= 0) {
				return false;
			}
		}
		return true;
	}
	private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}
	private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}
	public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}
	public String next() {
		if (!hasNext()) throw new NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		int b = readByte();
		while(isPrintableChar(b)) {
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	public long nextLong() {
		if (!hasNext()) throw new NoSuchElementException();
		long n = 0;
		boolean minus = false;
		int b = readByte();
		if (b == '-') {
			minus = true;
			b = readByte();
		}
		if (b < '0' || '9' < b) {
			throw new NumberFormatException();
		}
		while(true){
			if ('0' <= b && b <= '9') {
				n *= 10;
				n += b - '0';
			}else if(b == -1 || !isPrintableChar(b)){
				return minus ? -n : n;
			}else{
				throw new NumberFormatException();
			}
			b = readByte();
		}
	}
	public int nextInt() {
		long nl = nextLong();
		if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
		return (int) nl;
	}
	public double nextDouble() { return Double.parseDouble(next());}
	public char nextchar() {
		try { return (char)System.in.read(); } catch(Exception e) {
			throw new RuntimeException(e);
		}
	}
}
"
127,"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
public class Main{
	public static void main(String[] args) throws IOException{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		String line = br.readLine();
		int n = Integer.parseInt(line);
		for(int i = 1; i <= n; i++){
			int x = i;
			if( x % 3 == 0 ){
				sb.append("" "").append(i);
			}else{
				do{
					if( x % 10 == 3 ){
						sb.append("" "").append(i);
                                                x = 0;
					}
					x /= 10;
				}while( x != 0 );
			}
		}
		sb.append(""\n"");
		System.out.print(sb);
	}
}"
128,"import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Scanner;

class Main {
	public static void main(String[] args) throws IOException {
		new Main().run();
	}

	HashMap<List<Long>, Long> f = new HashMap<>();
	int N;
	long W;
	long[] w, v;

	void run() {
		Scanner sc = new Scanner(System.in);
		N = sc.nextInt();
		W = sc.nextLong();
		w = new long[N];
		v = new long[N];
		for (int i = 0; i < N; ++i) {
			w[i] = sc.nextLong();
			v[i] = sc.nextLong();
		}
		System.out.println(func(W, 0));
	}

	long func(long ww, int num) {
		if (ww < 0)
			return -Long.MAX_VALUE / 16;
		if (num == N)
			return 0;
		if (f.containsKey(Arrays.asList(ww, num)))
			return f.get(Arrays.asList(ww, num));
		long ret = Math.max(func(ww - w[num], num + 1) + v[num], func(ww, num + 1));
		f.put(Arrays.asList(ww, (long) num), ret);
		return ret;
	}

	void tr(Object... objects) {
		System.out.println(Arrays.deepToString(objects));
	}
}"
129,"import java.util.Scanner;
class Main
{
	public static void main(String args[])
	{
        Scanner s=new Scanner(System.in);
        s.close();

        int a=s.nextInt();
        int b=s.nextInt();

        if(a==1 && b==2){
            System.out.println(3);
        }
        if(a==1 && b==3){
            System.out.println(2);
        }
        if(a==2 && b==1){
            System.out.println(3);
        }
        if(a==2 && b==3){
            System.out.println(1);
        }
        if(a==3 && b==1){
            System.out.println(2);
        }
        if(a==3 && b==2){
            System.out.println(1);
        }
    }
}"
130,"import java.io.*;
import java.math.*;
import java.util.*;
import java.lang.*;

// import java.text.DecimalFormat; 
// import java.text.DecimalFormatSymbols; 
 
 
// Warning: Printing unwanted or ill-formatted data to output will cause the test cases to fail
 
public class Main {
    
    public static void main(String args[] ) throws Exception {
        /* Sample code to perform I/O:
         * Use either of these methods for input
 
        //BufferedReader
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String name = br.readLine();                // Reading input from STDIN
        System.out.println(""Hi, "" + name + ""."");    // Writing output to STDOUT
 
        //Scanner
        Scanner s = new Scanner(System.in);
        String name = s.nextLine();                 // Reading input from STDIN
        System.out.println(""Hi, "" + name + ""."");    // Writing output to STDOUT
        
        for Round off
         DecimalFormat deciFormat = new DecimalFormat(); 
        deciFormat.setMaximumFractionDigits(9); 
        */
 
        // Write your code here
        StringBuffer str = new StringBuffer();
        PrintWriter pw=new PrintWriter(System.out);
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        int T =Integer.parseInt(br.readLine());
        int ans=0;
        if(T%1000!=0)
            ans = 1000- T%1000;
        str.append(ans);
        pw.print(str.toString());
        pw.close();
    }
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
    
}"
131,"import java.util.*;

public class Main {

    public static void main(String args[]) {

        // 入力
        Scanner sc = new Scanner(System.in);
        int n = Integer.parseInt(sc.next());
        List<Integer> a = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            a.add(Integer.parseInt(sc.next()));
        }
        sc.close();

        // 主処理
        a.sort(Collections.reverseOrder());
        int base = a.get(0);
        int center = (int) Math.ceil(base / 2.0);

        List<Integer> diff = new ArrayList<>();
        for (int i = 1; i < a.size(); i++) {
            diff.add(Math.abs(center - a.get(i)));
        }

        int min = diff.stream().mapToInt(i -> i).min().orElse(0);
        int index = diff.indexOf(min) + 1;

        String result = base + "" "" + a.get(index);

        // 出力
        System.out.println(result);
    }
}
"
132,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main{

	public static void main(String[] args) throws IOException {

		BufferedReader input = new BufferedReader(new InputStreamReader(System.in));

		// ?????£?????????????????????????????????????????????
		//String shuffle_strings = """";

		while (true) {

			// ??????????????°??¢??????????????????????????\???
			String alphabet_cards = input.readLine();

			if (alphabet_cards.equals(""_"")) {

				break;
			}

			String shuffle_num = input.readLine();

			// ?????£?????????????????°
			int shuffle_times = Integer.parseInt(shuffle_num);

			StringBuilder shuffle_before_cards = new StringBuilder(alphabet_cards);

			// ?????£?????????????????°????????????????????£?????????
			for (int cards_spot = 0; cards_spot < shuffle_times; cards_spot++) {

				//??????????????§????????£??????????????????
				String shuffle_spot = input.readLine();

				int shuffle_cards = Integer.parseInt(shuffle_spot);

				// ??\??????????????¢???????????????????????????????????????shuffle_cards???????????§?????????
				String extracted_cards = shuffle_before_cards.substring(0, shuffle_cards);

				//???????????\???????????????????????\????????????alphabet_cards??????extracted_cards????¶????
				shuffle_before_cards.delete(0, shuffle_cards);

				//???????????\??????????????????,????°????extracted_cards????¶????
				shuffle_before_cards = shuffle_before_cards.append(extracted_cards);

			}

			System.out.println(shuffle_before_cards.toString());

		}

	}//StringBuilder ?????° = new StringBuilder(????????????????????°);
}"
133,"import java.util.*;

public class Main {

    public static void main(String[] args) {
        // write your code here
        Scanner sc = new Scanner(System.in);

        String s = sc.next();

        String ans = ""YES"";

        while (s.length() > 0) {
            boolean isOK = false;

            if (s.endsWith(""dreamer"")) {
               isOK = true;
               s = s.substring(0, s.length() - 7);
            }
            if (s.endsWith(""dream"")) {
                isOK = true;
                s = s.substring(0, s.length() - 5);
            }
            if (s.endsWith(""eraser"")) {
                s = s.substring(0, s.length() - 6);
                isOK = true;
            }
            if (s.endsWith(""erase"")) {
                s = s.substring(0, s.length() - 5);
                isOK = true;
            }

            if (!isOK) {
                ans = ""NO"";
                break;
            }
        }

        System.out.println(ans);
    }
}"
134,"import java.util.Arrays;
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		try (Scanner scanner = new Scanner(System.in)) {
			int a = scanner.nextInt();
			int b = scanner.nextInt();
			int q = scanner.nextInt();
			scanner.nextLine();
			long[] s = new long[a];
			for (int i = 0; i < a; i++) {
				s[i] = scanner.nextLong();
				scanner.nextLine();
			}
			long[] t = new long[b];
			for (int i = 0; i < b; i++) {
				t[i] = scanner.nextLong();
				scanner.nextLine();
			}
			long[] result = new long[q];
			for (int i = 0; i < q; i++) {
				long x = scanner.nextLong();
				result[i] = nearest(x, s, t);
			}
			Arrays.stream(result).forEach(System.out::println);
		}
	}

	private static long nearest(long x, long[] s, long[] t) {
		long s1 = 0L, s2 = 0L;
		if (x <= s[0]) {
			s1 = s2 = s[0];
		} else if (x >= s[s.length - 1]) {
			s1 = s2 = s[s.length - 1];
		} else {
			for (int i = 1; i < s.length; i++) {
				if ((x >= s[i - 1]) && (x <= s[i])) {
					s1 = s[i - 1];
					s2 = s[i];
				}
			}
		}
		long t1 = 0L, t2 = 0L;
		if (x <= t[0]) {
			t1 = t2 = t[0];
		} else if (x >= t[t.length - 1]) {
			t1 = t2 = t[t.length - 1];
		} else {
			for (int i = 1; i < t.length; i++) {
				if ((x >= t[i - 1]) && (x <= t[i])) {
					t1 = t[i - 1];
					t2 = t[i];
				}
			}
		}
		return min(distance(x, s1, t1), distance(x, s1, t2), distance(x, s2, t1), distance(x, s2, t2));
	}

	private static long distance(long x, long s1, long t1) {
		return Math.abs(s1 - t1) + min(Math.abs(s1 - x), Math.abs(t1 - x));
	}

	private static long min(long... x) {
		long min = Long.MAX_VALUE;
		for (long number : x) {
			min = Math.min(min, number);
		}
		return min;
	}
}"
135,"
import java.util.Scanner;

/**
 * @author yoshizaki
 *
 */
public class Main {
 
    public static void main(String[] args) {
        Scanner scanner= new Scanner(System.in);
        double target = scanner.nextDouble();
    //    long start = System.currentTimeMillis(); 
        long ans = calc(target);
    //    long end = System.currentTimeMillis(); 
    //    long time = end - start;
        System.out.println(ans );
    //    System.out.println(time +""ms"");
    }
    
    /**
     * @param target
     * @return
     */
    public static  long calc(double target){
        long targetNum = (long)target;
        long root = 0;
        long divNum = 0;
        long ansNum = 0;
        long sumNum = 0;
        root = (long) Math.sqrt(target);
        for (long i = root; i > 0; i--) 
        {
            if (targetNum % i == 0 ) {
                divNum = i;
                break;
            }
        }
        ansNum = targetNum / divNum;
        sumNum = ansNum + divNum -2;
        return sumNum;
    }
}"
136,"import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		int i = 0;
		Scanner scan;
		while(true) {
			i++;
			scan = new Scanner(System.in);
			int a = Integer.parseInt(scan.next());
			if(a == 0) {
				break;
			}
			System.out.println(""Case "" + i + "": "" + a);
		}
		scan.close();
	}
}
"
137,"import java.util.*;
public class Main {
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		int num = sc.nextInt();
		int k = sc.nextInt();
		String s = sc.next();
        String[] line = new String[num];
        line = s.split("""");
		//System.out.println(line.length);
        String former = line[0];
        int check = 0;
        int count = 1;
        int count2 = 0;
        int index = 0;
        int sum = 0;
        int max = 0;
        int temp = 0;
        List<Integer> counter = new ArrayList<Integer>();
        List<Integer> counter2 = new ArrayList<Integer>();
        if(line[0].equals(""0"")) check = 1;
        if(line.length == 1) {
            counter.add(count);
            counter2.add(count);
        }
        for(int i=1; i<num; i++){
          if(line[i].equals(former)){
            count++;
          }
          else{
            check++;
            count++;
            if(line[i].equals(""0"")) former = ""0"";
            else former = ""1"";
          }
          if(check == 2) count2++;
          if(check == 3){
            counter.add(count-1);
            counter2.add(count-1-temp);
            count = count2+1;
            temp = count2;
            count2 = 0;
            check = 1;
          }
          if(i+1 >= num) {
            counter.add(count);
            counter2.add(count-temp);
            break;
          }
        }
        temp = 0;
        //System.out.println(""size=""+counter.size());
        while(true){
          temp = index;
          //System.out.println(""index=""+index+"", value=""+counter.get(index));
          sum += counter.get(index);
          index++;
          for(int j=1; j<k; j++){
             //System.out.println(""index=""+index+"", value=""+counter2.get(index));
             sum += counter2.get(index);
             index++;
          }
          //sum -= k-1;
          if(max < sum) max = sum;
          sum = 0;
          index = temp + 1;
          if(index+k > counter.size()) break;
        }
        System.out.println(max);
	}
}"
138,"import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

class Main {
	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		int n = scanner.nextInt();
		int[] A = new int[n];
		int[] B = new int[n];
		int max = 0;

		for (int i = 0; i < n; i++) {
			A[i] = scanner.nextInt();
			if(max < A[i]){
				max = A[i] + 1;
			}
		}
		scanner.close();
		
		countingSort(A, B, n ,max);
		
		System.out.print(B[0]);
		for (int i = 1; i < n - 1; i++) {
			System.out.print("" "" + B[i]);
		}
		System.out.println("" "" + B[n - 1]);

	}

	//????±?????????????????´????????????????(A[])??¨??????????????????????????????????´?????????????(B[])??¨??????????????°???????´??????????????????°(n)????????°??????????????????
	static void countingSort(int[] A, int[] B, int n , int max) {
		
		int[] c = new int[max];
		for (int j = 0; j < n; j++) {
			c[A[j]]++;
		}
		for (int i = 1; i < max; i++) {
			c[i] = c[i] + c[i - 1];
		}
		for (int j = A.length - 1; j >= 0; j--) {
			c[A[j]]--;
			B[c[A[j]]] = A[j];
		}
	}
}"
139,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.StringTokenizer;


public class Grid {

	public static void main(String[] args) throws IOException {
		BufferedReader br= new BufferedReader(new InputStreamReader(System.in));
		PrintWriter pw =new PrintWriter(System.out);
		StringTokenizer st= new StringTokenizer(br.readLine());
		int H=Integer.parseInt(st.nextToken());
		int W=Integer.parseInt(st.nextToken());
		char[][] grid= new char[H][W];
		long[][] solution= new long[H][W];
		for (int i = 0; i < grid.length; i++) {
			String s=br.readLine();
			for (int j = 0; j < grid[i].length; j++) {
				grid[i][j]=s.charAt(j);
				grid[i][j]='.';
			}
		}
		for (int i = solution.length-1; i > -1; i--) {
			for (int j = solution[i].length-1; j > -1; j--) {
				if(grid[i][j]=='#')
				{
					solution[i][j]=0;
				}
				else if(i+1>=solution.length && j+1>=solution[i].length)
				{
					solution[i][j]=1;
				}
				else if(i+1>=solution.length)
				{
					solution[i][j]=solution[i][j+1];
				}
				else if(j+1>=solution[i].length)
				{
					solution[i][j]=solution[i+1][j];
				}
				else
				{
					solution[i][j]=solution[i][j+1]+solution[i+1][j];
				}
					
					
			}
		}
		pw.println(solution[0][0]%(1000000000+7));
		pw.close();
	}
}
"
140,"import java.util.ArrayList;
import java.util.Collections;
import java.util.Scanner;

public class Main {
	public static void main(String[] a) {
		// TODO ?????????????????????????????????????????????
		ArrayList<Integer> list = new ArrayList<Integer>();
		for(int i =0; i<10; i++){
			Scanner scan = new Scanner(System.in);
			String stra = scan.next();
			int str = Integer.parseInt(stra);
			 list.add(str);
		}
		Collections.sort(list);


		System.out.println(""1????????????????±±?????????"" + list.get(0));
		System.out.println(""2????????????????±±?????????"" + list.get(1));
		System.out.println(""3????????????????±±?????????"" + list.get(2));

	}

}"
141,"import java.util.Scanner;

class Main {
    private static void solve() {
        final Scanner scanner = new Scanner(System.in);
        final char[][] keymap =
                { null,
                  { ''', ',', '.', '!', '?' },
                  { 'a', 'b', 'c', 'A', 'B', 'C' },
                  { 'd', 'e', 'f', 'D', 'E', 'F' },
                  { 'g', 'h', 'i', 'G', 'H', 'I' },
                  { 'j', 'k', 'l', 'J', 'K', 'L' },
                  { 'm', 'n', 'o', 'M', 'N', 'O' },
                  { 'p', 'q', 'r', 's',  'P', 'Q', 'R', 'S' },
                  { 't', 'u', 'v', 'T', 'U', 'V' },
                  { 'w', 'x', 'y', 'z', 'W', 'X', 'Y' , 'Z' }
                 };
        while (scanner.hasNext()) {
            final char[] line = scanner.next().toCharArray();
            int index = 0;
            while (index != line.length) {
                final char digit = line[index];
                int counter = 1;
                while (++index < line.length && line[index] == digit) {
                    counter++;
                }
                if (keymap[digit - '0'] == null) {
                    for (int i = 1; i < counter; i++) {
                        System.out.print(' ');
                    }
                } else {
                    final int length = keymap[digit - '0'].length;
                    System.out.print(keymap[digit - '0'][(counter - 1) % length]);
                }
            }
            System.out.println();
        }
    }

    public static void main(String... args) {
        solve();
    }
}"
142,"//package com.regular.arc065;


import java.util.Scanner;

public class Main {

    static class UnionFind{
        int count =0;
        int []id;
        int []dataCnt;
        public void init(int n){
            id=new int[n];
            dataCnt = new int[n];
            count=n;

            for(int i=0;i<n;i++){
                id[i]=i;
                dataCnt[i]=1;
            }

        }
        public int getDataCnt(int n){
            return dataCnt[id[n]];
        }
        public int getCount(){return count;}
        public int find(int p){return id[p];}
        public boolean isConnected(int p,int q){
            return (find(p)==find(q));
        }
        public void union(int p,int q){
            int pID = find(p);
            int qID = find(q);
            if(pID==qID) return;
            int tmp=0;
            for(int i=0;i<id.length;i++) {
                if (id[i] == pID) id[i] = qID;
                if (id[i]==qID) tmp++;
            }
            dataCnt[qID]=tmp;
            count--;
        }

    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int K = sc.nextInt();
        int L = sc.nextInt();

        UnionFind road = new UnionFind();
        road.init(N);
        UnionFind rail = new UnionFind();
        rail.init(N);

        for(int i=0;i<K;i++){
            int a = sc.nextInt();
            int b = sc.nextInt();
            road.union(a-1,b-1);
        }


        for(int i=0;i<L;i++){
            int a = sc.nextInt();
            int b = sc.nextInt();
            rail.union(a-1,b-1);
        }


        for (int i=0;i<N;i++){
            int tmp = 0;
            for(int j=0;j<N;j++){
                if(road.isConnected(i,j)&&rail.isConnected(i,j)){
                    tmp++;
                }
            }
            if(i!=N-1)
                System.out.print(tmp+"" "");
            else
                System.out.println(tmp);
        }


        sc.close();

    }

}
"
143,"import java.util.*;

public class Main {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc = new Scanner(System.in);
		String S = sc.next();
		S = new StringBuilder(S).reverse().toString();
		String dream = ""maerd"";
		String dreamer = ""remaerd"";
		String erase = ""esare"";
		String eraser = ""resare"";
		boolean flag = false;
		while(true) {
			if(S.isEmpty()) {
				flag = true;
				break;
			}
			if(S.indexOf(dream) == 0) {
				S = S.replaceFirst(dream, """");
				continue;
			} else if(S.indexOf(dreamer) == 0) {
				S = S.replaceFirst(dreamer, """");
				continue;
			} else if(S.indexOf(erase) == 0) {
				S = S.replaceFirst(erase, """");
				continue;
			} else if(S.indexOf(eraser) == 0) {
				S = S.replaceFirst(eraser, """");
				continue;
			}
			break;
		}
		if(flag) System.out.println(""YES"");
		else System.out.println(""NO"");
	}
	
	// print
	static void print(String s) {
		System.out.println(s);
	}
	
	// union find lib
	// usage:
	// 最初にinitを呼ぶ
	// root: 直接は呼ばないで
	// unite: まとめる
	// same: グループ判定
	static void init(int par[], int N) {
		for(int i=0; i<N; i++) {
			par[i] = i;
		}
	}
	
	static int root(int x, int [] par) {
		if(par[x] == x) {
			return x;
		} else {
			return (par[x] = root(par[x], par));
		}
	}
	
	static boolean same(int x, int y, int[] par) {
		return root(x, par) == root(y, par);
	}
	
	static void unite(int x, int y, int[] par) {
		x = root(x, par);
		y = root(y, par);
		if(x == y) return;
		par[x] = y;
	}
	
	// end union find lib
	
	// number lib
	
	static long lcm(long a, long b) {
		return a*(b/gcd(a, b));
	}
	
	static long gcd(long a, long b) {
		long ta = Math.max(a, b);
		long tb = Math.min(a, b);
		long tmp;
		while((tmp = ta%tb) != 0) {
			ta = tb;
			tb = tmp;
		}
		return tb;
	}
	
	static long modcomb(long n, long k, long mod) {
		if(k==1) {
			return n;
		}
		
		long ans = 1;
		for(long i=n; i>=n-k+1; i--) {
			ans = (ans * i)%mod;
		}
		for(long i=k; 0<i; i--) {
			ans = (ans * modpow(i, mod-2, mod)) % mod;
		}
		return ans;
	}
	
	static long modpow(long a, long b, long mod) {
		if(b==0) return 1;
		if(b%2==0) {
			long d = modpow(a, b/2, mod);
			return (d*d)%mod;
		} else {
			return (a*modpow(a, b-1, mod))%mod;
		}
	}
	
	static int disit(long a, long d) {
		int count = 0;
		while(a!=0) {
			a = a/d;
			count++;
		}
		return count;
	}
	
	// end number lib
}"
144,"class LevelA{
  public static main(String args[]){
  	int A=Integer.parseInt(args[0]);
  	int B=Integer.parseInt(args[1]);
  	System.out.println(A*B)
	}
}"
145,"import java.util.Scanner;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        
        int X = scanner.nextInt();
        double i = 0;
        int count = 0;
        for(i = 100; i <= X; i * 1.01){
            count += 1;
        }

        System.out.println(count);
    }
}"
146,"import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.lang.reflect.Array;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Map.Entry;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;

public class Main {
	private static void solve() {
		int n = ni();
		int len = ns().length();
		long[][] dp = new long[n + 2][n + 2]; // [i][j] = i types, j length
		dp[0][0] = 1;
		long mod = 1000000007l;
		for (int i = 1; i <= n; i++) {
			dp[i][0] = dp[i - 1][0] + dp[i - 1][1];
			dp[i][0] %= mod;
			for (int j = 1; j <= n; j++) {
				dp[i][j] = dp[i - 1][j - 1] * 2 + dp[i - 1][j + 1];
				dp[i][j] %= mod;
			}
		}
		long ans = dp[n][len];
		// ans /= 2^len
		for (int i = 0; i < len; i++) {
			if (ans % 2 == 1)
				ans += mod;
			ans /= 2;
		}
		out(ans);
	}

	static int min(int a, int b) {
		return a < b ? a : b;
	}

	static long min(long a, long b) {
		return a < b ? a : b;
	}

	static <A extends Comparable<? super A>> A min(A a, A b) {
		return a.compareTo(b) < 0 ? a : b;
	}

	static int max(int a, int b) {
		return a > b ? a : b;
	}

	static long max(long a, long b) {
		return a > b ? a : b;
	}

	static <A extends Comparable<? super A>> A max(A a, A b) {
		return a.compareTo(b) > 0 ? a : b;
	}

	static int clamp(int a, int min, int max) {
		return a < min ? min : a > max ? max : a;
	}

	static long clamp(long a, long min, long max) {
		return a < min ? min : a > max ? max : a;
	}

	static int abs(int a) {
		return a < 0 ? -a : a;
	}

	static long abs(long a) {
		return a < 0 ? -a : a;
	}

	static <A extends Comparable<? super A>> A clamp(A a, A min, A max) {
		return a.compareTo(min) < 0 ? min : a.compareTo(max) > 0 ? max : a;
	}

	static void out(String val) {
		IO.out(val);
	}

	static void out(Object val) {
		IO.out(String.valueOf(val));
	}

	static void out(int val) {
		IO.out(String.valueOf(val));
	}

	static void out(long val) {
		IO.out(String.valueOf(val));
	}

	static void out(char val) {
		IO.out(String.valueOf(val));
	}

	static void out(double val) {
		IO.out(Double.isFinite(val) ? BigDecimal.valueOf(val).toPlainString() : String.valueOf(val));
	}

	static void out(boolean val) {
		IO.out(val ? ""true"" : ""false"");
	}

	static void outn(String val) {
		IO.outn(val);
	}

	static void outn(Object val) {
		IO.outn(String.valueOf(val));
	}

	static void outn(int val) {
		IO.outn(String.valueOf(val));
	}

	static void outn(long val) {
		IO.outn(String.valueOf(val));
	}

	static void outn(char val) {
		IO.outn(String.valueOf(val));
	}

	static void outn(double val) {
		IO.outn(Double.isFinite(val) ? BigDecimal.valueOf(val).toPlainString() : String.valueOf(val));
	}

	static void outn(boolean val) {
		IO.outn(val ? ""true"" : ""false"");
	}

	static void kil(String val) {
		IO.out(val);
		IO.flush();
		System.exit(0);
	}

	static void kil(Object val) {
		IO.out(String.valueOf(val));
		IO.flush();
		System.exit(0);
	}

	static void kil(int val) {
		IO.out(String.valueOf(val));
		IO.flush();
		System.exit(0);
	}

	static void kil(long val) {
		IO.out(String.valueOf(val));
		IO.flush();
		System.exit(0);
	}

	static void kil(char val) {
		IO.out(String.valueOf(val));
		IO.flush();
		System.exit(0);
	}

	static void kil(double val) {
		IO.out(Double.isFinite(val) ? BigDecimal.valueOf(val).toPlainString() : String.valueOf(val));
		IO.flush();
		System.exit(0);
	}

	static void kil(boolean val) {
		IO.out(val ? ""true"" : ""false"");
		IO.flush();
		System.exit(0);
	}

	static String ns() {
		return IO.next();
	}

	static int ni() {
		return IO.nextInt();
	}

	static long nl() {
		return IO.nextLong();
	}

	static double nd() {
		return IO.nextDouble();
	}

	static char nc() {
		return IO.nextChar();
	}

	static String[] nss(int n) {
		String[] as = new String[n];
		for (int i = 0; i < n; i++) {
			as[i] = IO.next();
		}
		return as;
	}

	static int[] nis(int n) {
		int[] as = new int[n];
		for (int i = 0; i < n; i++) {
			as[i] = IO.nextInt();
		}
		return as;
	}

	static long[] nls(int n) {
		long[] as = new long[n];
		for (int i = 0; i < n; i++) {
			as[i] = IO.nextLong();
		}
		return as;
	}

	static double[] nds(int n) {
		double[] as = new double[n];
		for (int i = 0; i < n; i++) {
			as[i] = IO.nextDouble();
		}
		return as;
	}

	static char[] ncs(int n) {
		char[] as = new char[n];
		for (int i = 0; i < n; i++) {
			as[i] = IO.nextChar();
		}
		return as;
	}

	static String[][] nss2(int n, int m) {
		String[][] as = new String[n][m];
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				as[i][j] = IO.next();
			}
		}
		return as;
	}

	static int[][] nis2(int n, int m) {
		int[][] as = new int[n][m];
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				as[i][j] = IO.nextInt();
			}
		}
		return as;
	}

	static long[][] nls2(int n, int m) {
		long[][] as = new long[n][m];
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				as[i][j] = IO.nextLong();
			}
		}
		return as;
	}

	static double[][] nds2(int n, int m) {
		double[][] as = new double[n][m];
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				as[i][j] = IO.nextDouble();
			}
		}
		return as;
	}

	static char[][] ncs2(int n, int m) {
		char[][] as = new char[n][m];
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				as[i][j] = IO.nextChar();
			}
		}
		return as;
	}

	static int parseInt(String val) {
		return Integer.parseInt(val);
	}

	static long parseLong(String val) {
		return Long.parseLong(val);
	}

	public static void main(String[] args) {
		try {
			solve();
			IO.flush();
		} catch (NumberFormatException e) {
			e.printStackTrace();
		} catch (OutOfMemoryError e) {
			e.printStackTrace(); // this will be detected as RE
		}
	}
}

final class IO {
	private static final InputStream in = System.in;
	private static final PrintWriter out = new PrintWriter(System.out, false);
	private static final byte[] buffer = new byte[1024];
	private static int ptr = 0;
	private static int len = 0;

	private static boolean hasNextByte() {
		if (ptr < len)
			return true;
		ptr = 0;
		try {
			len = in.read(buffer);
		} catch (IOException e) {
			e.printStackTrace();
		}
		return len > 0;
	}

	private static int readByte() {
		if (hasNextByte())
			return buffer[ptr++];
		else
			return -1;
	}

	static boolean hasNext() {
		byte c;
		while (hasNextByte() && ((c = buffer[ptr]) < '!' || c > '~'))
			ptr++;
		return hasNextByte();
	}

	static String next() {
		if (!hasNext())
			throw new NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		int b = readByte();
		while (b >= '!' && b <= '~') {
			sb.append((char) b);
			b = readByte();
		}
		return sb.toString();
	}

	static char nextChar() {
		if (!hasNext())
			throw new NoSuchElementException();
		return (char) readByte();
	}

	static long nextLong() {
		if (!hasNext())
			throw new NoSuchElementException();
		long n = 0;
		int sign = 1;
		int b = readByte();
		if (b == '-') {
			sign = -1;
			b = readByte();
		}
		if (b < '0' || '9' < b)
			throw new NumberFormatException();
		while (true) {
			if ('0' <= b && b <= '9')
				n = n * 10 + b - '0';
			else if (b == -1 || b < '!' || b > '~')
				return n * sign;
			else
				throw new NumberFormatException();
			b = readByte();
		}
	}

	static int nextInt() {
		if (!hasNext())
			throw new NoSuchElementException();
		int n = 0;
		int sign = 1;
		int b = readByte();
		if (b == '-') {
			sign = -1;
			b = readByte();
		}
		if (b < '0' || '9' < b)
			throw new NumberFormatException();
		while (true) {
			if ('0' <= b && b <= '9')
				n = n * 10 + b - '0';
			else if (b == -1 || b < '!' || b > '~')
				return n * sign;
			else
				throw new NumberFormatException();
			b = readByte();
		}
	}

	static double nextDouble() {
		return Double.parseDouble(next());
	}

	static void out(String val) {
		out.println(val);
	}

	static void outn(String val) {
		out.print(val);
	}

	static void flush() {
		out.flush();
	}
}

// TODO: paste library here

class MS<A> {
	private TreeMap<A, Long> tm;

	MS() {
		tm = new TreeMap<A, Long>();
	}

	MS(Comparator<A> comp) {
		tm = new TreeMap<A, Long>(comp);
	}

	void add(A a, long num) {
		if (tm.containsKey(a))
			tm.put(a, tm.get(a) + num);
		else
			tm.put(a, num);
	}

	void add(A a) {
		add(a, 1);
	}

	long remove(A a, long num) {
		if (tm.containsKey(a)) {
			long n = tm.get(a);
			if (n <= num) {
				tm.remove(a);
				return n;
			}
			tm.put(a, n - num);
			return num;
		}
		return 0;
	}

	boolean remove(A a) {
		return remove(a, 1) == 1;
	}

	long removeAll(A a) {
		return remove(a, Long.MAX_VALUE);
	}

	long num(A a) {
		return tm.containsKey(a) ? tm.get(a) : 0;
	}

	int size() {
		return tm.size();
	}

	A floor(A a) {
		return tm.floorKey(a);
	}

	UP<A, Long> floorNum(A a) {
		Entry<A, Long> e = tm.floorEntry(a);
		return e == null ? null : UP.make(e.getKey(), e.getValue());
	}

	A ceil(A a) {
		return tm.ceilingKey(a);
	}

	UP<A, Long> ceilNum(A a) {
		Entry<A, Long> e = tm.ceilingEntry(a);
		return e == null ? null : UP.make(e.getKey(), e.getValue());
	}

	void clear() {
		tm.clear();
	}

	Set<A> keySet() {
		return tm.keySet();
	}

	Collection<Long> valueSet() {
		return tm.values();
	}

	Set<Entry<A, Long>> entrySet() {
		return tm.entrySet();
	}

	public String toString() {
		return tm.toString();
	}
}

class WUF<A, W> { // Weighted Union Find Tree
	private int[] parents;
	private int[] ranks;
	private ArrayList<A> roots;
	private ArrayList<W> weights;
	private F.XXX<A, A, A> merger;
	private F.XXX<W, W, W> add;
	private F.XX<W, W> inv;
	private W e;

	WUF(int n, F.IX<A> maker, F.XXX<A, A, A> merger, F.XXX<W, W, W> add, F.XX<W, W> inv, W e) {
		this.merger = merger;
		this.add = add;
		this.inv = inv;
		this.e = e;
		parents = new int[n];
		ranks = new int[n];
		roots = U.make(n, maker);
		weights = U.make(n, i -> e);

		for (int i = 0; i < n; i++) {
			parents[i] = i;
		}
	}

	int index(int i) {
		int p = parents[i];
		if (i == p) {
			return i;
		}
		int r = index(p);
		weights.set(i, add.f(weights.get(i), weights.get(p)));
		return parents[i] = r;
	}

	boolean same(int i, int j) {
		return index(i) == index(j);
	}

	A root(int i) {
		return roots.get(index(i));
	}

	W weight(int i) {
		index(i);
		return weights.get(i);
	}

	W diff(int i, int j) {
		return sub(weight(j), weight(i));
	}

	void unite(int i, int j, W w) {
		w = add(w, weight(i));
		w = sub(w, weight(j));
		i = index(i);
		j = index(j);
		if (i == j)
			return;
		A r = merger.f(root(i), root(j));
		if (ranks[i] < ranks[j]) {
			i ^= j;
			j ^= i;
			i ^= j;
			w = inv.f(w);
		}
		parents[j] = i;
		roots.set(i, r);
		if (ranks[i] == ranks[j])
			ranks[i]++;
		weights.set(j, w);
	}

	private W add(W a, W b) {
		return a == e ? b : b == e ? a : add.f(a, b);
	}

	private W sub(W a, W b) {
		return b == e ? a : add(a, inv.f(b));
	}
}

class PQ<A> { // Priority Queue
	static class E { // Entry
		private Object a;
		private int index;

		private E(Object a, int index) {
			this.a = a;
			this.index = index;
		}
	}

	private int n;
	private E[] as;
	private Comparator<A> comp;

	PQ(Comparator<A> comp) {
		this.comp = comp;
		as = new E[64];
		n = 1;
	}

	E add(A a) {
		E res = addEntry(a);
		fixUp(n - 1);
		return res;
	}

	A pop() {
		int max = n - 1;
		if (max == 0)
			return null;
		if (max == 1) {
			return removeLast();
		}

		E tmp = as[1];
		as[1] = as[max];
		as[max] = tmp;
		as[1].index = 1;
		as[max].index = max;

		A res = removeLast();
		fixDown(1);
		return res;
	}

	@SuppressWarnings(""unchecked"")
	A get(E e) {
		return (A) e.a;
	}

	void remove(E e) {
		int k = ((E) e).index;
		int max = n - 1;
		if (k == max) {
			removeLast();
			return;
		}

		E tmp = as[k];
		as[k] = as[max];
		as[max] = tmp;
		as[k].index = k;
		as[max].index = max;

		removeLast();
		if (!fixDown(k))
			fixUp(k);
	}

	void update(E e, A a) {
		int k = e.index;
		as[k].a = a;
		if (!fixDown(k))
			fixUp(k);
	}

	boolean isEmpty() {
		return n == 1;
	}

	@SuppressWarnings(""unchecked"")
	private A removeLast() {
		n--;
		E res = as[n];
		res.index = -1;
		as[n] = null;
		return (A) res.a;
	}

	@SuppressWarnings(""unchecked"")
	private boolean fixUp(int k) {
		boolean res = false;
		while (k > 1) {
			int nk = k >> 1;
			if (comp.compare((A) as[k].a, (A) as[nk].a) < 0) {
				E tmp = as[k];
				as[k] = as[nk];
				as[nk] = tmp;
				as[k].index = k;
				as[nk].index = nk;
				k = nk;
				res = true;
				continue;
			}
			break;
		}
		return res;
	}

	@SuppressWarnings(""unchecked"")
	private boolean fixDown(int k) {
		boolean res = false;
		while (k << 1 < n) {
			A a = (A) as[k].a;
			A l = (A) as[k << 1].a;
			if (k << 1 == n - 1) {
				if (comp.compare(a, l) <= 0)
					break;
				res = true;
				E tmp = as[k];
				as[k] = as[k << 1];
				as[k << 1] = tmp;
				as[k].index = k;
				as[k << 1].index = k << 1;
				break;
			}
			A r = (A) as[k << 1 | 1].a;
			if (comp.compare(a, l) <= 0 && comp.compare(a, r) <= 0)
				break;
			res = true;
			if (comp.compare(l, r) < 0) {
				int nk = k << 1;
				E tmp = as[k];
				as[k] = as[nk];
				as[nk] = tmp;
				as[k].index = k;
				as[nk].index = nk;
				k = nk;
			} else {
				int nk = k << 1 | 1;
				E tmp = as[k];
				as[k] = as[nk];
				as[nk] = tmp;
				as[k].index = k;
				as[nk].index = nk;
				k = nk;
			}
		}
		return res;
	}

	private E addEntry(A a) {
		if (n == as.length)
			as = U.doubleSize(as);
		return as[n] = new E(a, n++);
	}

	@SuppressWarnings(""unchecked"")
	public String toString() {
		if (n == 1)
			return ""[]"";
		String s = null;
		for (int i = 1; i < n; i++) {
			A a = (A) as[i].a;
			if (s == null)
				s = ""["" + a;
			else
				s += "", "" + a;
		}
		return s + ""]"";
	}
}

class G<V, E> { // Graph
	private int vSize;
	private Object[] vs; // V
	private int numEdges;
	private Object[] allEdges; // UT<Integer, Integer, E>
	private Object[] esFrom; // EdgeSet
	private Object[] esTo; // EdgeSet
	private Integer[] ints;

	private class EdgeSet {
//		HashMap<Integer, E> map;
		Integer[] is;
		Object[] es;
		int size;

		EdgeSet() {
			is = new Integer[2];
			es = new Object[2];
			size = 0;
		}

//		@SuppressWarnings(""unchecked"")
		void add(Integer i, E e) {
//			if (size > 1600000) {
//				map.put(i, e);
//				size++;
//				return;
//			}
			if (size == is.length) {
				is = Arrays.copyOf(is, size << 1);
				es = Arrays.copyOf(es, size << 1);
			}
			is[size] = i;
			es[size] = e;
//			if (++size > 1600000) {
//				map = new HashMap<Integer, E>();
//				for (int j = 0; j < size; j++) {
//					map.put(is[j], (E) es[j]);
//				}
//				is = null;
//				es = null;
//			}
		}

		@SuppressWarnings(""unchecked"")
		void iter(F.IXV<E> f) {
//			if (map == null)
			for (int i = 0; i < size; i++)
				f.f(is[i], (E) es[i]);
//			else
//				for (Entry<Integer, E> e : map.entrySet())
//					f.f(e.getKey(), e.getValue());
		}
	}

	G() {
		vs = new Object[64];
		allEdges = new Object[64];
		esFrom = new Object[64];
		esTo = new Object[64];
		ints = new Integer[64];
		vSize = 0;
		numEdges = 0;
	}

	@SuppressWarnings(""unchecked"")
	V getV(int i) {
		return i < 0 || i >= vs.length ? null : (V) vs[i];
	}

	@SuppressWarnings(""unchecked"")
	ArrayList<V> getSortedVs() {
		ArrayList<V> res = new ArrayList<V>();
		for (int i = 0; i < vs.length; i++) {
			if (vs[i] != null)
				res.add((V) vs[i]);
		}
		return res;
	}

	void addV(int i, V v) {
		if (getV(i) != null)
			throw new RuntimeException(""duplicate vtx: "" + i);
		while (vs.length <= i) {
			vs = U.doubleSize(vs);
			ints = U.doubleSize(ints);
			esFrom = U.doubleSize(esFrom);
			esTo = U.doubleSize(esTo);
		}
		vSize = U.max(vSize, i + 1);
		vs[i] = v;
		ints[i] = Integer.valueOf(i);
		esFrom[i] = new EdgeSet();
		esTo[i] = new EdgeSet();
	}

	void setV(int i, V v) {
		if (getV(i) == null)
			throw new RuntimeException(""no such vtx: "" + i);
		vs[i] = v;
	}

	@SuppressWarnings(""unchecked"")
	void addE(int from, int to, E e) {
		((EdgeSet) esFrom[from]).add(ints[to], e);
		((EdgeSet) esTo[to]).add(ints[from], e);
		if (numEdges == allEdges.length) {
			allEdges = U.doubleSize(allEdges);
		}
		allEdges[numEdges++] = UT.make(from, to, e);
	}

	void addUE(int i, int j, E e) {
		addE(i, j, e);
		addE(j, i, e);
	}

	<State> void dfs(int firstIdx, State firstS, F.XXXXX<State, Integer, Integer, E, State> nextState,
			F.XXXV<State, Integer, ArrayList<Integer>> visit) {
		ArrayDeque<UP<Object, Integer>> deque = new ArrayDeque<UP<Object, Integer>>();
		search(firstIdx, firstS, nextState, visit, deque::push, deque::pop, deque::isEmpty);
	}

	<State> void bfs(int firstIdx, State firstS, F.XXXXX<State, Integer, Integer, E, State> nextState,
			F.XXXV<State, Integer, ArrayList<Integer>> visit) {
		ArrayDeque<UP<Object, Integer>> deque = new ArrayDeque<UP<Object, Integer>>();
		search(firstIdx, firstS, nextState, visit, deque::addLast, deque::pollFirst, deque::isEmpty);
	}

	@SuppressWarnings(""unchecked"")
	ArrayList<UT<Integer, Integer, E>> getEs() {
		ArrayList<UT<Integer, Integer, E>> res = new ArrayList<UT<Integer, Integer, E>>();
		for (int i = 0; i < numEdges; i++) {
			res.add((UT<Integer, Integer, E>) allEdges[i]);
		}
		return res;
	}

	/**
	 * !!多重辺があるとバグる!!
	 * !!多重辺があるとバグる!!
	 * !!多重辺があるとバグる!!
	 */
	ArrayList<UP<Long, Integer>> dijkstraL(int from, F.XL<E> getWeight) {
		return dijkstra(from, e -> getWeight.f(e), (a, b) -> a + b, Long::compare, 0l, Long.MAX_VALUE);
	}

	/**
	 * !!多重辺があるとバグる!!
	 * !!多重辺があるとバグる!!
	 * !!多重辺があるとバグる!!
	 */
	@SuppressWarnings(""unchecked"")
	<A> ArrayList<UP<A, Integer>> dijkstra(int from, F.XX<E, A> getWeight, F.XXX<A, A, A> add, Comparator<A> comp,
			A zero, A inf) {
		int n = vSize;
		ArrayList<UP<A, Integer>> res = U.make(n, i -> getV(i) == null ? null : UP.make(i == from ? zero : inf, -1));
		PQ<UP<Integer, A>> q = new PQ<UP<Integer, A>>((i, j) -> comp.compare(i.b, j.b));

		PQ.E[] qes = new PQ.E[n];
		ArrayList<UP<Integer, A>> ups = new ArrayList<UP<Integer, A>>();
		for (int i = 0; i < n; i++) {
			ups.add(UP.make(i, inf));
		}

		boolean[] fixed = new boolean[n];
		ups.get(from).b = zero;
		qes[from] = q.add(ups.get(from));

		while (!q.isEmpty()) {
			UP<Integer, A> up = q.pop();
			Integer i = up.a;
			if (fixed[i])
				continue;
			fixed[i] = true;
			A dist = up.b;
			if (dist == inf)
				break;
			((EdgeSet) esFrom[i]).iter((j, e) -> {
				if (fixed[j])
					return;
				UP<A, Integer> resj = res.get(j);
				A newDist = add.f(dist, getWeight.f(e));
				if (comp.compare(resj.a, newDist) > 0) {
					resj.a = newDist;
					resj.b = i;

					q.add(UP.make(j, newDist));

//					UP<Integer, A> upj = ups.get(j);
//					upj.b = newDist;
//					if (qes[j] == null)
//						qes[j] = q.add(upj);
//					else
//						q.update(qes[j], upj);
				}
			});
		}
		return res;
	}

	@SuppressWarnings(""unchecked"")
	private <State> void search(int firstIdx, State firstS, F.XXXXX<State, Integer, Integer, E, State> nextState,
			F.XXXV<State, Integer, ArrayList<Integer>> visit, F.XV<UP<Object, Integer>> push,
			F.VX<UP<Object, Integer>> pop, F.VX<Boolean> isEmpty) {
		boolean[] visited = new boolean[vSize];
		ArrayList<Integer> movedTo = new ArrayList<Integer>();
		push.f(UP.make(firstS, firstIdx));
		visited[firstIdx] = true;
		while (!isEmpty.f()) {
			UP<Object, Integer> si = pop.f();
			State s = (State) si.a;
			Integer i = si.b;
			movedTo.clear();
			((EdgeSet) esFrom[i]).iter((j, e) -> {
				if (visited[j])
					return;
				State ns = nextState.f(s, i, j, e);
				if (ns != null) {
					movedTo.add(j);
					push.f(P.make(ns, j));
					visited[j] = true;
				}
			});
			visit.f(s, i, movedTo);
		}
	}
}

class UP<A, B> { // Unordered Pair
	A a;
	B b;

	UP(A a, B b) {
		this.a = a;
		this.b = b;
	}

	static <A, B> UP<A, B> make(A a, B b) {
		return new UP<A, B>(a, b);
	}

	public boolean equals(Object o) {
		if (o == this)
			return true;
		if (!(o instanceof UP))
			return false;
		UP<?, ?> p = (UP<?, ?>) o;
		boolean aok = a == null ? p.a == null : a.equals(p.a);
		boolean bok = b == null ? p.b == null : b.equals(p.b);
		return aok && bok;
	}

	public String toString() {
		return ""("" + a.toString() + "", "" + b.toString() + "")"";
	}
}

class P<A extends Comparable<? super A>, B extends Comparable<? super B>> extends UP<A, B>
		implements Comparable<P<A, B>> { // Pair
	P(A a, B b) {
		super(a, b);
	}

	static <A extends Comparable<? super A>, B extends Comparable<? super B>> P<A, B> make(A a, B b) {
		return new P<A, B>(a, b);
	}

	public int compareTo(P<A, B> o) {
		int sa = a.compareTo(o.a);
		int sb = b.compareTo(o.b);
		return sa != 0 ? sa : sb;
	}
}

class PI implements Comparable<PI> { // Pair int
	int a;
	int b;

	PI(int a, int b) {
		this.a = a;
		this.b = b;
	}

	static PI make(int a, int b) {
		return new PI(a, b);
	}

	public boolean equals(Object o) {
		if (o == this)
			return true;
		if (!(o instanceof PI))
			return false;
		PI p = (PI) o;
		return a == p.a && b == p.b;
	}

	public int compareTo(PI o) {
		int sa = a - o.a;
		int sb = b - o.b;
		return sa > 0 ? 1 : sa < 0 ? -1 : sb > 0 ? 1 : sb < 0 ? -1 : 0;
	}

	public String toString() {
		return ""("" + a + "", "" + b + "")"";
	}
}

class PL implements Comparable<PL> { // Pair long
	long a;
	long b;

	PL(long a, long b) {
		this.a = a;
		this.b = b;
	}

	static PL make(long a, long b) {
		return new PL(a, b);
	}

	public boolean equals(Object o) {
		if (o == this)
			return true;
		if (!(o instanceof PL))
			return false;
		PL p = (PL) o;
		return a == p.a && b == p.b;
	}

	public int compareTo(PL o) {
		long sa = a - o.a;
		long sb = b - o.b;
		return sa > 0 ? 1 : sa < 0 ? -1 : sb > 0 ? 1 : sb < 0 ? -1 : 0;
	}

	public String toString() {
		return ""("" + a + "", "" + b + "")"";
	}
}

class UT<A, B, C> { // Unordered Tuple
	A a;
	B b;
	C c;

	UT(A a, B b, C c) {
		this.a = a;
		this.b = b;
		this.c = c;
	}

	static <A, B, C> UT<A, B, C> make(A a, B b, C c) {
		return new UT<A, B, C>(a, b, c);
	}

	public boolean equals(Object o) {
		if (o == this)
			return true;
		if (!(o instanceof UT))
			return false;
		UT<?, ?, ?> t = (UT<?, ?, ?>) o;
		boolean aok = a == null ? t.a == null : a.equals(t.a);
		boolean bok = b == null ? t.b == null : b.equals(t.b);
		boolean cok = c == null ? t.c == null : c.equals(t.c);
		return aok && bok && cok;
	}

	public String toString() {
		return ""("" + a.toString() + "", "" + b.toString() + "", "" + c.toString() + "")"";
	}
}

class T<A extends Comparable<? super A>, B extends Comparable<? super B>, C extends Comparable<? super C>>
		extends UT<A, B, C> implements Comparable<T<A, B, C>> { // Tuple
	T(A a, B b, C c) {
		super(a, b, c);
	}

	static <A extends Comparable<? super A>, B extends Comparable<? super B>, C extends Comparable<? super C>> T<A, B, C> make(
			A a, B b, C c) {
		return new T<A, B, C>(a, b, c);
	}

	public int compareTo(T<A, B, C> o) {
		int sa = a.compareTo(o.a);
		int sb = b.compareTo(o.b);
		int sc = c.compareTo(o.c);
		return sa != 0 ? sa : sb != 0 ? sb : sc;
	}
}

class TI implements Comparable<TI> { // Tuple int
	int a;
	int b;
	int c;

	TI(int a, int b, int c) {
		this.a = a;
		this.b = b;
		this.c = c;
	}

	static TI make(int a, int b, int c) {
		return new TI(a, b, c);
	}

	TL toLong() {
		return TL.make(a, b, c);
	}

	public boolean equals(Object o) {
		if (o == this)
			return true;
		if (!(o instanceof TI))
			return false;
		TI t = (TI) o;
		return a == t.a && b == t.b && c == t.c;
	}

	public int compareTo(TI o) {
		int sa = a - o.a;
		int sb = b - o.b;
		int sc = c - o.c;
		return sa > 0 ? 1 : sa < 0 ? -1 : sb > 0 ? 1 : sb < 0 ? -1 : sc > 0 ? 1 : sc < 0 ? -1 : 0;
	}

	public String toString() {
		return ""("" + a + "", "" + b + "", "" + c + "")"";
	}
}

class TL implements Comparable<TL> { // Tuple long
	long a;
	long b;
	long c;

	TL(long a, long b, long c) {
		this.a = a;
		this.b = b;
		this.c = c;
	}

	static TL make(long a, long b, long c) {
		return new TL(a, b, c);
	}

	TI toInt() {
		return TI.make((int) a, (int) b, (int) c);
	}

	public boolean equals(Object o) {
		if (o == this)
			return true;
		if (!(o instanceof TL))
			return false;
		TL t = (TL) o;
		return a == t.a && b == t.b && c == t.c;
	}

	public int compareTo(TL o) {
		long sa = a - o.a;
		long sb = b - o.b;
		long sc = c - o.c;
		return sa > 0 ? 1 : sa < 0 ? -1 : sb > 0 ? 1 : sb < 0 ? -1 : sc > 0 ? 1 : sc < 0 ? -1 : 0;
	}

	public String toString() {
		return ""("" + a + "", "" + b + "", "" + c + "")"";
	}
}

final class U { // Utilities
	private U() {
	}

	static <A> ArrayList<A> make(int n, F.IX<A> maker) {
		ArrayList<A> res = new ArrayList<A>();
		for (int i = 0; i < n; i++)
			res.add(maker.f(i));
		return res;
	}

	static boolean[] makeB(int n, F.IB maker) {
		boolean[] res = new boolean[n];
		for (int i = 0; i < n; i++)
			res[i] = maker.f(i);
		return res;
	}

	static int[] makeI(int n, F.II maker) {
		int[] res = new int[n];
		for (int i = 0; i < n; i++)
			res[i] = maker.f(i);
		return res;
	}

	static long[] makeL(int n, F.IL maker) {
		long[] res = new long[n];
		for (int i = 0; i < n; i++)
			res[i] = maker.f(i);
		return res;
	}

	static <A> A[] makeX(int n, F.IX<A> maker, A[] as) {
		A[] res = Arrays.copyOf(as, n);
		for (int i = 0; i < n; i++)
			res[i] = maker.f(i);
		return res;
	}

	static <A> ArrayList<A> filter(ArrayList<A> as, F.XB<A> pred) {
		ArrayList<A> res = new ArrayList<A>();
		for (A a : as)
			if (pred.f(a))
				res.add(a);
		return res;
	}

	static <A> int count(ArrayList<A> as, F.XB<A> pred) {
		int res = 0;
		for (A a : as)
			if (pred.f(a))
				res++;
		return res;
	}

	static <A> ArrayList<A> concat(ArrayList<A> as, ArrayList<A> bs) {
		ArrayList<A> res = new ArrayList<A>();
		res.addAll(as);
		res.addAll(bs);
		return res;
	}

	static <A> boolean any(ArrayList<A> as, F.XB<A> pred) {
		for (A a : as)
			if (pred.f(a))
				return true;
		return false;
	}

	static <A> boolean all(ArrayList<A> as, F.XB<A> pred) {
		for (A a : as)
			if (!pred.f(a))
				return false;
		return true;
	}

	static <A> ArrayList<A> flatten(ArrayList<ArrayList<A>> ass) {
		ArrayList<A> res = new ArrayList<A>();
		for (ArrayList<A> as : ass)
			res.addAll(as);
		return res;
	}

	static <A, B> B foldl(ArrayList<A> as, F.XXX<B, A, B> f, B e) {
		B res = e;
		for (A a : as)
			res = f.f(res, a);
		return res;
	}

	static <A, B> B foldr(ArrayList<A> as, F.XXX<A, B, B> f, B e) {
		B res = e;
		for (int i = as.size() - 1; i >= 0; i--)
			res = f.f(as.get(i), res);
		return res;
	}

	static <A> ArrayList<A> reverse(ArrayList<A> as) {
		int size = as.size();
		return make(size, i -> as.get(size - 1 - i));
	}

	static boolean[] reverse(boolean[] as) {
		int size = as.length;
		return makeB(size, i -> as[size - 1 - i]);
	}

	static int[] reverse(int[] as) {
		int size = as.length;
		return makeI(size, i -> as[size - 1 - i]);
	}

	static long[] reverse(long[] as) {
		int size = as.length;
		return makeL(size, i -> as[size - 1 - i]);
	}

	static <A> A[] reverse(A[] as) {
		int size = as.length;
		return makeX(size, i -> as[size - 1 - i], as);
	}

	static <A extends Comparable<? super A>> UP<TreeMap<A, Integer>, ArrayList<A>> compress(ArrayList<A> as) {
		TreeSet<A> set = new TreeSet<A>(as);
		TreeMap<A, Integer> map = new TreeMap<A, Integer>();
		ArrayList<A> imap = new ArrayList<A>();
		int i = 0;
		for (A a : set) {
			map.put(a, i++);
			imap.add(a);
		}
		return UP.make(map, imap);
	}

	static <A, B> ArrayList<B> map(ArrayList<A> as, F.XX<A, B> f) {
		return make(as.size(), (i) -> f.f(as.get(i)));
	}

	static <A, B> ArrayList<B> mapi(ArrayList<A> as, F.XIX<A, B> f) {
		return make(as.size(), (i) -> f.f(as.get(i), i));
	}

	static <A, B> ArrayList<UP<A, B>> zip(ArrayList<A> as, ArrayList<B> bs) {
		return make(min(as.size(), bs.size()), (i) -> UP.make(as.get(i), bs.get(i)));
	}

	static int min(int a, int b) {
		return a < b ? a : b;
	}

	static long min(long a, long b) {
		return a < b ? a : b;
	}

	static <A extends Comparable<? super A>> A min(A a, A b) {
		return a.compareTo(b) < 0 ? a : b;
	}

	static int max(int a, int b) {
		return a > b ? a : b;
	}

	static long max(long a, long b) {
		return a > b ? a : b;
	}

	static <A extends Comparable<? super A>> A max(A a, A b) {
		return a.compareTo(b) > 0 ? a : b;
	}

	static int clamp(int a, int min, int max) {
		return a < min ? min : a > max ? max : a;
	}

	static long clamp(long a, long min, long max) {
		return a < min ? min : a > max ? max : a;
	}

	static <A extends Comparable<? super A>> A clamp(A a, A min, A max) {
		return a.compareTo(min) < 0 ? min : a.compareTo(max) > 0 ? max : a;
	}

	static int abs(int a) {
		return a < 0 ? -a : a;
	}

	static long abs(long a) {
		return a < 0 ? -a : a;
	}

	static void forEachBitPerm(int n, int k, F.IV f) {
		for (int i = (1 << k) - 1; i < 1 << n;) {
			f.f(i);
			int t = (i | i - 1) + 1;
			i = t | ((t & -t) / (i & -i) >> 1) - 1;
		}
	}

	static int nextBitPerm(int a) {
		int t = (a | a - 1) + 1;
		return t | ((t & -t) / (a & -a) >> 1) - 1;
	}

	static void mebius(int n, F.IIV f) { // s, i
		int bit = 1;
		int exp = 0;
		for (int i = 1; i < 1 << n; i++) {
			f.f(i ^ bit, exp);
			if ((i & i + 1) == 0) {
				bit <<= 1;
				exp++;
			}
		}
	}

	static void zeta(int n, F.IIV f) { // s, i
		int m = (1 << n) - 1;
		int bit = 1;
		int exp = 0;
		for (int i = (1 << n) - 2; i >= 0; i--) {
			f.f(i ^ bit, exp);
			if ((~i & ~i + 1 & m) == 0) {
				bit <<= 1;
				exp++;
			}
		}
	}

	static <A> ArrayList<A> toAL(A[] as) {
		return make(as.length, i -> as[i]);
	}

	static <A> A[] doubleSize(A[] as) {
		return Arrays.copyOf(as, as.length << 1);
	}

	static long searchL(long ng, long ok, F.LB isOk) {
		while (ng - ok > 1 || ok - ng > 1) {
			long mid = ng + ok >> 1;
			if (isOk.f(mid))
				ok = mid;
			else
				ng = mid;
		}
		return ok;
	}

	static int searchI(int ng, int ok, F.IB isOk) {
		return (int) searchL((long) ng, (long) ok, (mid) -> isOk.f((int) mid));
	}
}

final class F { // Functions
	private F() {
	}

	interface VV {
		void f();
	}

	interface BV {
		void f(boolean a);
	}

	interface BXV<A> {
		void f(boolean a, A b);
	}

	interface BXXV<A, B> {
		void f(boolean a, A b, B c);
	}

	interface BXXXV<A, B, C> {
		void f(boolean a, A b, B c, C d);
	}

	interface XBV<A> {
		void f(A a, boolean b);
	}

	interface XXBV<A, B> {
		void f(A a, B b, boolean c);
	}

	interface XXXBV<A, B, C> {
		void f(A a, B b, C c, boolean d);
	}

	interface IV {
		void f(int a);
	}

	interface IXV<A> {
		void f(int a, A b);
	}

	interface IXXV<A, B> {
		void f(int a, A b, B c);
	}

	interface IXXXV<A, B, C> {
		void f(int a, A b, B c, C d);
	}

	interface XIV<A> {
		void f(A a, int b);
	}

	interface XXIV<A, B> {
		void f(A a, B b, int c);
	}

	interface XXXIV<A, B, C> {
		void f(A a, B b, C c, int d);
	}

	interface LV {
		void f(long a);
	}

	interface LXV<A> {
		void f(long a, A b);
	}

	interface LXXV<A, B> {
		void f(long a, A b, B c);
	}

	interface LXXXV<A, B, C> {
		void f(long a, A b, B c, C d);
	}

	interface XLV<A> {
		void f(A a, long b);
	}

	interface XXLV<A, B> {
		void f(A a, B b, long c);
	}

	interface XXXLV<A, B, C> {
		void f(A a, B b, C c, long d);
	}

	interface DV {
		void f(double a);
	}

	interface DXV<A> {
		void f(double a, A b);
	}

	interface DXXV<A, B> {
		void f(double a, A b, B c);
	}

	interface DXXXV<A, B, C> {
		void f(double a, A b, B c, C d);
	}

	interface XDV<A> {
		void f(A a, double b);
	}

	interface XXDV<A, B> {
		void f(A a, B b, double c);
	}

	interface XXXDV<A, B, C> {
		void f(A a, B b, C c, double d);
	}

	interface XV<A> {
		void f(A a);
	}

	interface XXV<A, B> {
		void f(A a, B b);
	}

	interface XXXV<A, B, C> {
		void f(A a, B b, C c);
	}

	interface XXXXV<A, B, C, D> {
		void f(A a, B b, C c, D d);
	}

	interface BBV {
		void f(boolean a, boolean b);
	}

	interface BIV {
		void f(boolean a, int b);
	}

	interface BLV {
		void f(boolean a, long b);
	}

	interface BDV {
		void f(boolean a, double b);
	}

	interface IBV {
		void f(int a, boolean b);
	}

	interface IIV {
		void f(int a, int b);
	}

	interface ILV {
		void f(int a, long b);
	}

	interface IDV {
		void f(int a, double b);
	}

	interface LBV {
		void f(long a, boolean b);
	}

	interface LIV {
		void f(long a, int b);
	}

	interface LLV {
		void f(long a, long b);
	}

	interface LDV {
		void f(long a, double b);
	}

	interface DBV {
		void f(double a, boolean b);
	}

	interface DIV {
		void f(double a, int b);
	}

	interface DLV {
		void f(double a, long b);
	}

	interface DDV {
		void f(double a, double b);
	}

	interface VB {
		boolean f();
	}

	interface BB {
		boolean f(boolean a);
	}

	interface BXB<A> {
		boolean f(boolean a, A b);
	}

	interface BXXB<A, B> {
		boolean f(boolean a, A b, B c);
	}

	interface BXXXB<A, B, C> {
		boolean f(boolean a, A b, B c, C d);
	}

	interface XBB<A> {
		boolean f(A a, boolean b);
	}

	interface XXBB<A, B> {
		boolean f(A a, B b, boolean c);
	}

	interface XXXBB<A, B, C> {
		boolean f(A a, B b, C c, boolean d);
	}

	interface IB {
		boolean f(int a);
	}

	interface IXB<A> {
		boolean f(int a, A b);
	}

	interface IXXB<A, B> {
		boolean f(int a, A b, B c);
	}

	interface IXXXB<A, B, C> {
		boolean f(int a, A b, B c, C d);
	}

	interface XIB<A> {
		boolean f(A a, int b);
	}

	interface XXIB<A, B> {
		boolean f(A a, B b, int c);
	}

	interface XXXIB<A, B, C> {
		boolean f(A a, B b, C c, int d);
	}

	interface LB {
		boolean f(long a);
	}

	interface LXB<A> {
		boolean f(long a, A b);
	}

	interface LXXB<A, B> {
		boolean f(long a, A b, B c);
	}

	interface LXXXB<A, B, C> {
		boolean f(long a, A b, B c, C d);
	}

	interface XLB<A> {
		boolean f(A a, long b);
	}

	interface XXLB<A, B> {
		boolean f(A a, B b, long c);
	}

	interface XXXLB<A, B, C> {
		boolean f(A a, B b, C c, long d);
	}

	interface DB {
		boolean f(double a);
	}

	interface DXB<A> {
		boolean f(double a, A b);
	}

	interface DXXB<A, B> {
		boolean f(double a, A b, B c);
	}

	interface DXXXB<A, B, C> {
		boolean f(double a, A b, B c, C d);
	}

	interface XDB<A> {
		boolean f(A a, double b);
	}

	interface XXDB<A, B> {
		boolean f(A a, B b, double c);
	}

	interface XXXDB<A, B, C> {
		boolean f(A a, B b, C c, double d);
	}

	interface XB<A> {
		boolean f(A a);
	}

	interface XXB<A, B> {
		boolean f(A a, B b);
	}

	interface XXXB<A, B, C> {
		boolean f(A a, B b, C c);
	}

	interface XXXXB<A, B, C, D> {
		boolean f(A a, B b, C c, D d);
	}

	interface BBB {
		boolean f(boolean a, boolean b);
	}

	interface BIB {
		boolean f(boolean a, int b);
	}

	interface BLB {
		boolean f(boolean a, long b);
	}

	interface BDB {
		boolean f(boolean a, double b);
	}

	interface IBB {
		boolean f(int a, boolean b);
	}

	interface IIB {
		boolean f(int a, int b);
	}

	interface ILB {
		boolean f(int a, long b);
	}

	interface IDB {
		boolean f(int a, double b);
	}

	interface LBB {
		boolean f(long a, boolean b);
	}

	interface LIB {
		boolean f(long a, int b);
	}

	interface LLB {
		boolean f(long a, long b);
	}

	interface LDB {
		boolean f(long a, double b);
	}

	interface DBB {
		boolean f(double a, boolean b);
	}

	interface DIB {
		boolean f(double a, int b);
	}

	interface DLB {
		boolean f(double a, long b);
	}

	interface DDB {
		boolean f(double a, double b);
	}

	interface VI {
		int f();
	}

	interface BI {
		int f(boolean a);
	}

	interface BXI<A> {
		int f(boolean a, A b);
	}

	interface BXXI<A, B> {
		int f(boolean a, A b, B c);
	}

	interface BXXXI<A, B, C> {
		int f(boolean a, A b, B c, C d);
	}

	interface XBI<A> {
		int f(A a, boolean b);
	}

	interface XXBI<A, B> {
		int f(A a, B b, boolean c);
	}

	interface XXXBI<A, B, C> {
		int f(A a, B b, C c, boolean d);
	}

	interface II {
		int f(int a);
	}

	interface IXI<A> {
		int f(int a, A b);
	}

	interface IXXI<A, B> {
		int f(int a, A b, B c);
	}

	interface IXXXI<A, B, C> {
		int f(int a, A b, B c, C d);
	}

	interface XII<A> {
		int f(A a, int b);
	}

	interface XXII<A, B> {
		int f(A a, B b, int c);
	}

	interface XXXII<A, B, C> {
		int f(A a, B b, C c, int d);
	}

	interface LI {
		int f(long a);
	}

	interface LXI<A> {
		int f(long a, A b);
	}

	interface LXXI<A, B> {
		int f(long a, A b, B c);
	}

	interface LXXXI<A, B, C> {
		int f(long a, A b, B c, C d);
	}

	interface XLI<A> {
		int f(A a, long b);
	}

	interface XXLI<A, B> {
		int f(A a, B b, long c);
	}

	interface XXXLI<A, B, C> {
		int f(A a, B b, C c, long d);
	}

	interface DI {
		int f(double a);
	}

	interface DXI<A> {
		int f(double a, A b);
	}

	interface DXXI<A, B> {
		int f(double a, A b, B c);
	}

	interface DXXXI<A, B, C> {
		int f(double a, A b, B c, C d);
	}

	interface XDI<A> {
		int f(A a, double b);
	}

	interface XXDI<A, B> {
		int f(A a, B b, double c);
	}

	interface XXXDI<A, B, C> {
		int f(A a, B b, C c, double d);
	}

	interface XI<A> {
		int f(A a);
	}

	interface XXI<A, B> {
		int f(A a, B b);
	}

	interface XXXI<A, B, C> {
		int f(A a, B b, C c);
	}

	interface XXXXI<A, B, C, D> {
		int f(A a, B b, C c, D d);
	}

	interface BBI {
		int f(boolean a, boolean b);
	}

	interface BII {
		int f(boolean a, int b);
	}

	interface BLI {
		int f(boolean a, long b);
	}

	interface BDI {
		int f(boolean a, double b);
	}

	interface IBI {
		int f(int a, boolean b);
	}

	interface III {
		int f(int a, int b);
	}

	interface ILI {
		int f(int a, long b);
	}

	interface IDI {
		int f(int a, double b);
	}

	interface LBI {
		int f(long a, boolean b);
	}

	interface LII {
		int f(long a, int b);
	}

	interface LLI {
		int f(long a, long b);
	}

	interface LDI {
		int f(long a, double b);
	}

	interface DBI {
		int f(double a, boolean b);
	}

	interface DII {
		int f(double a, int b);
	}

	interface DLI {
		int f(double a, long b);
	}

	interface DDI {
		int f(double a, double b);
	}

	interface VL {
		long f();
	}

	interface BL {
		long f(boolean a);
	}

	interface BXL<A> {
		long f(boolean a, A b);
	}

	interface BXXL<A, B> {
		long f(boolean a, A b, B c);
	}

	interface BXXXL<A, B, C> {
		long f(boolean a, A b, B c, C d);
	}

	interface XBL<A> {
		long f(A a, boolean b);
	}

	interface XXBL<A, B> {
		long f(A a, B b, boolean c);
	}

	interface XXXBL<A, B, C> {
		long f(A a, B b, C c, boolean d);
	}

	interface IL {
		long f(int a);
	}

	interface IXL<A> {
		long f(int a, A b);
	}

	interface IXXL<A, B> {
		long f(int a, A b, B c);
	}

	interface IXXXL<A, B, C> {
		long f(int a, A b, B c, C d);
	}

	interface XIL<A> {
		long f(A a, int b);
	}

	interface XXIL<A, B> {
		long f(A a, B b, int c);
	}

	interface XXXIL<A, B, C> {
		long f(A a, B b, C c, int d);
	}

	interface LL {
		long f(long a);
	}

	interface LXL<A> {
		long f(long a, A b);
	}

	interface LXXL<A, B> {
		long f(long a, A b, B c);
	}

	interface LXXXL<A, B, C> {
		long f(long a, A b, B c, C d);
	}

	interface XLL<A> {
		long f(A a, long b);
	}

	interface XXLL<A, B> {
		long f(A a, B b, long c);
	}

	interface XXXLL<A, B, C> {
		long f(A a, B b, C c, long d);
	}

	interface DL {
		long f(double a);
	}

	interface DXL<A> {
		long f(double a, A b);
	}

	interface DXXL<A, B> {
		long f(double a, A b, B c);
	}

	interface DXXXL<A, B, C> {
		long f(double a, A b, B c, C d);
	}

	interface XDL<A> {
		long f(A a, double b);
	}

	interface XXDL<A, B> {
		long f(A a, B b, double c);
	}

	interface XXXDL<A, B, C> {
		long f(A a, B b, C c, double d);
	}

	interface XL<A> {
		long f(A a);
	}

	interface XXL<A, B> {
		long f(A a, B b);
	}

	interface XXXL<A, B, C> {
		long f(A a, B b, C c);
	}

	interface XXXXL<A, B, C, D> {
		long f(A a, B b, C c, D d);
	}

	interface BBL {
		long f(boolean a, boolean b);
	}

	interface BIL {
		long f(boolean a, int b);
	}

	interface BLL {
		long f(boolean a, long b);
	}

	interface BDL {
		long f(boolean a, double b);
	}

	interface IBL {
		long f(int a, boolean b);
	}

	interface IIL {
		long f(int a, int b);
	}

	interface ILL {
		long f(int a, long b);
	}

	interface IDL {
		long f(int a, double b);
	}

	interface LBL {
		long f(long a, boolean b);
	}

	interface LIL {
		long f(long a, int b);
	}

	interface LLL {
		long f(long a, long b);
	}

	interface LDL {
		long f(long a, double b);
	}

	interface DBL {
		long f(double a, boolean b);
	}

	interface DIL {
		long f(double a, int b);
	}

	interface DLL {
		long f(double a, long b);
	}

	interface DDL {
		long f(double a, double b);
	}

	interface VD {
		double f();
	}

	interface BD {
		double f(boolean a);
	}

	interface BXD<A> {
		double f(boolean a, A b);
	}

	interface BXXD<A, B> {
		double f(boolean a, A b, B c);
	}

	interface BXXXD<A, B, C> {
		double f(boolean a, A b, B c, C d);
	}

	interface XBD<A> {
		double f(A a, boolean b);
	}

	interface XXBD<A, B> {
		double f(A a, B b, boolean c);
	}

	interface XXXBD<A, B, C> {
		double f(A a, B b, C c, boolean d);
	}

	interface ID {
		double f(int a);
	}

	interface IXD<A> {
		double f(int a, A b);
	}

	interface IXXD<A, B> {
		double f(int a, A b, B c);
	}

	interface IXXXD<A, B, C> {
		double f(int a, A b, B c, C d);
	}

	interface XID<A> {
		double f(A a, int b);
	}

	interface XXID<A, B> {
		double f(A a, B b, int c);
	}

	interface XXXID<A, B, C> {
		double f(A a, B b, C c, int d);
	}

	interface LD {
		double f(long a);
	}

	interface LXD<A> {
		double f(long a, A b);
	}

	interface LXXD<A, B> {
		double f(long a, A b, B c);
	}

	interface LXXXD<A, B, C> {
		double f(long a, A b, B c, C d);
	}

	interface XLD<A> {
		double f(A a, long b);
	}

	interface XXLD<A, B> {
		double f(A a, B b, long c);
	}

	interface XXXLD<A, B, C> {
		double f(A a, B b, C c, long d);
	}

	interface DD {
		double f(double a);
	}

	interface DXD<A> {
		double f(double a, A b);
	}

	interface DXXD<A, B> {
		double f(double a, A b, B c);
	}

	interface DXXXD<A, B, C> {
		double f(double a, A b, B c, C d);
	}

	interface XDD<A> {
		double f(A a, double b);
	}

	interface XXDD<A, B> {
		double f(A a, B b, double c);
	}

	interface XXXDD<A, B, C> {
		double f(A a, B b, C c, double d);
	}

	interface XD<A> {
		double f(A a);
	}

	interface XXD<A, B> {
		double f(A a, B b);
	}

	interface XXXD<A, B, C> {
		double f(A a, B b, C c);
	}

	interface XXXXD<A, B, C, D> {
		double f(A a, B b, C c, D d);
	}

	interface BBD {
		double f(boolean a, boolean b);
	}

	interface BID {
		double f(boolean a, int b);
	}

	interface BLD {
		double f(boolean a, long b);
	}

	interface BDD {
		double f(boolean a, double b);
	}

	interface IBD {
		double f(int a, boolean b);
	}

	interface IID {
		double f(int a, int b);
	}

	interface ILD {
		double f(int a, long b);
	}

	interface IDD {
		double f(int a, double b);
	}

	interface LBD {
		double f(long a, boolean b);
	}

	interface LID {
		double f(long a, int b);
	}

	interface LLD {
		double f(long a, long b);
	}

	interface LDD {
		double f(long a, double b);
	}

	interface DBD {
		double f(double a, boolean b);
	}

	interface DID {
		double f(double a, int b);
	}

	interface DLD {
		double f(double a, long b);
	}

	interface DDD {
		double f(double a, double b);
	}

	interface VX<A> {
		A f();
	}

	interface BX<A> {
		A f(boolean a);
	}

	interface BXX<A, B> {
		B f(boolean a, A b);
	}

	interface BXXX<A, B, C> {
		C f(boolean a, A b, B c);
	}

	interface BXXXX<A, B, C, D> {
		D f(boolean a, A b, B c, C d);
	}

	interface XBX<A, B> {
		B f(A a, boolean b);
	}

	interface XXBX<A, B, C> {
		C f(A a, B b, boolean c);
	}

	interface XXXBX<A, B, C, D> {
		D f(A a, B b, C c, boolean d);
	}

	interface IX<A> {
		A f(int a);
	}

	interface IXX<A, B> {
		B f(int a, A b);
	}

	interface IXXX<A, B, C> {
		C f(int a, A b, B c);
	}

	interface IXXXX<A, B, C, D> {
		D f(int a, A b, B c, C d);
	}

	interface XIX<A, B> {
		B f(A a, int b);
	}

	interface XXIX<A, B, C> {
		C f(A a, B b, int c);
	}

	interface XXXIX<A, B, C, D> {
		D f(A a, B b, C c, int d);
	}

	interface LX<A> {
		A f(long a);
	}

	interface LXX<A, B> {
		B f(long a, A b);
	}

	interface LXXX<A, B, C> {
		C f(long a, A b, B c);
	}

	interface LXXXX<A, B, C, D> {
		D f(long a, A b, B c, C d);
	}

	interface XLX<A, B> {
		B f(A a, long b);
	}

	interface XXLX<A, B, C> {
		C f(A a, B b, long c);
	}

	interface XXXLX<A, B, C, D> {
		D f(A a, B b, C c, long d);
	}

	interface DX<A> {
		A f(double a);
	}

	interface DXX<A, B> {
		B f(double a, A b);
	}

	interface DXXX<A, B, C> {
		C f(double a, A b, B c);
	}

	interface DXXXX<A, B, C, D> {
		D f(double a, A b, B c, C d);
	}

	interface XDX<A, B> {
		B f(A a, double b);
	}

	interface XXDX<A, B, C> {
		C f(A a, B b, double c);
	}

	interface XXXDX<A, B, C, D> {
		D f(A a, B b, C c, double d);
	}

	interface XX<A, B> {
		B f(A a);
	}

	interface XXX<A, B, C> {
		C f(A a, B b);
	}

	interface XXXX<A, B, C, D> {
		D f(A a, B b, C c);
	}

	interface XXXXX<A, B, C, D, E> {
		E f(A a, B b, C c, D d);
	}

	interface BBX<A> {
		A f(boolean a, boolean b);
	}

	interface BIX<A> {
		A f(boolean a, int b);
	}

	interface BLX<A> {
		A f(boolean a, long b);
	}

	interface BDX<A> {
		A f(boolean a, double b);
	}

	interface IBX<A> {
		A f(int a, boolean b);
	}

	interface IIX<A> {
		A f(int a, int b);
	}

	interface ILX<A> {
		A f(int a, long b);
	}

	interface IDX<A> {
		A f(int a, double b);
	}

	interface LBX<A> {
		A f(long a, boolean b);
	}

	interface LIX<A> {
		A f(long a, int b);
	}

	interface LLX<A> {
		A f(long a, long b);
	}

	interface LDX<A> {
		A f(long a, double b);
	}

	interface DBX<A> {
		A f(double a, boolean b);
	}

	interface DIX<A> {
		A f(double a, int b);
	}

	interface DLX<A> {
		A f(double a, long b);
	}

	interface DDX<A> {
		A f(double a, double b);
	}
}

class SA { // suffix array
	static int[] makeSA(String s) {
		int n = s.length() + 1;
		int[] cs = new int[n];
		cs[n - 1] = 0;
		for (int i = 0; i < n - 1; i++)
			cs[i] = s.charAt(i) + 1;
		ArrayList<Integer> acs = U.make(n, i -> cs[i]);
		TreeMap<Integer, Integer> tm = U.compress(acs).a;
		int k = tm.size();
		for (int i = 0; i < n; i++)
			cs[i] = tm.get(cs[i]);
		return makeSA(cs, n, k);
	}

	static int[] makeLCP(String s, int[] sa) { // lcp(i, i+1)
		int n = sa.length;
		int[] r = new int[n];
		for (int i = 0; i < n; i++)
			r[sa[i]] = i;
		int[] lcp = new int[n];
		int l = 0;
		for (int i = 0; i < n; i++) {
			int idx = r[i];
			if (idx == n - 1) {
				lcp[idx] = -1;
				l = 0;
				continue;
			}
			int p = sa[idx];
			int q = sa[idx + 1];
			if (l > 0)
				l--;
			while (p + l < n - 1 && q + l < n - 1 && s.charAt(p + l) == s.charAt(q + l))
				l++;
			lcp[idx] = l;
		}
		return lcp;
	}

	static F.III lcpQuery(String s) {
		int n = s.length() + 1;
		int[] sa = makeSA(s);
		int[] lcp = makeLCP(s, sa);
		int[] inv = new int[n];
		for (int i = 0; i < n; i++) {
			inv[sa[i]] = i;
		}
		ST<Integer> st = new ST<Integer>(n, (a, b) -> a < b ? a : b, Integer.MAX_VALUE);
		st.init(i -> i < n ? lcp[i] : Integer.MAX_VALUE);
		return (i, j) -> {
			if (i == j)
				return n - 1 - i;
			i = inv[i];
			j = inv[j];
			if (i > j) {
				i ^= j;
				j ^= i;
				i ^= j;
			}
			return st.query(i, j);
		};
	}

	private static int[] makeSA(int[] cs, int n, int k) {
		boolean[] isS = new boolean[n];
		boolean[] isLms = new boolean[n];
		int[] lmss = new int[n];
		int numLmss = 0;
		isS[n - 1] = true;
		for (int i = n - 2; i >= 0; i--)
			isS[i] = cs[i] < cs[i + 1] || cs[i] == cs[i + 1] && isS[i + 1];
		for (int i = 1; i < n; i++)
			if (!isS[i - 1] && isS[i]) {
				lmss[numLmss++] = i;
				isLms[i] = true;
			}
		int[] sa = inducedSort(cs, n, numLmss, k, lmss, isS);
		int[] lmss2 = new int[numLmss];
		numLmss = 0;
		for (int i = 0; i < n; i++)
			if (isLms[sa[i]])
				lmss2[numLmss++] = sa[i];
		int num = 0;
		sa[lmss2[0]] = 0;
		for (int i = 0; i < numLmss - 1; i++) {
			int p = lmss2[i];
			int q = lmss2[i + 1];
			for (int j = 0; j < n; j++) {
				if (cs[p] != cs[q] || isLms[p] != isLms[q]) {
					sa[lmss2[i + 1]] = ++num;
					break;
				} else if (j > 0 && (isLms[p] || isLms[q])) {
					sa[lmss2[i + 1]] = num;
					break;
				}
				p++;
				q++;
			}
		}
		if (num + 1 < numLmss) {
			numLmss = 0;
			for (int i = 0; i < n; i++)
				if (isLms[i])
					lmss2[numLmss++] = sa[i];
			lmss2 = makeSA(lmss2, numLmss, num + 1);
			for (int i = 0; i < numLmss; i++)
				lmss2[i] = lmss[lmss2[i]];
		}
		return inducedSort(cs, n, numLmss, k, lmss2, isS);
	}

	private static int[] inducedSort(int[] cs, int n, int numLmss, int k, int[] lmss, boolean[] isS) {
		int[] sa = new int[n];
		int[] bin = new int[k + 1];
		for (int i = 0; i < n; i++)
			bin[cs[i] + 1]++;
		for (int i = 0; i < k; i++)
			bin[i + 1] += bin[i];
		int[] counts = new int[k];
		for (int i = numLmss - 1; i >= 0; i--) { // put LMS backward
			int c = cs[lmss[i]];
			sa[bin[c + 1] - 1 - counts[c]++] = lmss[i];
		}
		for (int i = 0; i < k; i++)
			counts[i] = 0;
		for (int i = 0; i < n; i++) { // put L forward
			int s = sa[i] - 1;
			if (s < 0 || isS[s])
				continue;
			int c = cs[s];
			sa[bin[c] + counts[c]++] = s;
		}
		for (int i = 0; i < k; i++)
			counts[i] = 0;
		for (int i = n - 1; i >= 0; i--) { // put S backward
			int s = sa[i] - 1;
			if (s < 0 || !isS[s])
				continue;
			int c = cs[s];
			sa[bin[c + 1] - 1 - counts[c]++] = s;
		}
		return sa;
	}
}

class ST<A> { // Segment Tree
	private ArrayList<A> as;
	private int h;
	private int n;
	private F.XXX<A, A, A> merger;
	private A e;

	ST(int num, F.XXX<A, A, A> merger, A e) {
		this.merger = merger;
		this.e = e;
		h = 0;
		while ((1 << h) < num)
			h++;
		n = 1 << h;
		as = U.make(2 * n, i -> e);
	}

	void init(A a) {
		init(i -> a);
	}

	void init(A[] as) {
		init(i -> i < as.length ? as[i] : e);
	}

	void init(F.IX<A> maker) {
		for (int i = 0; i < n; i++)
			as.set(n + i, maker.f(i));
		for (int i = n - 1; i > 0; i--)
			as.set(i, merge(as.get(i << 1), as.get(i << 1 | 1)));
	}

	A get(int i) {
		return query(i, i + 1);
	}

	void set(int i, A a) {
		as.set(i += n, a);
		while ((i >>= 1) > 0)
			as.set(i, merge(as.get(i << 1), as.get(i << 1 | 1)));
	}

	A query(int l, int r) {
		l += n;
		r += n;
		A al = e;
		A ar = e;
		while (l < r) {
			if ((l & 1) != 0)
				al = merge(al, as.get(l++));
			if ((r & 1) != 0)
				ar = merge(as.get(--r), ar);
			l >>= 1;
			r >>= 1;
		}
		return merge(al, ar);
	}

	private A merge(A a, A b) {
		return a == e ? b : b == e ? a : merger.f(a, b);
	}
}

class LST<A, Op> { // Lazy Segment Tree
	private ArrayList<A> as;
	private ArrayList<Op> lazy;
	private F.XXX<A, A, A> merger;
	private F.XXIX<A, Op, A> applier;
	private F.XXX<Op, Op, Op> opMerger;
	private A e;
	private Op id;
	private int h;
	private int n;

	LST(int num, F.XXX<A, A, A> merger, F.XXIX<A, Op, A> applier, F.XXX<Op, Op, Op> opMerger, A e, Op id) {
		this.merger = merger;
		this.applier = applier;
		this.opMerger = opMerger;
		this.e = e;
		this.id = id;
		h = 0;
		while ((1 << h) < num)
			h++;
		n = 1 << h;
		int size = n << 1;
		as = U.make(size, i -> e);
		lazy = U.make(size, i -> id);
	}

	void init(A a) {
		init(i -> a);
	}

	void init(A[] as) {
		init(i -> i < as.length ? as[i] : e);
	}

	void init(F.IX<A> maker) {
		for (int i = 0; i < n << 1; i++)
			lazy.set(i, id);
		for (int i = 0; i < n; i++)
			as.set(n + i, maker.f(i));
		for (int i = n - 1; i > 0; i--)
			as.set(i, merge(as.get(i << 1), as.get(i << 1 | 1)));
	}

	A get(int i) {
		return query(i, i + 1);
	}

	void set(int i, A a) {
		prop(i += n);
		as.set(i, a);
		lazy.set(i, id);
		backprop(i);
	}

	A query(int l, int r) {
		prop(l += n);
		prop(r += n - 1);
		r++;
		A al = e;
		A ar = e;
		int len = 1;
		while (l < r) {
			if ((l & 1) != 0)
				al = merge(al, eval(l++, len));
			if ((r & 1) != 0)
				ar = merge(eval(--r, len), ar);
			l >>= 1;
			r >>= 1;
			len <<= 1;
		}
		return merge(al, ar);
	}

	void apply(int l, int r, Op o) {
		prop(l += n);
		prop(r += n - 1);
		int a = l;
		int b = r;
		r++;
		while (l < r) {
			if ((l & 1) != 0)
				lazy.set(l, mergeOp(lazy.get(l++), o));
			if ((r & 1) != 0)
				lazy.set(--r, mergeOp(lazy.get(r), o));
			l >>= 1;
			r >>= 1;
		}
		backprop(a);
		backprop(b);
	}

	int size() {
		return n;
	}

	private A merge(A a, A b) {
		return a == e ? b : b == e ? a : merger.f(a, b);
	}

	private Op mergeOp(Op o, Op p) {
		return o == id ? p : p == id ? o : opMerger.f(o, p);
	}

	private A apply(A a, Op o, int len) {
		return o == id ? a : applier.f(a, o, len);
	}

	private A eval(int k, int len) {
		return apply(as.get(k), lazy.get(k), len);
	}

	private void flush(int k, int len) {
		Op o = lazy.get(k);
		if (o == id)
			return;
		lazy.set(k << 1, mergeOp(lazy.get(k << 1), o));
		lazy.set(k << 1 | 1, mergeOp(lazy.get(k << 1 | 1), o));
		as.set(k, apply(as.get(k), o, len));
		lazy.set(k, id);
	}

	private void prop(int k) {
		for (int i = h; i > 0; i--)
			flush(k >> i, 1 << i);
	}

	private void backprop(int k) {
		int len = 1;
		while ((k >>= 1) > 0) {
			as.set(k, merge(eval(k << 1, len), eval(k << 1 | 1, len)));
			len <<= 1;
		}
	}
}

interface Magma<A> {
	A g(A a, A b);
}

interface Associative {
}

interface Unital<A> {
	A e();
}

interface Invertible<A> {
	A inv(A a);
}

interface Commutative {
}

interface SemiGroup<A> extends Magma<A>, Associative {
}

interface Monoid<A> extends SemiGroup<A>, Unital<A> {
	static <A> Monoid<A> make(F.XXX<A, A, A> g, A e) {
		return new Monoid<A>() {
			public A g(A a, A b) {
				return a.equals(e) ? b : b.equals(e) ? a : g.f(a, b);
			}

			public A e() {
				return e;
			}
		};
	}
}

interface CommutativeMonoid<A> extends Monoid<A>, Commutative {
	static <A> CommutativeMonoid<A> make(F.XXX<A, A, A> g, A e) {
		return new CommutativeMonoid<A>() {
			public A g(A a, A b) {
				return a.equals(e) ? b : b.equals(e) ? a : g.f(a, b);
			}

			public A e() {
				return e;
			}
		};
	}
}

interface Group<A> extends Monoid<A>, Invertible<A> {
	static <A> Group<A> make(F.XXX<A, A, A> g, F.XX<A, A> inv, A e) {
		return new Group<A>() {
			public A g(A a, A b) {
				return a.equals(e) ? b : b.equals(e) ? a : g.f(a, b);
			}

			public A e() {
				return e;
			}

			public A inv(A a) {
				return a.equals(e) ? e : inv.f(a);
			}
		};
	}
}

interface AbelianGroup<A> extends Group<A>, CommutativeMonoid<A> {
	static <A> AbelianGroup<A> make(F.XXX<A, A, A> g, F.XX<A, A> inv, A e) {
		return new AbelianGroup<A>() {
			public A g(A a, A b) {
				return a.equals(e) ? b : b.equals(e) ? a : g.f(a, b);
			}

			public A e() {
				return e;
			}

			public A inv(A a) {
				return a.equals(e) ? e : inv.f(a);
			}
		};
	}
}

interface Ring<A> {
	AbelianGroup<A> add();

	Monoid<A> mul();

	default A zero() {
		return add().e();
	}

	default A one() {
		return mul().e();
	}

	static <A> Ring<A> make(F.XXX<A, A, A> add, F.XX<A, A> neg, F.XXX<A, A, A> mul, A zero, A one) {
		return make(AbelianGroup.make(add, neg, zero), Monoid.make(mul, one));
	}

	static <A> Ring<A> make(AbelianGroup<A> add, Monoid<A> mul) {
		return new Ring<A>() {
			public AbelianGroup<A> add() {
				return add;
			}

			public Monoid<A> mul() {
				return mul;
			}
		};
	}
}

interface CommutativeRing<A> extends Ring<A> {
	CommutativeMonoid<A> mul();

	static <A> CommutativeRing<A> make(F.XXX<A, A, A> add, F.XX<A, A> neg, F.XXX<A, A, A> mul, A zero, A one) {
		return make(AbelianGroup.make(add, neg, zero), CommutativeMonoid.make(mul, one));
	}

	static <A> CommutativeRing<A> make(AbelianGroup<A> add, CommutativeMonoid<A> mul) {
		return new CommutativeRing<A>() {
			public AbelianGroup<A> add() {
				return add;
			}

			public CommutativeMonoid<A> mul() {
				return mul;
			}
		};
	}
}

interface EuclideanRing<A> extends CommutativeRing<A> {
	A div(A a, A b);

	A mod(A a, A b);

	static <A> EuclideanRing<A> make(F.XXX<A, A, A> add, F.XX<A, A> neg, F.XXX<A, A, A> mul, F.XXX<A, A, A> div,
			F.XXX<A, A, A> mod, A zero, A one) {
		return make(AbelianGroup.make(add, neg, zero), CommutativeMonoid.make(mul, one), div, mod);
	}

	static <A> EuclideanRing<A> make(AbelianGroup<A> add, CommutativeMonoid<A> mul, F.XXX<A, A, A> div,
			F.XXX<A, A, A> mod) {
		final A zero = add.e();
		final A one = mul.e();
		return new EuclideanRing<A>() {
			public AbelianGroup<A> add() {
				return add;
			}

			public CommutativeMonoid<A> mul() {
				return mul;
			}

			public A div(A a, A b) {
				if (b.equals(zero))
					throw new ArithmeticException(""division by zero"");
				return b.equals(one) ? a : div.f(a, b);
			}

			public A mod(A a, A b) {
				if (b.equals(zero))
					throw new ArithmeticException(""division by zero"");
				return b.equals(one) ? zero : mod.f(a, b);
			}
		};
	}
}

interface Field<A> extends EuclideanRing<A> {
	AbelianGroup<A> mul();

	static <A> Field<A> make(F.XXX<A, A, A> add, F.XX<A, A> neg, F.XXX<A, A, A> mul, F.XX<A, A> inv, A zero, A one) {
		return make(AbelianGroup.make(add, neg, zero), AbelianGroup.make(mul, inv, one));
	}

	static <A> Field<A> make(AbelianGroup<A> add, AbelianGroup<A> mul) {
		final A zero = add.e();
		final A one = mul.e();
		return new Field<A>() {
			public AbelianGroup<A> add() {
				return add;
			}

			public AbelianGroup<A> mul() {
				return mul;
			}

			public A div(A a, A b) {
				if (b.equals(zero))
					throw new ArithmeticException(""division by zero"");
				return b.equals(one) ? a : mul.g(a, mul.inv(b));
			}

			public A mod(A a, A b) {
				if (b.equals(zero))
					throw new ArithmeticException(""division by zero"");
				return zero;
			}
		};
	}
}

final class Alg {
	private Alg() {
	}

	static <A extends Comparable<? super A>> A gcd(A a, A b, EuclideanRing<A> ring) {
		AbelianGroup<A> add = ring.add();
		A zero = add.e();
		int sa = a.compareTo(zero);
		int sb = b.compareTo(zero);
		if (sa == 0)
			return b;
		if (sb == 0)
			return a;
		if (sa < 0)
			a = add.inv(a);
		if (sb < 0)
			b = add.inv(b);
		if (a.compareTo(b) < 0) {
			A tmp = a;
			a = b;
			b = tmp;
		}
		while (true) {
			A c = ring.mod(a, b);
			if (c.compareTo(zero) == 0)
				return b;
			a = b;
			b = c;
		}
	}

	static long gcd(long a, long b) {
		if (a == 0)
			return b;
		if (b == 0)
			return a;
		if (a < 0)
			a = -a;
		if (b < 0)
			b = -b;
		if (a < b) {
			a ^= b;
			b ^= a;
			a ^= b;
		}
		while (true) {
			long c = a % b;
			if (c == 0)
				return b;
			a = b;
			b = c;
		}
	}

	static int gcd(int a, int b) {
		return (int) gcd((long) a, (long) b);
	}

	static <A extends Comparable<A>> int[] lis(F.IX<A> access, int size) {
		Object[] dp = new Object[size];
		int[][] dpIndices = new int[size][2];
		dp[0] = access.f(0);
		int len = 1;
		int lidx = 0;
		for (int i = 1; i < size; i++) {
			A ai = access.f(i);
			@SuppressWarnings(""unchecked"")
			int idx = U.searchI(-1, len, j -> ai.compareTo((A) dp[j]) <= 0); // replace <= with < to return NLDS
			dp[idx] = ai;
			dpIndices[idx][0] = i;
			if (idx == len) {
				lidx = i;
				len++;
			}
			if (idx > 0)
				dpIndices[i][1] = dpIndices[idx - 1][0];
		}
		int[] res = new int[len];
		res[len - 1] = lidx;
		for (int i = len - 1; i >= 0; i--) {
			res[i] = lidx;
			lidx = dpIndices[lidx][1];
		}
		return res;
	}

	static <A> A pow(A a, long b, Monoid<A> monoid) {
		A res = monoid.e();
		while (b > 0) {
			if ((b & 1) != 0)
				res = monoid.g(res, a);
			a = monoid.g(a, a);
			b >>= 1;
		}
		return res;
	}

	static <A> A pow(A a, BigInteger b, Monoid<A> monoid) {
		A res = monoid.e();
		while (b.compareTo(BigInteger.ZERO) > 0) {
			if ((b.and(BigInteger.ONE)).intValueExact() != 0)
				res = monoid.g(res, a);
			a = monoid.g(a, a);
			b = b.divide(BigInteger.valueOf(2));
		}
		return res;
	}

	static long pow(long a, long b) {
		long res = 1;
		while (b > 0) {
			if ((b & 1) != 0)
				res *= a;
			a *= a;
			b >>= 1;
		}
		return res;
	}

	static <A extends Comparable<? super A>> T<A, A, A> extgcd(A a, A b, EuclideanRing<A> ring) { // returns (x, y, d) s.t. ax + by = d
		AbelianGroup<A> add = ring.add();
		CommutativeMonoid<A> mul = ring.mul();
		A zero = add.e();
		A one = mul.e();
		A sa = a.compareTo(zero) < 0 ? add.inv(one) : one;
		A sb = b.compareTo(zero) < 0 ? add.inv(one) : one;
		a = mul.g(a, sa);
		b = mul.g(b, sb);
		A x = one;
		A y = zero;
		A z = zero;
		A w = one;
		while (b.compareTo(zero) > 0) {
			A q = ring.div(a, b);
			A t = z;
			z = add.g(x, add.inv(mul.g(q, z)));
			x = t;
			t = w;
			w = add.g(y, add.inv(mul.g(q, w)));
			y = t;
			t = b;
			b = add.g(a, add.inv(mul.g(q, b)));
			a = t;
		}
		return T.make(mul.g(x, sa), mul.g(y, sb), a);
	}

	static TL extgcd(long a, long b) {
		int sa = a < 0 ? -1 : 1;
		int sb = b < 0 ? -1 : 1;
		a *= sa;
		b *= sb;
		long x = 1;
		long y = 0;
		long z = 0;
		long w = 1;
		while (b > 0) {
			long q = a / b;
			long t = z;
			z = x - q * z;
			x = t;
			t = w;
			w = y - q * w;
			y = t;
			t = b;
			b = a - q * b;
			a = t;
		}
		return TL.make(x * sa, y * sb, a);
	}

	static TI extgcd(int a, int b) {
		return extgcd((long) a, (long) b).toInt();
	}

	static ArrayList<PI> factorize(int n) { // factor, exponent
		ArrayList<PI> res = new ArrayList<PI>();
		for (int i = 2; i * i <= n; i++) {
			int count = 0;
			while (n % i == 0) {
				n /= i;
				count++;
			}
			if (count > 0)
				res.add(PI.make(i, count));
		}
		if (n > 1)
			res.add(PI.make(n, 1));
		return res;
	}

	static ArrayList<PL> factorize(long n) { // factor, exponent
		ArrayList<PL> res = new ArrayList<PL>();
		for (int i = 2; i * i <= n; i++) {
			int count = 0;
			while (n % i == 0) {
				n /= i;
				count++;
			}
			if (count > 0)
				res.add(PL.make(i, count));
		}
		if (n > 1)
			res.add(PL.make(n, 1));
		return res;
	}

	static <A> A arithSum(A a, A d, long num, Ring<A> ring) {
		return arithGeomSum(a, d, ring.one(), ring.one(), num, ring);
	}

	static <A> A geomSum(A b, A r, long num, Ring<A> ring) {
		return arithGeomSum(ring.one(), ring.zero(), b, r, num, ring);
	}

	static <A> A arithGeomSum(A a, A d, A b, A r, long num, Ring<A> ring) { // Σ(a+(i-1)d)br^(i-1)
		AbelianGroup<A> add = ring.add();
		Monoid<A> mul = ring.mul();
		Monoid<MN<A>> matMul = Mat.mulRing(3, ring);
		A zero = ring.zero();
		A one = ring.one();
		MN<A> mat = pow(Mat.make(new Object[][] { { r, d, a }, { zero, r, r }, { zero, zero, one } }), num - 1, matMul);
		return mul.g(add.g(add.g(mul.g(mat.at(0, 0), a), mul.g(mat.at(0, 1), r)), mat.at(0, 2)), b);
	}
}

class MN<A> {
	final int m;
	final int n;
	private final Object[][] as;

	static class Scalar<A> extends MN<A> {
		final long l;
		A a;

		Scalar(int m, int n, long l, A zero, A oneTimesL) {
			super(m, n, (i, j) -> i == j ? oneTimesL : zero);
			this.a = oneTimesL;
			this.l = l;
		}
	}

	MN(int m, int n, Mat.Accessor<A> accessor) {
		this.m = m;
		this.n = n;
		as = new Object[m][n];
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				as[i][j] = accessor.at(i, j);
			}
		}
	}

	public String toString() {
		String s = """";
		for (int i = 0; i < m; i++) {
			s += i == 0 ? ""[[ "" : "" [ "";
			for (int j = 0; j < n; j++) {
				s += (j == 0 ? """" : "", "") + as[i][j];
			}
			s += i == m - 1 ? "" ]]"" : "" ]\n"";
		}
		return s;
	}

	@SuppressWarnings(""unchecked"")
	A at(int i, int j) {
		return (A) as[i][j];
	}

	@SuppressWarnings(""unchecked"")
	A[][] toArray() {
		A[][] res = (A[][]) Array.newInstance(as[0][0].getClass(), m, n);
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				res[i][j] = (A) as[i][j];
			}
		}
		return res;
	}

	int[][] toIntArray() {
		int[][] res = new int[m][n];
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				res[i][j] = (int) as[i][j];
			}
		}
		return res;
	}

	long[][] toLongArray() {
		long[][] res = new long[m][n];
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				res[i][j] = (long) as[i][j];
			}
		}
		return res;
	}

	double[][] toDoubleArray() {
		double[][] res = new double[m][n];
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				res[i][j] = (double) as[i][j];
			}
		}
		return res;
	}
}

class Mat<A> {
	interface Accessor<A> {
		A at(int i, int j);
	}

	private static <A> MN.Scalar<A> make(int m, int n, long l, A zero, A oneTimesL) {
		return new MN.Scalar<A>(m, n, l, zero, oneTimesL);
	}

	static <A> MN<A> make(int m, int n, Accessor<A> accessor) {
		return new MN<A>(m, n, accessor);
	}

	static <A> MN<A> make(int m, int n, A[][] as) {
		return new MN<A>(m, n, (i, j) -> as[i][j]);
	}

	static MN<Long> make(int[][] as) {
		return new MN<Long>(as.length, as.length == 0 ? 0 : as[0].length, (i, j) -> (long) as[i][j]);
	}

	static MN<Long> make(long[][] as) {
		return new MN<Long>(as.length, as.length == 0 ? 0 : as[0].length, (i, j) -> as[i][j]);
	}

	static MN<Double> make(double[][] as) {
		return new MN<Double>(as.length, as.length == 0 ? 0 : as[0].length, (i, j) -> as[i][j]);
	}

	static <A> MN<A> make(int[][] as, F.IX<A> toA) {
		return new MN<A>(as.length, as.length == 0 ? 0 : as[0].length, (i, j) -> toA.f(as[i][j]));
	}

	static <A> MN<A> make(long[][] as, F.LX<A> toA) {
		return new MN<A>(as.length, as.length == 0 ? 0 : as[0].length, (i, j) -> toA.f(as[i][j]));
	}

	static <A> MN<A> make(double[][] as, F.DX<A> toA) {
		return new MN<A>(as.length, as.length == 0 ? 0 : as[0].length, (i, j) -> toA.f(as[i][j]));
	}

	static <A, B> MN<A> make(B[][] as, F.XX<B, A> toA) {
		return new MN<A>(as.length, as.length == 0 ? 0 : as[0].length, (i, j) -> toA.f(as[i][j]));
	}

	@SuppressWarnings(""unchecked"")
	static <A> MN<A> make(Object[][] as) {
		return new MN<A>(as.length, as.length == 0 ? 0 : as[0].length, (i, j) -> (A) as[i][j]);
	}

	static <A> MN<A> eye(int n, Ring<A> ring) {
		return make(n, n, (i, j) -> i == j ? ring.mul().e() : ring.add().e());
	}

	static <A> AbelianGroup<MN<A>> add(int m, int n, Ring<A> ring) {
		return AbelianGroup.make((a, b) -> add(a, b, ring), a -> neg(a, ring), make(m, n, 0, ring.zero(), ring.zero()));
	}

	static <A> Monoid<MN<A>> mulRing(int n, Ring<A> ring) {
		return Monoid.make((a, b) -> mul(a, b, ring), make(n, n, 1, ring.zero(), ring.one()));
	}

	static <A> AbelianGroup<MN<A>> mulField(int n, Field<A> field) {
		return AbelianGroup.make((a, b) -> mul(a, b, field), a -> inv(a, field),
				make(n, n, 1, field.zero(), field.one()));
	}

	static <A> MN<A> add(MN<A> a, MN<A> b, Ring<A> ring) {
		int m = U.max(a.m, b.m);
		int n = U.max(a.n, b.n);
		AbelianGroup<A> add = ring.add();
		if (a instanceof MN.Scalar && b instanceof MN.Scalar) {
			MN.Scalar<A> as = ((MN.Scalar<A>) a);
			MN.Scalar<A> bs = ((MN.Scalar<A>) b);
			return make(m, n, as.l + bs.l, ring.zero(), add.g(as.a, bs.a));
		}
		return make(m, n, (i, j) -> add.g(a.at(i, j), b.at(i, j)));
	}

	static <A> MN<A> neg(MN<A> a, Ring<A> ring) {
		if (a instanceof MN.Scalar) {
			MN.Scalar<A> as = ((MN.Scalar<A>) a);
			return make(a.m, a.n, -as.l, ring.zero(), ring.add().inv(as.a));
		}
		return make(a.m, a.n, (i, j) -> ring.add().inv(a.at(i, j)));
	}

	static <A> MN<A> mul(MN<A> a, MN<A> b, Ring<A> ring) {
		int m = a.m;
		int u = U.max(a.n, b.m);
		int n = b.n;
		AbelianGroup<A> add = ring.add();
		Monoid<A> mul = ring.mul();
		if (a instanceof MN.Scalar && b instanceof MN.Scalar) {
			MN.Scalar<A> as = ((MN.Scalar<A>) a);
			MN.Scalar<A> bs = ((MN.Scalar<A>) b);
			return make(m, n, as.l * bs.l, ring.zero(), mul.g(as.a, bs.a));
		}
		return make(m, n, (i, j) -> {
			A res = ring.zero();
			for (int k = 0; k < u; k++)
				res = add.g(res, mul.g(a.at(i, k), b.at(k, j)));
			return res;
		});
	}

	static <A> A det(MN<A> a, Field<A> field) {
		return detInv(a, field).a;
	}

	static <A> MN<A> inv(MN<A> a, Field<A> field) {
		UP<A, MN<A>> detInv = detInv(a, field);
		if (detInv.a.equals(field.zero()))
			throw new ArithmeticException(""inverse does not exist: det=0"");
		return detInv.b;
	}

	@SuppressWarnings(""unchecked"")
	private static <A> UP<A, MN<A>> detInv(MN<A> a, Field<A> field) {
		if (a.m != a.n)
			throw new IllegalArgumentException(""matrix not square"");
		if (field.zero() instanceof Long) {
			UP<Long, MN<Long>> detInv = detInvLong((MN<Long>) a, (Field<Long>) field);
			return UP.make((A) detInv.a, (MN<A>) detInv.b);
		}
		int n = a.n;
		AbelianGroup<A> add = field.add();
		AbelianGroup<A> mul = field.mul();
		A zero = field.zero();
		A one = field.one();
		A[][] m1 = a.toArray();
		A[][] m2 = eye(n, field).toArray();
		A res = one;
		int sign = 1;
		for (int i = 0; i < n; i++) {
			int pivot = -1;
			for (int j = i; j < n; j++) {
				if (!m1[j][i].equals(zero)) {
					pivot = j;
					break;
				}
			}
			if (pivot == -1) {
				return UP.make(zero, null);
			}
			if (pivot != i) {
				sign = -sign;
				A tmp;
				for (int j = i; j < n; j++) { // [0, i) are zero
					tmp = m1[i][j];
					m1[i][j] = m1[pivot][j];
					m1[pivot][j] = tmp;
				}
				for (int j = 0; j < n; j++) {
					tmp = m2[i][j];
					m2[i][j] = m2[pivot][j];
					m2[pivot][j] = tmp;
				}
			}
			A d = m1[i][i];
			res = mul.g(res, d);
			d = mul.inv(d);
			m1[i][i] = one;
			for (int j = i + 1; j < n; j++) {
				m1[i][j] = mul.g(m1[i][j], d);
			}
			for (int j = 0; j < n; j++) {
				m2[i][j] = mul.g(m2[i][j], d);
			}
			for (int j = 0; j < n; j++) {
				if (i == j)
					continue;
				A mult = m1[j][i];
				m1[j][i] = zero;
				for (int k = i + 1; k < n; k++) {
					m1[j][k] = add.g(m1[j][k], add.inv(mul.g(m1[i][k], mult)));
				}
				for (int k = 0; k < n; k++) {
					m2[j][k] = add.g(m2[j][k], add.inv(mul.g(m2[i][k], mult)));
				}
			}
		}
		return UP.make(sign == 1 ? res : add.inv(res), make(m2));
	}

	private static UP<Long, MN<Long>> detInvLong(MN<Long> a, Field<Long> field) {
		if (a.m != a.n)
			throw new IllegalArgumentException(""matrix not square"");
		int n = a.n;
		AbelianGroup<Long> add = field.add();
		AbelianGroup<Long> mul = field.mul();
		long zero = field.zero();
		long one = field.one();
		long[][] m1 = a.toLongArray();
		long[][] m2 = eye(n, field).toLongArray();
		long res = one;
		int sign = 1;
		for (int i = 0; i < n; i++) {
			int pivot = -1;
			for (int j = i; j < n; j++) {
				if (m1[j][i] != zero) {
					pivot = j;
					break;
				}
			}
			if (pivot == -1) {
				return UP.make(zero, null);
			}
			if (pivot != i) {
				sign = -sign;
				long tmp;
				for (int j = i; j < n; j++) { // [0, i) are zero
					tmp = m1[i][j];
					m1[i][j] = m1[pivot][j];
					m1[pivot][j] = tmp;
				}
				for (int j = 0; j < n; j++) {
					tmp = m2[i][j];
					m2[i][j] = m2[pivot][j];
					m2[pivot][j] = tmp;
				}
			}
			long d = m1[i][i];
			res = mul.g(res, d);
			d = mul.inv(d);
			m1[i][i] = one;
			for (int j = i + 1; j < n; j++) {
				m1[i][j] = mul.g(m1[i][j], d);
			}
			for (int j = 0; j < n; j++) {
				m2[i][j] = mul.g(m2[i][j], d);
			}
			for (int j = 0; j < n; j++) {
				if (i == j)
					continue;
				long mult = m1[j][i];
				m1[j][i] = zero;
				for (int k = i + 1; k < n; k++) {
					m1[j][k] = add.g(m1[j][k], add.inv(mul.g(m1[i][k], mult)));
				}
				for (int k = 0; k < n; k++) {
					m2[j][k] = add.g(m2[j][k], add.inv(mul.g(m2[i][k], mult)));
				}
			}
		}
		return UP.make(sign == 1 ? res : add.inv(res), make(m2));
	}

	static <A> Ring<MN<A>> ring(int n, Ring<A> ring) {
		return Ring.make(add(n, n, ring), mulRing(n, ring));
	}

	static <A> Field<MN<A>> field(int n, Field<A> field) {
		return Field.make(add(n, n, field), mulField(n, field));
	}

	static <A> VM<MN<A>> vm(int n, Ring<A> ring) {
		if (ring instanceof Field)
			return vmField(n, (Field<A>) ring);
		return vmRing(n, ring);
	}

	private static <A> VM<MN<A>> vmRing(int n, Ring<A> ring) {
		Ring<MN<A>> matRing = ring(n, ring);
		Monoid<MN<A>> matMul = matRing.mul();
		AbelianGroup<A> add = ring.add();
		Monoid<A> mul = ring.mul();
		A zero = add.e();
		A one = mul.e();
		return new VM<MN<A>>(matRing, null, null, (a, b) -> {
			if (b instanceof MN.Scalar) {
				MN.Scalar<A> bs = ((MN.Scalar<A>) b);
				if (bs.l < 0)
					throw new RuntimeException(""pow(MN, <0) is not defined"");
				return Alg.pow(a, bs.l, matMul);
			}
			throw new RuntimeException(""pow(MN, MN) is not defined"");
		}, null, l -> make(n, n, l, zero, Alg.pow(one, l, add)), a -> a);
	}

	private static <A> VM<MN<A>> vmField(int n, Field<A> field) {
		Field<MN<A>> matField = field(n, field);
		AbelianGroup<MN<A>> matMul = matField.mul();
		A zero = field.zero();
		A one = field.one();
		return new VM<MN<A>>(matField, (a, b) -> {
			if (b instanceof MN.Scalar) {
				MN.Scalar<A> bs = ((MN.Scalar<A>) b);
				if (bs.l < 0)
					return Alg.pow(inv(a, field), -bs.l, matMul);
				return Alg.pow(a, bs.l, matMul);
			}
			throw new RuntimeException(""pow(MN, MN) is not defined"");
		}, a -> inv(a, field), l -> make(n, n, l, zero, Alg.pow(one, l, field.add())), a -> a);
	}
}

class VM<A> {
	private final HashMap<String, A> env;
	private final Evaluator<A> etor;
	private final F.XX<A, A> filter;

	VM(F.XXX<A, A, A> add, F.XXX<A, A, A> sub, F.XXX<A, A, A> mul, F.XXX<A, A, A> div, F.XXX<A, A, A> mod,
			F.XXX<A, A, A> pow, F.XX<A, A> neg, F.XX<A, A> fact, F.LX<A> fromInt, F.XX<A, A> filter) {
		env = new HashMap<String, A>();
		etor = SimpleLang.makeEvaluator((s, a) -> {
			env.put(s, a);
			return a;
		}, add, sub, mul, div, mod, pow, neg, fact, fromInt, s -> {
			if (env.containsKey(s))
				return env.get(s);
			throw new RuntimeException(""no such variable: "" + s);
		});
		this.filter = filter;
	}

	VM(Ring<A> ring, F.XXX<A, A, A> div, F.XXX<A, A, A> mod, F.XXX<A, A, A> pow, F.XX<A, A> fact, F.LX<A> fromInt,
			F.XX<A, A> filter) {
		this(ring.add()::g, (a, b) -> ring.add().g(a, ring.add().inv(b)), ring.mul()::g, div, mod, pow, ring.add()::inv,
				fact, fromInt, filter);
	}

	VM(EuclideanRing<A> ring, F.XXX<A, A, A> pow, F.XX<A, A> fact, F.LX<A> fromInt, F.XX<A, A> filter) {
		this(ring, ring::div, ring::mod, pow, fact, fromInt, filter);
	}

	void clear() {
		env.clear();
	}

	A get(String id) {
		return env.get(id);
	}

	void print(String id, F.XV<String> printer) {
		printer.f("""" + get(id));
	}

	@SafeVarargs
	final void set(String idsSp, A... as) {
		String[] ids = idsSp.trim().split("" +"");
		int n = ids.length;
		if (as.length != n)
			throw new IllegalArgumentException(""argument size mismatch: "" + n + "" != "" + as.length);
		for (int i = 0; i < n; i++)
			set(ids[i], as[i]);
	}

	void set(String id, A a) {
		env.put(id, filter.f(a));
	}

	A run(String expr) {
		return AST.eval(SimpleLang.parse(expr), etor);
	}
}

class AST { // Abstract Syntax Tree
	static class AssignOp extends AST {
		String id;
		AST r;

		AssignOp(String id, AST r) {
			this.id = id;
			this.r = r;
		}

		public String toString() {
			return ""Assign("" + id + "", "" + r + "")"";
		}
	}

	static class Multi extends AST {
		ArrayList<AST> as;

		Multi(ArrayList<AST> as) {
			this.as = as;
		}

		public String toString() {
			String s = """";
			for (AST a : as)
				s += s.isEmpty() ? a : ""; "" + a;
			return ""Multi("" + s + "")"";
		}
	}

	static class BinOp extends AST {
		AST l;
		AST r;
		String op;

		BinOp(AST l, String op, AST r) {
			this.l = l;
			this.op = op;
			this.r = r;
		}

		public String toString() {
			return ""BinOp("" + l + "", "" + op + "", "" + r + "")"";
		}
	}

	static class UnOp extends AST {
		AST a;
		String op;

		UnOp(String op, AST a) {
			this.op = op;
			this.a = a;
		}

		public String toString() {
			return ""UnOp("" + op + "", "" + a + "")"";
		}
	}

	static class Int extends AST {
		long v;

		Int(long v) {
			this.v = v;
		}

		public String toString() {
			return ""Int("" + v + "")"";
		}
	}

	static class Id extends AST {
		String s;

		Id(String s) {
			this.s = s;
		}

		public String toString() {
			return ""Id("" + s + "")"";
		}
	}

	static <A> A eval(AST a, Evaluator<A> etor) {
		if (a instanceof AssignOp)
			return etor.assign(((AssignOp) a).id, eval(((AssignOp) a).r, etor));
		if (a instanceof Multi) {
			A last = null;
			for (AST a2 : ((Multi) a).as)
				last = eval(a2, etor);
			return last;
		}
		if (a instanceof BinOp)
			return etor.binOp(((BinOp) a).op, eval(((BinOp) a).l, etor), eval(((BinOp) a).r, etor));
		if (a instanceof UnOp)
			return etor.unOp(((UnOp) a).op, eval(((UnOp) a).a, etor));
		if (a instanceof Int)
			return etor.fromInt(((Int) a).v);
		if (a instanceof Id)
			return etor.id(((Id) a).s);
		throw new RuntimeException(""unexpected ast: "" + a);
	}
}

interface Evaluator<A> {
	A assign(String s, A a);

	A binOp(String op, A a, A b);

	A unOp(String op, A a);

	A fromInt(long a);

	A id(String s);
}

class Seq<A> {
	ArrayList<A> as;
	int ptr;

	Seq(ArrayList<A> as) {
		this.as = as;
		ptr = 0;
	}

	boolean hasNext(int num) {
		return ptr + num < as.size();
	}

	boolean hasNext() {
		return hasNext(0);
	}

	A next(int num) {
		return ptr + num < as.size() ? as.get(ptr + num) : null;
	}

	A next() {
		return next(0);
	}

	A read() {
		return hasNext() ? as.get(ptr++) : null;
	}

	A read(A a) {
		if (!hasNext())
			throw new RuntimeException(""unexpected EOF"");
		if (!isNext(a))
			throw new RuntimeException(""expected "" + a + "" but got"" + next());
		return read();
	}

	A read(F.XX<A, Boolean> f) {
		if (!hasNext())
			throw new RuntimeException(""unexpected EOF"");
		if (!f.f(next()))
			throw new RuntimeException(""f("" + next() + "") returned false"");
		return read();
	}

	boolean isNext(A a) {
		return a.equals(next());
	}

	boolean isNext(@SuppressWarnings(""unchecked"") A... as) {
		for (A a : as)
			if (isNext(a))
				return true;
		return false;
	}

	boolean isNext(F.XX<A, Boolean> f) {
		return hasNext() && f.f(next());
	}

	A readIf(F.XX<A, Boolean> f) {
		if (isNext(f))
			return read();
		return null;
	}

	A readIf(@SuppressWarnings(""unchecked"") A... as) {
		for (A a : as)
			if (isNext(a)) {
				ptr++;
				return a;
			}
		return null;
	}

	public String toString() {
		return as.toString();
	}
}

class Token extends P<String, Integer> {
	private static final int ID = 1;
	private static final int SYM = 2;
	private static final int INT = 3;

	Token(String s, int type) {
		super(s, type);
	}

	boolean is(String s) {
		return a.equals(s);
	}

	static Token ofId(String s) {
		return new Token(s, ID);
	}

	static Token ofSym(String s) {
		return new Token(s, SYM);
	}

	static Token ofInt(String s) {
		return new Token(s, INT);
	}

	boolean isId() {
		return b == ID;
	}

	boolean isSym() {
		return b == SYM;
	}

	boolean isInt() {
		return b == INT;
	}
}

class SimpleLang {
	private static class Tokenizer {
		private static final String SYMS = ""+-*/%^!()=;"";

		Seq<Character> sc;
		ArrayList<Token> ts;

		Tokenizer(String s) {
			sc = new Seq<Character>(U.make(s.length(), i -> s.charAt(i)));
		}

		Seq<Token> parse() {
			ts = new ArrayList<Token>();
			parseAll();
			return new Seq<Token>(ts);
		}

		private static boolean isSpace(char c) {
			return c == ' ' || c == '\t' || c == '\r' || c == '\n';
		}

		private static boolean isDigit(char c) {
			return c >= '0' && c <= '9';
		}

		private static boolean isSymbol(char c) {
			return SYMS.indexOf(c) != -1;
		}

		private static boolean isAlpha(char c) {
			return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c == '_';
		}

		private void parseAll() {
			while (sc.hasNext()) {
				while (sc.isNext(Tokenizer::isSpace))
					sc.read();
				if (!sc.hasNext())
					break;
				if (sc.isNext(Tokenizer::isAlpha)) {
					parseId();
				} else if (sc.isNext(Tokenizer::isDigit)) {
					parseInt();
				} else if (sc.isNext(Tokenizer::isSymbol)) {
					parseSym();
				} else {
					throw new RuntimeException(""invalid character: "" + sc.next());
				}
			}
		}

		private void parseId() {
			String s = sc.read().toString();
			while (sc.isNext(Tokenizer::isAlpha) || sc.isNext(Tokenizer::isDigit))
				s += sc.read().toString();
			ts.add(Token.ofId(s));
		}

		private void parseInt() {
			String s = sc.read().toString();
			while (sc.isNext(Tokenizer::isDigit))
				s += sc.read().toString();
			ts.add(Token.ofInt(s));
		}

		private void parseSym() {
			String s = sc.read().toString();
			ts.add(Token.ofSym(s));
		}
	}

	private static class Parser {
		Seq<Token> ts;

		Parser(Seq<Token> ts) {
			this.ts = ts;
		}

		AST parse() {
			return parseExpr();
		}

		private AST parseExpr() {
			return parseMultiExpr();
		}

		private AST parseMultiExpr() {
			readSemicolons();
			AST a = parseAssignExpr();
			if (readSemicolons()) {
				ArrayList<AST> as = new ArrayList<AST>();
				as.add(a);
				do {
					if (!ts.hasNext())
						break;
					as.add(parseAssignExpr());
				} while (readSemicolons());
				if (as.size() == 1)
					return a;
				return new AST.Multi(as);
			}
			return a;
		}

		private boolean readSemicolons() {
			if (!ts.isNext(t -> t.is("";"")))
				return false;
			do {
				ts.read();
			} while (ts.isNext(t -> t.is("";"")));
			return true;
		}

		private AST parseAssignExpr() {
			AST a = parseAddSubOp();
			if (ts.isNext(t -> t.is(""=""))) {
				ts.read();
				if (!(a instanceof AST.Id))
					throw new RuntimeException(""cannot assign to "" + a);
				return new AST.AssignOp(((AST.Id) a).s, parseAssignExpr());
			}
			return a;
		}

		private AST parseAddSubOp() {
			AST a = parseMulDivModOp();
			while (ts.isNext(t -> t.is(""+"") || t.is(""-"")))
				a = new AST.BinOp(a, ts.read().a, parseMulDivModOp());
			return a;
		}

		private AST parseMulDivModOp() {
			AST a = parsePowOp();
			while (ts.isNext(t -> t.is(""*"") || t.is(""/"") || t.is(""%"")))
				a = new AST.BinOp(a, ts.read().a, parsePowOp());
			return a;
		}

		private AST parsePowOp() {
			AST a = parseNegateOp();
			if (ts.isNext(t -> t.is(""^"")))
				return new AST.BinOp(a, ts.read().a, parsePowOp());
			return a;
		}

		private AST parseNegateOp() {
			if (ts.isNext(t -> t.is(""-"")))
				return new AST.UnOp(ts.read().a, parseNegateOp());
			return parseFactOp();
		}

		private AST parseFactOp() {
			AST a = parsePrimary();
			while (ts.isNext(t -> t.is(""!"")))
				a = new AST.UnOp(ts.read().a, a);
			return a;
		}

		private AST parsePrimary() {
			if (ts.isNext(t -> t.isId()))
				return new AST.Id(ts.read().a);
			if (ts.isNext(t -> t.isInt()))
				return new AST.Int(Long.parseLong(ts.read().a));
			if (ts.readIf(t -> t.is(""("")) != null) {
				AST e = parseExpr();
				ts.read(t -> t.is("")""));
				return e;
			}
			throw new RuntimeException(""unexpected token: "" + ts.next());
		}
	}

	static HashMap<String, AST> cache = new HashMap<String, AST>();

	static <A> Evaluator<A> makeEvaluator(F.XXX<String, A, A> assign, F.XXX<A, A, A> add, F.XXX<A, A, A> sub,
			F.XXX<A, A, A> mul, F.XXX<A, A, A> div, F.XXX<A, A, A> mod, F.XXX<A, A, A> pow, F.XX<A, A> neg,
			F.XX<A, A> fact, F.LX<A> fromInt, F.XX<String, A> id) {
		return new Evaluator<A>() {
			public A assign(String s, A a) {
				return assign.f(s, a);
			}

			public A binOp(String op, A a, A b) {
				switch (op) {
				case ""+"":
					return add.f(a, b);
				case ""-"":
					return sub.f(a, b);
				case ""*"":
					return mul.f(a, b);
				case ""/"":
					return div.f(a, b);
				case ""%"":
					return mod.f(a, b);
				case ""^"":
					return pow.f(a, b);
				}
				throw new RuntimeException(""invalid binOp: "" + op);
			}

			public A unOp(String op, A a) {
				switch (op) {
				case ""-"":
					return neg.f(a);
				case ""!"":
					return fact.f(a);
				}
				throw new RuntimeException(""invalid unOp: "" + op);
			}

			public A fromInt(long a) {
				return fromInt.f(a);
			}

			public A id(String s) {
				return id.f(s);
			}
		};
	}

	static AST parse(String s) {
		if (cache.containsKey(cache)) {
			return cache.get(s);
		}
		Tokenizer l = new Tokenizer(s);
		Seq<Token> ts = l.parse();
		Parser p = new Parser(ts);
		AST a = p.parse();
		cache.put(s, a);
		return a;
	}
}

class Mod {
	final long mod;
	final AbelianGroup<Long> add;
	final AbelianGroup<Long> mul;
	final Field<Long> field;
	final VM<Long> vm;
	private final boolean prime;
	private final HashMap<Long, Integer> logMap;
	private long[] facts;
	private long[] invs;
	private long[] invFacts;
	private long[] factors;

	Mod(long mod) {
		this.mod = mod;
		prepareFacts(0);
		prime = BigInteger.valueOf(mod).isProbablePrime(100);
		add = AbelianGroup.make((a, b) -> (a + b) % mod, a -> mod - a, 0l);
		mul = AbelianGroup.make((a, b) -> (a * b) % mod, a -> {
			if (prime)
				return pow(a, mod - 2);
			TL t = Alg.extgcd(a, mod);
			if (t.c != 1)
				throw new ArithmeticException(""inv("" + a + "") does not exist"");
			return (t.a % mod + mod) % mod;
		}, 1l);
		field = Field.make(add, mul);
		logMap = new HashMap<Long, Integer>();
		vm = new VM<Long>(field, this::pow, this::fact, a -> (a % mod + mod) % mod, a -> (a % mod + mod) % mod);
	}

	long fact(long a) {
		if (a >= Integer.MAX_VALUE)
			throw new RuntimeException(""fact("" + a + "") too big"");
		prepareFacts((int) a);
		return facts[(int) (a % mod)];
	}

	long invFact(int a) {
		prepareFacts(a);
		return invFacts[(int) (a % mod)];
	}

	long inv(long a) {
		return mul.inv(a);
	}

	long pow(long a, long b) {
		if (b == 0)
			return 1;
		if (b == 1)
			return a;
		if (b < 0) {
			a = inv(a);
			b = -b;
		}
		a %= mod;
		long res = 1;
		while (b > 0) {
			if ((b & 1) != 0)
				res = res * a % mod;
			a = a * a % mod;
			b >>= 1;
		}
		return res;
	}

	long order(long a) { // computes the order of `a` in O(sqrt(mod)) time
		a %= mod;
		if (a == 0)
			return 0;
		if (a == 1)
			return 1;
		if (factors == null) {
			ArrayList<Long> fs = new ArrayList<Long>();
			for (long i = 2; i * i < mod; i++) {
				if ((mod - 1) % i == 0)
					fs.add(i);
			}
			factors = new long[fs.size()];
			for (int i = 0; i < fs.size(); i++) {
				factors[i] = fs.get(i);
			}
		}
		for (long f : factors) {
			if (pow(a, f) == 1)
				return f;
		}
		return mod - 1;
	}

	PL log(long a, long b) { // log_b(a) in O(sqrt(mod)) time
		a %= mod;
		b %= mod;
		if (b == 1 || b == 0)
			return a == b ? PL.make(1, 1) : PL.make(-1, 0);
		if (a == 0)
			return PL.make(-1, 0);
		long order = order(b);
		if (a == 1)
			return PL.make(0, order);
		long orderSqrtL = sqrtCeil(order);
		if (orderSqrtL > Integer.MAX_VALUE)
			throw new RuntimeException(""order("" + b + "") too big: "" + order);
		int orderSqrt = (int) sqrtCeil(order);
		logMap.clear();
		logMap.put(1l, 0);
		long p = 1;
		for (int i = 1; i < orderSqrt; i++) {
			p = p * b % mod;
			logMap.put(p, i);
		}
		long ib = pow(b, mod - orderSqrt - 1);
		p = a;
		for (int i = 1; i < orderSqrt; i++) {
			p = p * ib % mod;
			if (logMap.containsKey(p))
				return PL.make((i * orderSqrt + logMap.get(p)) % order, order);
		}
		return PL.make(-1, 0);
	}

	private long sqrtCeil(long a) {
		return U.searchL((long) Math.sqrt(a * 0.9), (long) Math.sqrt(a * 1.1) + 1, mid -> mid * mid >= a);
	}

	private void prepareFacts(int n) {
		if (facts == null) {
			facts = new long[1024];
			invs = new long[1024];
			invFacts = new long[1024];
			prepareFactsIn(0, 1024);
		}
		if (n >= mod)
			n = (int) (mod - 1);
		while (facts.length <= n) {
			int prevL = facts.length;
			int newL = prevL << 1;
			facts = Arrays.copyOf(facts, newL);
			invs = Arrays.copyOf(invs, newL);
			invFacts = Arrays.copyOf(invFacts, newL);
			prepareFactsIn(prevL, newL);
		}
	}

	private void prepareFactsIn(int from, int until) {
		if (until > mod)
			until = (int) mod;
		for (int i = from; i < until; i++) {
			if (i == 0) {
				facts[0] = 1;
				invs[0] = 0;
				invFacts[0] = 1;
				continue;
			}
			if (i == 1) {
				facts[1] = 1;
				invs[1] = 1;
				invFacts[1] = 1;
				continue;
			}
			facts[i] = facts[i - 1] * i % mod;
			invs[i] = (mod - mod / i) * invs[(int) (mod % i)] % mod;
			invFacts[i] = invFacts[i - 1] * invs[i] % mod;
		}
	}
}
"
147,"import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Scanner;

public class  Main {
	static ArrayList<List<Integer>>[] questions;
	static int N;
	static DJSet ds;
	static String[] ans;

	@SuppressWarnings(""unchecked"")
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);

		N = sc.nextInt();

		int k = sc.nextInt();

		questions = new ArrayList[k];
		ans = new String[k];
		ArrayList<List<Integer>> operations = new ArrayList<>();
		Map<List<Integer>, Integer> cnt = new HashMap<>();
		for (int i = 0; i < k; ++i) {
			questions[i] = new ArrayList<>();
		}
		for (int i = 0; i < k; ++i) {
			int type = sc.nextInt();
			int u = sc.nextInt();
			int v = sc.nextInt();

			if (type == 3) {
				questions[i].add(Arrays.asList(u, v));
			} else if (type == 1) {
				cnt.put(Arrays.asList(u, v), i);
			} else if (type == 2) {
				operations.add(Arrays.asList(u, v, cnt.get(Arrays.asList(u, v)), i));
				cnt.put(Arrays.asList(u, v), -1);
			} else {
				throw new AssertionError();
			}
		}

		SegTree seg = new SegTree(k);
		for (Entry<List<Integer>, Integer> entry : cnt.entrySet()) {
			int t = entry.getValue();
			if (t >= 0) {
				int u = entry.getKey().get(0);
				int v = entry.getKey().get(1);
				operations.add(Arrays.asList(u, v, t, seg.n));
			}
		}
		ds = new DJSet(N);
		for (List<Integer> op : operations) {
			seg.update(op.get(2), op.get(3), new Edge(op.get(0), op.get(1)));
		}

		seg.dfs(0);

		for (String out : ans) {
			if (out != null) {
				System.out.println(out);
			}
		}

	}

	static class SegTree {
		int n = 1;
		ArrayList<Edge>[] edges;

		@SuppressWarnings(""unchecked"")
		public SegTree(int n_) {
			while (n < n_) {
				n *= 2;
			}
			edges = new ArrayList[2 * n - 1];
			for (int i = 0; i < 2 * n - 1; ++i) {
				edges[i] = new ArrayList<>();
			}
		}

		void update(int a, int b, Edge e) {
			update(a, b, 0, n, 0, e);
		}

		// [a,b),[l,r)
		void update(int a, int b, int l, int r, int k, Edge e) {
			if (a >= r || b <= l) {
				return;
			} else if (a <= l && r <= b && (n<=1000||(n > 1000 && k >= 1000))) {
				edges[k].add(e);
				return;
			} else {
				update(a, b, l, (l + r) / 2, 2 * k + 1, e);
				update(a, b, (l + r) / 2, r, 2 * k + 2, e);// 30000*30000=9*10^8
				return;
			}
		}

		void dfs(int k) {
			if (k >= 2 * n - 1)
				return;
			for (Edge e : edges[k]) {
				ds.setUnion(e.src, e.dst);
			}
			if (k < n - 1) {
				dfs(2 * k + 1);
				dfs(2 * k + 2);
			} else if (k >= n - 1) {
				int pos = k - (n - 1);
				if (pos < questions.length)
					for (List<Integer> q : questions[pos]) {
						if (ds.equiv(q.get(0), q.get(1))) {
							ans[pos] = ""YES"";
						} else {
							ans[pos] = ""NO"";
						}
					}
			}

			for (Edge e : edges[k]) {
				ds.undo();
			}
		}

	}

	static class DJSet {
		int n;
		int[] upper;
		ArrayDeque<List<Integer>> cmds = new ArrayDeque<>();

		public DJSet(int n) {
			this.n = n;
			upper = new int[n];
			Arrays.fill(upper, -1);
		}

		int root(int x) {
			return upper[x] < 0 ? x : (upper[x] = root(upper[x]));
		}

		boolean equiv(int x, int y) {
			return root(x) == root(y);
		}

		boolean setUnion(int x, int y) {
			x = root(x);
			y = root(y);
			cmds.addFirst(Arrays.asList(x, upper[x]));
			cmds.addFirst(Arrays.asList(y, upper[y]));
			if (x != y) {
				if (upper[x] > upper[y]) {
					int d = x;
					x = y;
					y = d;
				}
				upper[x] += upper[y];
				upper[y] = x;
			}
			return x != y;
		}

		boolean undo() {
			if (cmds.isEmpty())
				throw new AssertionError();
			else {
				List<Integer> y = cmds.pollFirst();
				List<Integer> x = cmds.pollFirst();
				upper[y.get(0)] = y.get(1);
				upper[x.get(0)] = x.get(1);
				return true;
			}
		}
	}

	static class Edge {
		int src;
		int dst;

		public Edge(int src, int dst) {
			this.src = src;
			this.dst = dst;
		}
	}
}"
148,"import java.util.Scanner;

class Main
{
	public static void main(String[] args)
	{
		Scanner sc = new Scanner(System.in);
		String[] str = sc.nextLine().split("" "");
		int a = Integer.parseInt(str[0]);
		int b = Integer.parseInt(str[2]);
		String op = str[1];
		
		while (sc.hasNextLine())
		{
			if (op == ""+"")
			{
				System.out.println(a + b);
				return;
			}
			else if (op == ""-"")
			{
				System.out.println(a - b);
				return;
			}
			else if (op == ""*"")
			{
				System.out.println(a * b);
				return;
			}
			else if (op == ""/"")
			{
				System.out.println(a / b);
				return;
			}
			else if (op == ""?"")
			{
				break;
			}
		}
	}
}"
149,"import java.util.*;
import java.io.*;

public class Main {
  public static void main (String[] args) {
    Scanner sc = new Scanner(System.in);

    int h = sc.nextInt();
    int w = sc.nextInt();
    int a = sc.nextInt();
    int b = sc.nextInt();

    for (int i = 1; i <= h; i++) {
      for (int j = 1; j <= w; j++) {
        if (i <= b ) {
          if (j <= a) {
            System.out.print(""0"");
          } else {
            System.out.print(""1"");
          }
        } else {
          if (j <= a) {
            System.out.print(""1"");
          } else {
            System.out.print(""0"");
          }
        }
      }
      System.out.println("""");
    }

  }
}"
150,"import java.util.*;
public class program{
  public static void main(String[] args){
    Scanner scn = new Scanner(System.in);
    Map<Integer,Integer> map = new HashMap<Integer,Integer>();
    int n = scn.nextInt();
    int []arr = new int[n];
    for(int i=1;i<n;i++){
      arr[i] = scn.nextInt();
    }
    for(int i=1;i<arr.length;i++){
      if(map.containsKey(arr[i])){
        int val = map.get(arr[i]) + 1;
        map.put(arr[i],val);
      }else{
        map.put(arr[i],1);
      } 
 }
  for(int i=1;i<arr.length;i++){
    int val = map.get(arr[i]);
    System.out.println(val);
  }
    
    
  
  
  
  
  
  
  
  
  
  
  
  }
  
}
  
  
  
  
  
  
"
151,"import java.util.Scanner;

public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int max=-1000000000,res,min,num;
        int n=sc.nextInt();
        for(int i=1;i<n;i++){
            num=sc.nextInt();
            if(i==0){
                min=num;
            }else{
                res=num-min;
                if(res>max){
                    max=res;
                }
                if(min>num){
                    min=num;
                }
            }
        }
        System.out.println(max);
    }
}
"
152,"import java.math.BigInteger;
import java.util.Scanner;

public class Main {

	static Scanner sc = new Scanner(System.in);
	static int M;
	static int[] mm;
	static int MOD = 10000;

	static boolean check(char[] s) {
		if (s.length == 1) return true;
		if (s[0] == s[1]) return false;
		boolean top = s[0] < s[1];
		for (int i = 1; i < s.length - 1; ++i) {
			if (s[i] == s[i + 1]) return false;
			boolean expect = top ^ (i % 2 != 0);
			if (expect != s[i] < s[i + 1]) return false;
		}
		return true;
	}

	static int naive(int min, int max) {
		int ret = 0;
		for (int i = min; i <= max; ++i) {
			if (i % M != 0) continue;
			char[] a = Integer.toString(i).toCharArray();
			if (check(a)) ++ret;
		}
		return ret;
	}

	static int solve(String upper) {
//		System.out.println(""upper:"" + upper);
		int L = upper.length();
		int ret = 1;
		if (L <= 2) {
			int u = Integer.parseInt(upper);
			for (int i = 1; i <= u; ++i) {
				if (i % 11 == 0 || i % M != 0) continue;
				++ret;
			}
			return ret;
		}
		for (int i = 1; i <= 99; ++i) {
			if (i % 11 == 0 || i % M != 0) continue;
			++ret;
		}
		int[] d = new int[L];
		for (int i = 0; i < L; ++i) {
			d[i] = upper.charAt(i) - '0';
		}
		int[][][][] dp = new int[2][L][M][10];
		for (int i = 0; i <= 9; ++i) {
			dp[0][0][i % M][i] += 1;
			dp[1][0][i % M][i] += 1;
		}
		for (int i = 1; i < L - 1; ++i) {
			for (int j = 0; j <= 9; ++j) {
				for (int k = 0; k < j; ++k) {
					for (int l = 0; l < M; ++l) {
						dp[0][i][(l + k * mm[i]) % M][k] += dp[1][i - 1][l][j];
						if (dp[0][i][(l + k * mm[i]) % M][k] >= MOD) dp[0][i][(l + k * mm[i]) % M][k] -= MOD;
					}
				}
				for (int k = j + 1; k <= 9; ++k) {
					for (int l = 0; l < M; ++l) {
						dp[1][i][(l + k * mm[i]) % M][k] += dp[0][i - 1][l][j];
						if (dp[1][i][(l + k * mm[i]) % M][k] >= MOD) dp[1][i][(l + k * mm[i]) % M][k] -= MOD;
					}
				}
			}
			if (i >= 2) {
				for (int j = 1; j <= 9; ++j) {
					ret += dp[0][i][0][j] + dp[1][i][0][j];
				}
			}
			ret %= MOD;
		}
//		System.out.println(ret);
		for (int j = 0; j <= 9; ++j) {
			for (int k = 0; k < j && k < d[0]; ++k) {
				for (int l = 0; l < M; ++l) {
					dp[0][L - 1][(l + k * mm[L - 1]) % M][k] += dp[1][L - 2][l][j];
					if (dp[0][L - 1][(l + k * mm[L - 1]) % M][k] >= MOD) dp[0][L - 1][(l + k * mm[L - 1]) % M][k] -= MOD;
				}
			}
			for (int k = j + 1; k <= 9 && k < d[0]; ++k) {
				for (int l = 0; l < M; ++l) {
					dp[1][L - 1][(l + k * mm[L - 1]) % M][k] += dp[0][L - 2][l][j];
					if (dp[1][L - 1][(l + k * mm[L - 1]) % M][k] >= MOD) dp[1][L - 1][(l + k * mm[L - 1]) % M][k] -= MOD;
				}
			}
		}
		for (int j = 1; j < d[0]; ++j) {
			ret += dp[0][L - 1][0][j] + dp[1][L - 1][0][j];
			//			System.out.println(j + "" "" + dp[0][L - 1][0][j] + "" "" + dp[1][L - 1][0][j]);
		}
//		System.out.println(ret);
		ret %= MOD;

		int mmSur = d[0] * mm[L - 1] % M;
		for (int i = 0; i < Math.min(d[0], d[1]); ++i) {
			ret += dp[0][L - 2][(M - mmSur) % M][i];
		}
		for (int i = d[0] + 1; i < d[1]; ++i) {
			ret += dp[1][L - 2][(M - mmSur) % M][i];
		}
		//		System.out.println(ret);
		if (d[0] != d[1]) {
			boolean top = d[0] > d[1];
			mmSur = (mmSur + d[1] * mm[L - 2]) % M;
			if (top) {
				for (int i = d[1] + 1; i < d[2]; ++i) {
					ret += dp[1][L - 3][(M - mmSur) % M][i];
				}
			} else {
				for (int i = 0; i < Math.min(d[1], d[2]); ++i) {
					ret += dp[0][L - 3][(M - mmSur) % M][i];
				}
			}
			for (int i = 2; i < L; ++i) {
				if (d[i] == d[i - 1]) break;
				mmSur = (mmSur + d[i] * mm[L - 1 - i]) % M;
				boolean expect = top;
				expect ^= i % 2 == 0;
				boolean actual = d[i - 1] > d[i];
//				System.out.println(i + "" "" + expect + "" "" + actual);
				if (expect != actual) break;
				if (i == L - 1) {
					if (mmSur == 0) ++ret;
					break;
				}
				if (actual) {
					for (int j = d[i] + 1; j < d[i + 1]; ++j) {
						ret += dp[1][L - (i + 2)][(M - mmSur) % M][j];
					}
				} else {
					for (int j = 0; j < Math.min(d[i], d[i + 1]); ++j) {
						ret += dp[0][L - (i + 2)][(M - mmSur) % M][j];
					}
				}
//				System.out.println(ret);
			}
		}
		ret %= MOD;
//		System.out.println(ret);
		return ret;
	}

	public static void main(String[] args) {
		String A = sc.next();
		String B = sc.next();
		M = sc.nextInt();
//		System.out.println(naive(0, Integer.parseInt(A) - 1));
//		System.out.println(naive(0, Integer.parseInt(B)));
		mm = new int[B.length()];
		mm[0] = 1 % M;
		for (int i = 1; i < mm.length; ++i) {
			mm[i] = mm[i - 1] * 10 % M;
		}
		int nb = solve(B);
		int na = solve(new BigInteger(A).subtract(BigInteger.ONE).toString());
		System.out.println((nb - na + MOD) % MOD);
	}
}"
153,"import java.util.ArrayList;
import java.util.Scanner;

public class Main {
    static int n;
    static ArrayList<Circle> circles;
    static int max;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while (true) {
            n = sc.nextInt();
            if (n == 0) {
                break;
            }
            circles = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                int x = sc.nextInt();
                int y = sc.nextInt();
                int r = sc.nextInt();
                int c = sc.nextInt();
                circles.add(new Circle(x, y, r, c, i));
            }
            for (int i = 0; i < n - 1; i++) {
                for (int j = i + 1; j < n; j++) {
                    Circle c1 = circles.get(i);
                    Circle c2 = circles.get(j);
                    if (c1.dip(c2)) {
                        c1.children.add(c2);
                        c2.parents.add(c1);
                    }
                }
            }
            max = Integer.MIN_VALUE;
            dp(0);
            System.out.println(max * 2);
        }
    }

    static void dp(int k) {
        max = Math.max(max, k);

        ArrayList<Circle> tops = new ArrayList<>();
        for (Circle c: circles) {
            if (c.parents.isEmpty()) {
                tops.add(c);
            }
        }

        for (int i = 1; i <= 4; i++) {
            ArrayList<Circle> items = new ArrayList<>();
            for (Circle c: tops) {
                if (c.c == i) {
                    items.add(c);
                }
            }

            if (items.size() < 2) {
                continue;
            }
            // TODO: sum6 ?????????

            for (int j = 0; j < items.size() - 1; j++) {
                for (int l = j + 1; l < items.size(); l++) {
                    Circle c1 = items.get(j);
                    Circle c2 = items.get(l);
                    circles.remove(c1);
                    circles.remove(c2);
                    for (Circle c: c1.children) {
                        c.parents.remove(c1);
                    }
                    for (Circle c: c2.children) {
                        c.parents.remove(c2);
                    }
                    dp(k + 1);
                    circles.add(c1);
                    circles.add(c2);
                    for (Circle c: c1.children) {
                        c.parents.add(c1);
                    }
                    for (Circle c: c2.children) {
                        c.parents.add(c2);
                    }
                }
            }
        }
    }

    static class Circle {
        int x, y, r, c, id;
        ArrayList<Circle> parents;
        ArrayList<Circle> children;
        Circle (int x, int y, int r, int c, int id) {
            this.x = x;
            this.y = y;
            this.r = r;
            this.c = c;
            this.id = id;
            parents = new ArrayList<>();
            children = new ArrayList<>();
        }

        public boolean dip(Circle c) {
            return Math.pow(this.r + c.r, 2) > Math.pow(this.x - c.x, 2) + Math.pow(this.y - c.y, 2);
        }

    }
}"
154,"import static java.lang.System.*;
import java.util.*;

class UnionFind {
    int[] par;

    UnionFind(int n) { 
    	par = new int[n];
        for(int i = 0; i < n; i++) par[i] = i;
    }

    int root(int x) {
        if (par[x] == x) return x;
        return par[x] = root(par[x]);
    }

    void unite(int x, int y) {
        int rx = root(x); 
        int ry = root(y);
        if (rx == ry) return; 
        
        par[rx] = ry;
    }

    boolean same(int x, int y) {
        int rx = root(x);
        int ry = root(y);
        return rx == ry;
    }
};

public class Main {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		Scanner sc = new Scanner(in);
		
		int n = sc.nextInt();
		int m = sc.nextInt();
		UnionFind uf = new UnionFind(n);

		int[] a = new int[m];
		int[] b = new int[m];
		for(int i=0; i<m; i++) {
			a[m-i-1] = sc.nextInt()-1;
			b[m-i-1] = sc.nextInt()-1;
		}
		
		long[] ans = new long[m];
		ans[0] = n*(n-1)/2;
		
		for(int i=0; i<m-1; i++) {
			if(uf.same(a[i], b[i])) ans[i+1] = ans[i];
			else {
				int ar = uf.root(a[i]);
				int br = uf.root(b[i]);
				long ac = 0, bc = 0;
				for(int j=0; j<n; j++) {
					if(uf.root(j) == ar) ac++;
					else if(uf.root(j) == br) bc++;
				}
				ans[i+1] = ans[i] - ac * bc;
				uf.unite(a[i], b[i]);
			}
		}

		for(int i=0; i<m; i++) {
			out.println(ans[m-i-1]); 
		}
	}

}
"
155,"import java.io.*;
import java.util.*;
 
 
public class Main implements Runnable {
 
  public void run() {
    BetterScanner scanner = new BetterScanner(System.in);
    int n = scanner.nextInt();
    int m = scanner.nextInt();
 
    List<IntWrapper>[] conn = new List[n];
    List<IntWrapper>[] diff = new List[n];
 
    for (int i = 0 ; i < m ; i ++) {
      int l = scanner.nextInt() - 1;
      int r = scanner.nextInt() - 1;
      int d = scanner.nextInt();
      if (conn[l] == null) {
        conn[l] = new ArrayList();
        diff[l] = new ArrayList();
      }
      conn[l].add(new IntWrapper(r));
      diff[l].add(new IntWrapper(d));
      if (conn[r] == null) {
        conn[r] = new ArrayList();
        diff[r] = new ArrayList();
      }
      conn[r].add(new IntWrapper(l));
      diff[r].add(new IntWrapper(-d));
    }
 
    boolean[] visited = new boolean[n];
    int[] x = new int[n];
 
    for (int first = 0 ; first < n ; first ++) {
      if (visited[first]) {
        continue;
      }
      IntQueue queue = new IntQueue(n);
      visited[first] = true;
      x[first] = 0;
      queue.offer(first);
      while (!queue.isEmpty()) {
        int u = queue.poll();
        for (int i = 0 ; conn[u] != null && i < conn[u].size() ; i ++) {
          int v = conn[u].get(i).value;
          int d = diff[u].get(i).value;
          if (!visited[v]) {
            visited[v] = true;
            x[v] = x[u] + d;
            queue.offer(v);
          } else if (x[v] != x[u] + d) {
            System.out.println(""No"");
            return;
          }
        }
      }
    }
    System.out.println(""Yes"");
    return;
  }
 
  public static void main(String[] args) {
    Main main = new Main();
    main.run();
  }

  public static class IntWrapper {

    public int value;

    public IntWrapper(int value) {
      this.value = value;
    }

  }
 
  // lightweight queue for int
  public static class IntQueue {
 
    private int[] array;
    private int head, tail;
 
    public IntQueue(int max) {
      array = new int[max];
    }
 
    public void offer(int x) {
      array[tail ++] = x;
    }
 
    public int poll() {
      return array[head ++];
    }
    
    public boolean isEmpty() {
      return head == tail;
    }
 
  }
 
  // scanner slightly faster than usual ones
  public static class BetterScanner {
 
    private InputStream stream;
    private byte[] buffer = new byte[1024];
    private int pointer = 0;
    private int bufferLength = 0;
 
    public BetterScanner(InputStream stream) {
      this.stream = stream;
    }
 
    private boolean updateBuffer() {
      if (pointer >= bufferLength) {
        pointer = 0;
        try {
          bufferLength = stream.read(buffer);
        } catch (IOException exception) {
          exception.printStackTrace();
        }
        return bufferLength > 0;
      } else {
        return true;
      }
    }
 
    private int read() {
      if (updateBuffer()) {
        return buffer[pointer ++];
      } else {
        return -1;
      }
    }
 
    public boolean hasNext() {
      skipUnprintable();
      return updateBuffer();
    }
 
    private void skipUnprintable() { 
      while (updateBuffer() && !isPrintableChar(buffer[pointer])) {
        pointer ++;
      }
    }
 
    public String next() {
      if (hasNext()) {
        StringBuilder builder = new StringBuilder();
        int codePoint = read();
        while (isPrintableChar(codePoint)) {
          builder.appendCodePoint(codePoint);
          codePoint = read();
        }
        return builder.toString();
      } else {
        throw new NoSuchElementException();
      }
    }
 
    public long nextLong() {
      if (hasNext()) {
        long number = 0;
        boolean minus = false;
        int codePoint = read();
        if (codePoint == '-') {
          minus = true;
          codePoint = read();
        }
        if (codePoint >= '0' && codePoint <= '9') {
          while (true) {
            if (codePoint >= '0' && codePoint <= '9') {
              number *= 10;
              number += codePoint - '0';
            } else if (codePoint < 0 || !isPrintableChar(codePoint)) {
              return (minus) ? -number : number;
            } else {
              throw new NumberFormatException();
            }
            codePoint = read();
          }
        } else {
          throw new NumberFormatException();
        }
      } else {
        throw new NoSuchElementException();
      }
    }
 
    public int nextInt() {
      long number = nextLong();
      if (number >= Integer.MIN_VALUE && number <= Integer.MAX_VALUE) {
        return (int)number;
      } else {
        throw new NumberFormatException();
      }
    }
 
    private boolean isPrintableChar(int codePoint) {
      return codePoint >= 33 && codePoint <= 126;
    }
 
  }
 
}"
156,"import java.util.*;

class Main
{
  public static void main(String[] args)
  {
    Scanner sc = new Scanner(System.in);
    String s = sc.next();

    char[] ch = new char[s.length()];
    int count = 0;

    for(int i=0; i<s.length(); i++){
       ch[i] = s.charAt(i);
    }

    int a =(s.length())%2;

    if(a == 0){
       for(int j=0; j<(s.length())/2; j++){
          if(ch[j] != ch[s.length()-j]){
             count++;
          }else{
             continue;
          }
       }
    }

    else if(a != 0){
       for(int j=0; j<(s.length()-1)/2; j++){
          if(ch[j] != ch[s.length()-j]){
             count++;
          }else{
             continue;
          }
       }
    }
    System.out.println(count);
  }
}
"
157,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] list = new int[n];
        int[] result = new int[n];
        for (int i = 0; i < n; i++) {
            list[i] = sc.nextInt();
        }
        countingSort(list, result, n);
        String[] answer = new String[n];
        for (int i = 0; i < n; i++) {
            answer[i] = String.valueOf(result[i]);
        }
        System.out.println(String.join("" "", answer));
        sc.close();
    }

    static void countingSort(int[] a, int[] b, int n) {
        int k = 10001;
        int[] c = new int[k];
        for (int i = 0; i < n; i++) {
            c[a[i]]++;
        }
        for (int i = 1; i < k; i++) {
            c[i] += c[i - 1];
        }
        for (int i = 0; i < n; i++) {
            c[a[i]]--;
            b[c[a[i]]] = a[i];
        }
    }
}"
158,"import java.io.*;
import java.util.*;
import java.math.*;
// import java.awt.Point;
 
public class Main {
    InputStream is;
    PrintWriter out;
    String INPUT = """";
 
    long MOD = 1_000_000_007;
    int inf = Integer.MAX_VALUE;

    void solve(){
        int n = ni();
        int m = ni();
        Dijkstra dijkstra = new Dijkstra((m+n)*2);
        TreeMap<Long, Integer> reindex= new TreeMap<>();
        long res = 0;
        for(int i = 0; i < m; i++){
            long p = nl();
            long q = nl();
            long c = nl();
            long from = (p<<32)+c;
            long to = (q<<32)+c;
            long fromout = (p<<32)-1;
            long toout = (q<<32)-1;
            if(!reindex.containsKey(fromout))reindex.put(fromout, reindex.size());
            if(!reindex.containsKey(toout)) reindex.put(toout, reindex.size());
            if(!reindex.containsKey(from)){
                reindex.put(from, reindex.size());
                dijkstra.addDirectedEdge(reindex.get(from), reindex.get(fromout), 0);
                dijkstra.addDirectedEdge(reindex.get(fromout), reindex.get(from), 1);
                res+=2;
            }
            if(!reindex.containsKey(to)){
                reindex.put(to, reindex.size());
                dijkstra.addDirectedEdge(reindex.get(to), reindex.get(toout), 0);
                dijkstra.addDirectedEdge(reindex.get(toout), reindex.get(to), 1);
                res+=2;
            }
            dijkstra.addDirectedEdge(reindex.get(from), reindex.get(to), 0);
            dijkstra.addDirectedEdge(reindex.get(to), reindex.get(from), 0);
            res+=2;
        }
        // out.println(reindex.size());
        // out.println(res);
        long start = (1l<<32) - 1;
        long goal = ((long)n<<32) - 1;
        if(!reindex.containsKey(start) || !reindex.containsKey(goal)){
            out.println(-1);
            return;
        }
        long[] dist = dijkstra.getDist(reindex.get(start));
        long ans = dist[reindex.get(goal)];
        if(ans == Long.MAX_VALUE / 3){
            out.println(-1);
            return;
        }
        out.println(ans);
    }

    static class Dijkstra {
        int n;
        ArrayList<Pair>[] G;
        long INF = Long.MAX_VALUE / 3;

        public Dijkstra(int n) {
            this.n = n;
            G = new ArrayList[n];
            for (int i = 0; i < n; i++) {
                G[i] = new ArrayList<>();
            }
        }

        public void addDirectedEdge(int from, int to, int cost) {
            G[from].add(new Pair(to, cost));
        }

        public long[] getDist(int s) {
            PriorityQueue<Pair> Q = new PriorityQueue<>();
            Q.add(new Pair(s, 0));
            long[] dist = new long[n];
            Arrays.fill(dist, INF);
            boolean[] used = new boolean[n];
            while (!Q.isEmpty()) {
                Pair p = Q.poll();
                if (used[p.x]) continue;
                used[p.x] = true;
                dist[p.x] = p.y;

                for (Pair edge : G[p.x]) {
                    Q.add(new Pair(edge.x, p.y + edge.y));
                }
            }
            return dist;
        }

        class Pair implements Comparable<Pair> {
            int x;
            long y;

            Pair(int x, long y) {
                this.x = x;
                this.y = y;
            }

            public int compareTo(Pair p) {
                return Long.compare(y, p.y);
            }

        }

    }

    void run() throws Exception
    {
        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
        out = new PrintWriter(System.out);
        
        long s = System.currentTimeMillis();
        solve();
        out.flush();
        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+""ms"");
    }
    
    public static void main(String[] args) throws Exception { new Main().run(); }
    
    private byte[] inbuf = new byte[1024];
    private int lenbuf = 0, ptrbuf = 0;
    
    private int readByte()
    {
        if(lenbuf == -1)throw new InputMismatchException();
        if(ptrbuf >= lenbuf){
            ptrbuf = 0;
            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
            if(lenbuf <= 0)return -1;
        }
        return inbuf[ptrbuf++];
    }
    
    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }
    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }
    
    private double nd() { return Double.parseDouble(ns()); }
    private char nc() { return (char)skip(); }
    
    private String ns()
    {
        int b = skip();
        StringBuilder sb = new StringBuilder();
        while(!(isSpaceChar(b) && b != ' ')){
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
    
    private char[] ns(int n)
    {
        char[] buf = new char[n];
        int b = skip(), p = 0;
        while(p < n && !(isSpaceChar(b))){
            buf[p++] = (char)b;
            b = readByte();
        }
        return n == p ? buf : Arrays.copyOf(buf, p);
    }
    
    private char[][] nm(int n, int m)
    {
        char[][] map = new char[n][];
        for(int i = 0;i < n;i++)map[i] = ns(m);
        return map;
    }
    
    private int[] na(int n)
    {
        int[] a = new int[n];
        for(int i = 0;i < n;i++)a[i] = ni();
        return a;
    }
    
    private int ni()
    {
        int num = 0, b;
        boolean minus = false;
        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
        if(b == '-'){
            minus = true;
            b = readByte();
        }
        
        while(true){
            if(b >= '0' && b <= '9'){
                num = num * 10 + (b - '0');
            }else{
                return minus ? -num : num;
            }
            b = readByte();
        }
    }
    
    private long nl()
    {
        long num = 0;
        int b;
        boolean minus = false;
        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
        if(b == '-'){
            minus = true;
            b = readByte();
        }
        
        while(true){
            if(b >= '0' && b <= '9'){
                num = num * 10 + (b - '0');
            }else{
                return minus ? -num : num;
            }
            b = readByte();
        }
    }
    
    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }
 
}"
159,"import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class Main {

  public static void main(String[] args) {
    final Scanner scanner = new Scanner(System.in);

    scanner.nextLine();
    final int[] a = Arrays.stream(scanner.nextLine().split("" ""))
        .mapToInt(Integer::parseInt)
        .toArray();
    Map<Integer, Long> counts = new HashMap<>();
    long sum = 0;
    for (int i = 0; i < a.length; i++) {
      counts.put(
          a[i],
          counts.getOrDefault(a[i], 0L) + 1
      );
      sum += a[i];
    }

    final int q = scanner.nextInt();
    scanner.nextLine();
    final int[][] bc = new int[q][2];

    for (int i = 0; i < q; i++) {
      bc[i][0] = scanner.nextInt();
      bc[i][1] = scanner.nextInt();
      scanner.nextLine();

      final long replaceCount = counts.getOrDefault(bc[i][0], 0L);
      counts.put(
          bc[i][1],
          counts.getOrDefault(bc[i][1], 0L) + replaceCount
      );
      counts.remove(bc[i][0]);

      sum += replaceCount * (bc[i][1] - bc[i][0]);

      System.out.println(sum);
    }
  }
}
"
160,"import java.io.*;
  
public class Main {
    public static void main(String[] args) throws Exception{
        BufferedReader read = new BufferedReader(new java.io.InputStreamReader(System.in));
        int a = Integer.parseInt(read.readLine());
        int b = Integer.parseInt(read.readLine());
        System.out.println(a*b+"" ""+(a*b)*2);
    }
}"
161,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();
        int q = sc.nextInt();
        String s = sc.next();
        char[] arr = s.toCharArray();

        int[][] lr = new int[q][2];
        for (int i=0; i<q; i++) {
            lr[i][0] = sc.nextInt()-1;
            lr[i][1] = sc.nextInt()-1;
        }

        int[] flag = new int[n+1];

        for (int i=0; i<n-1; i++){
            if (arr[i]=='A'){
                if (arr[i+1]=='C'){
                    flag[i+1] = 1;
                }
            }
        }

        int[] cnt = new int[n+2];
        for (int i=0; i<n; i++){
            cnt[i+1] = cnt[i]+flag[i];
        }

//        for (int i=0; i<n+1; i++)System.out.print(cnt[i]);

        StringBuilder sb = new StringBuilder();

        for (int i=0; i<q; i++){
            int l = lr[i][0];
            int r = lr[i][1];

            sb.append((cnt[r+1]-cnt[l+1])+""\n"");
        }

        System.out.println(sb.toString());

    }
}
"
162,"import java.util.Scanner;

public class aoj0004 {
	public static void main(String[] args)
	{
		Scanner sc = new Scanner(System.in);
		while(sc.hasNext()){
			double a = sc.nextDouble();
			double b = sc.nextDouble();
			double c = sc.nextDouble();
			double d = sc.nextDouble();
			double e = sc.nextDouble();
			double f = sc.nextDouble();
					   b = b*d;
					   c = c*d;
					   e = e*a;
					   f = f*a;

					double y = (c-f)/(b-e);
					double x = (c-(b*y))/(a*d);
					if(x>0)x = (double)((int)((x * 1000)+0.5))/1000;
					if(x<0)x = (double)((int)((x * 1000)-0.5))/1000;
					if(y>0)y = (double)((int)((y * 1000)+0.5))/1000;
					if(y<0)y = (double)((int)((y * 1000)-0.5))/1000;
					if(x==-0.0)x=0.0;
					if(y==-0.0)y=0.0;
			System.out.println(x +"" ""+ y);
		}
	}
}"
163,"import java.util.*;
import java.io.*;
public class Main {
    static class Scan {
        private byte[] buf=new byte[1024];
        private int index;
        private InputStream in;
        private int total;
        public Scan()
        {
            in=System.in;
        }
        public int scan()throws IOException
        {
            if(total<0)
            throw new InputMismatchException();
            if(index>=total)
            {
                index=0;
                total=in.read(buf);
                if(total<=0)
                return -1;
            }
            return buf[index++];
        }
        public int scanInt()throws IOException
        {
            int integer=0;
            int n=scan();
            while(isWhiteSpace(n))
            n=scan();
            int neg=1;
            if(n=='-')
            {
                neg=-1;
                n=scan();
            }
            while(!isWhiteSpace(n))
            {
                if(n>='0'&&n<='9')
                {
                    integer*=10;
                    integer+=n-'0';
                    n=scan();
                }
                else throw new InputMismatchException();
            }
            return neg*integer;
        }
        public double scanDouble()throws IOException
        {
            double doub=0;
            int n=scan();
            while(isWhiteSpace(n))
            n=scan();
            int neg=1;
            if(n=='-')
            {
                neg=-1;
                n=scan();
            }
            while(!isWhiteSpace(n)&&n!='.')
            {
                if(n>='0'&&n<='9')
                {
                    doub*=10;
                    doub+=n-'0';
                    n=scan();
                }
                else throw new InputMismatchException();
            }
            if(n=='.')
            {
                n=scan();
                double temp=1;
                while(!isWhiteSpace(n))
                {
                    if(n>='0'&&n<='9')
                    {
                        temp/=10;
                        doub+=(n-'0')*temp;
                        n=scan();
                    }
                    else throw new InputMismatchException();
                }
            }
            return doub*neg;
        }
        public String scanString()throws IOException
        {
            StringBuilder sb=new StringBuilder();
            int n=scan();
            while(isWhiteSpace(n))
            n=scan();
            while(!isWhiteSpace(n))
            {
                sb.append((char)n);
                n=scan();
            }
            return sb.toString();
        }
        private boolean isWhiteSpace(int n)
        {
            if(n==' '||n=='\n'||n=='\r'||n=='\t'||n==-1)
            return true;
            return false;
        }
    }
    public static void main(String args[]) throws IOException {
        Scan input=new Scan();
        int n=input.scanInt();
        String str=input.scanString();
        int cnt=0;
        for(int i=0;i<n;i++) {
            if(str.charAt(i)=='1') {
                cnt++;
            }
        }
        int pow0[]=new int[n];
        pow0[0]=1;
        for(int i=1;i<n;i++) {
            pow0[i]=2*pow0[i-1];
            pow0[i]%=(cnt-1);
        }
        int pow1[]=new int[n];
        pow1[0]=1;
        for(int i=1;i<n;i++) {
            pow1[i]=2*pow1[i-1];
            pow1[i]%=(cnt+1);
        }
        int num0=0,num1=0;
        for(int i=0;i<n;i++) {
            if(str.charAt(i)=='1') {
                num0+=pow0[n-i-1];
                num0%=(cnt-1);
            }
        }
        for(int i=0;i<n;i++) {
            if(str.charAt(i)=='1') {
                num1+=pow1[n-i-1];
                num1%=(cnt+1);
            }
        }
        StringBuilder ans=new StringBuilder("""");
        for(int i=0;i<n;i++) {
            if(str.charAt(i)=='1') {
                num0-=pow1[n-i-1];
                if(num0<0) {
                    num0+=(cnt-1);
                }
                ans.append((calc(num0)+1)+""\n"");
                num0+=pow1[n-i-1];
                num0%=(cnt-1);
            }
            else {
                num1+=pow1[n-i-1];
                num1%=(cnt+1);
                ans.append((calc(num1)+1)+""\n"");
                num1-=pow1[n-i-1];
                if(num1<0) {
                    num1+=(cnt+1);
                }
            }
        }
        System.out.println(ans);
    }
    public static int calc(int n) {
        int cnt=0;
        while(n!=0) {
            int tmp=n;
            int ones=0;
            while(tmp!=0) {
               ones+=tmp%2;
               tmp/=2;
            }
            n%=ones;
            cnt++;
        }
        return cnt;
    }
}
"
164,"import java.util.*;
import java.io.*;
import java.util.Arrays; 
import java.util.ArrayList; 
import java.util.Collections; 
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.InputStream;
import java.util.StringTokenizer;
import java.math.BigInteger;

public class Main {

    public static void main(String[] args) {
        try (PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out))) {
            FastScanner in = new FastScanner(System.in);
            int n = in.nextInt();
            int a;
            int b;
            int c;
            int numberOfTuples = 0;

            for(int i = 1; i < n; i ++) {
                a = i;
                for(int j = 1; j < n; j++) {
                    b = j;
                    if(a*b < n) {
                        c = n - (a*b);
                        numberOfTuples++;
                    }
                }
            }
            out.println(numberOfTuples);



        } finally {
            //out.close();
        }
        
           
    }
}


class FastScanner {
   private final BufferedReader br;
   private StringTokenizer st;
 
    FastScanner(InputStream InputStream) {
        br = new BufferedReader(new InputStreamReader(InputStream));
    }
    
    String next() {
        while (st == null || !st.hasMoreTokens()) {
            try {
                st = new StringTokenizer(br.readLine());
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
        return st.nextToken();
    }
    
    int nextInt() {
        return Integer.parseInt(next());
    }
    
    long nextLong() {
        return Long.parseLong(next());
    }
    
    double nextDouble() {
        return Double.parseDouble(next());
    }


    
    ArrayList<Integer> nextIntList(int count) {
        ArrayList<Integer> array = new ArrayList<>();
        for (int n = 0; n < count; n++) {
            int number = nextInt();
            array.add(number);
        }
        return array;
    }
    
    int[] nextIntArray(int count) {
        int[] array = new int[count];
        for (int n = 0; n < count; n++) {
            array[n] = nextInt();
        }
        return array;
    }
}"
165,"import java.io.InputStream;
import java.io.PrintStream;
import java.util.HashSet;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) throws Exception {
        solve(System.in, System.out);
    }

    static HashSet<Integer> friend[];
    static HashSet<Integer> block[];
    static HashSet<Integer> friendCache[];

    static void solve(InputStream is, PrintStream os) {
        // Your code here!
        Scanner scan = new Scanner(is);
        int N = scan.nextInt();
        int M = scan.nextInt();
        int K = scan.nextInt();
        friend = new HashSet[N];
        block = new HashSet[N];
        friendCache = new HashSet[N];
        for(int i = 0; i < N; i++) {
            friend[i] = new HashSet<>();
            block[i] = new HashSet<>();
        }

        for(int i = 0; i < M; i++) {
            int A = scan.nextInt()-1;
            int B = scan.nextInt()-1;
            friend[A].add(B);
            friend[B].add(A);
        }
        for(int i = 0; i < K; i++) {
            int C = scan.nextInt()-1;
            int D = scan.nextInt()-1;
            block[C].add(D);
            block[D].add(C);
        }

        int ans[] = new int[N];
        for(int i = 0; i < N; i++) {
            if(friend[i].size() + block[i].size() == N-1) {
                ans[i] = 0;
            } else {
                ans[i] = bfs(i);
            }
            os.print(ans[i]);
            if(i != N-1)
                os.print("" "");
        }
        os.println();

    }


    static int bfs(int i) {
        int ans = 0;
        HashSet<Integer> visited = new HashSet<>();
        HashSet<Integer> stack = new HashSet<>();
        visited.add(i);
        stack.addAll(friend[i]);
        while(!stack.isEmpty()) {
            HashSet<Integer> next = new HashSet<>();
            for(Integer fri : stack) {
                if(visited.contains(fri))
                    continue;
                visited.add(fri);
                if(friendCache[fri] != null)
                    next.addAll(friendCache[fri]);
                else
                    next.addAll(friend[fri]);
                if(!friend[i].contains(fri) && !block[i].contains(fri)) {
                    if(friendCache[i] == null) {
                        friendCache[i] = new HashSet<>();
                        friendCache[i].addAll(friend[i]);
                    }
                    friendCache[i].add(fri);
                    ans++;
                }
            }
            stack = next;
        }
        return ans;
    }
}"
166,"// This template is based on Mr. tonymontaro's template (https://atcoder.jp/users/tonymontaro).
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.StringTokenizer;

// For flatten() required Java8
import java.util.stream.Stream;
import java.util.stream.IntStream;

import java.util.Queue;
import java.util.ArrayDeque;

import java.util.ArrayList;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Collections;

public class Main {
    static PrintWriter out;
    static CF_Reader in;

    static int INTMAX = 2147483647;

    // Start: 大きな数
    // 10^20くらいまで
    // long a = 0;
    // End: 大きな数
    public static void main(String[] args) throws IOException {
        out = new PrintWriter(new OutputStreamWriter(System.out));
        in = new CF_Reader();
        StringBuilder result = new StringBuilder();

        // Start: int型の整数N Mを取得する
        // // N M 形式
        long N = in.longNext();
        // int M = in.intNext();

        // for (long i = 2L; i < N; i *= 2) {
        //   if (
        // }

        if (isPrimeLong(N)) {
          out.println(1);
          out.close();
          return;
        }
        ArrayList<Long> primes = new ArrayList<>();
        long prime = N;
        long n;
        for (long i = 2L; i <= prime; i++) {
          n = 0L;
          while (prime % i == 0L) {
            prime /= i;
            n++;
          }

          if (n != 0L) {
            for (long j = n; j > 0L; j--) {
              primes.add(i);
            }
          }
        }

        ArrayList<Long> uniqPrimes = new ArrayList<>();
        for (long p : primes) {
          if(!uniqPrimes.contains(p))
              uniqPrimes.add(p);
        }

        ArrayList<Integer> primeOccurence = new ArrayList<>();
        for (long p : uniqPrimes) {
          primeOccurence.add(Collections.frequency(primes, p));
        }

        // int counter = 0;
        // for (int num : primeOccurence) {
        //   for (int i = 0; i < num; i++) {
        //     if (i + i + 1 <= num) {
        //       counter++;
        //     }
        //   }
        // }
        // result.append(counter);

        // ArrayList<int> numPrimes = new ArrayList<>();
        // long prevP = -1;
        // for (int i; i < primes.size(); i++) {
        //   long p = primes.get(i);
        //   if (prevP == p) {
        //     numPrimes.set(i, numPrimes.get(i)++);
        //   } else {
        //     numPrimes.set(i, numPrimes.get(i)++);
        //   }
        //   prevP = p;
        // }


        //for(long p : primes) {
        //  out.println(p);
        //}

        int ans = 0;
        for (long p : primeOccurence) {
          long used = 0;
          while (p > used) {
            ans++;
            used++;
            p -= used;
          }
        }
        result.append(ans);
        // ArrayList<Long> memo = new ArrayList<>();
        // int count = 0;

        // long prev = 1;

        // int i = 0;
        // while (i < primes.size()) {
        //   long p = primes.get(i);

        //   while (memo.contains(p)) {
        //     i++;
        //     if (i == primes.size()) break;
        //     p *= primes.get(i);
        //   }

        //   if (!memo.contains(p) && i < primes.size()) {
        //     memo.add(p);
        //     count++;
        //     i++;
        //   }
        // }
        // result.append(count);

        //[補足]
        // N M
        // A B 形式だと
        // int N = in.intNext();
        // int M = in.intNext();
        // int A = in.intNext();
        // int B = in.intNext();
        // End: int型の整数N Mを取得する

        // Start: int型の整数Nと配列Aを取得する
        // // N
        // // A1 A2 A3... AN 形式
        // int n = in.intNext();
        // int[] A = in.nextIntArray(n);
        // End: int型の整数Nと配列Aを取得する

        // Start: Char型の文字をInt型に変換する
        // Integer.parseInt(String.valueOf(charText))
        // End: Char型の文字をInt型に変換する

        // Start: 文字列を1文字ずつ出力する
        // String text = in.next();
        // char[] work = new char[text.length()];
        // for(int i = 0; i < text.length(); i++){
        //   work[i] = text.charAt(i); // Char型の文字
        //   out.println(work[i]);
        // }
        // End: 文字列を1文字ずつ出力する

        // Start: 配列の定義
        // int[] a = new int[N];
        // int[][] b = new int[N][M];
        // End: 配列の定義

        // Start: キューの定義
        // Queue<int[]> queue = new ArrayDeque<int[]>();
        // Start: キューの定義

        // Start: リストのリスト
        // @SuppressWarnings(""unchecked"")
        // List<Integer>[] adjacents = new ArrayList[N];
        // Start: リストのリスト

        // Start: forEach文
        // for (int elem: elements) {
        // }
        // Start: forEach文

        out.println(result);

        out.close();
    }

    // 素数判定。
    public static boolean isPrime(int N) {
      if (N == 1) return false;
      for (int i = 2; i * i <= N; ++i) {
        if (N % i == 0) return false;
      }
      return true;
    }

    public static boolean isPrimeLong(Long N) {
      if (N == 1L) return false;
      for (long i = 2L; i * i <= N; ++i) {
        if (N % i == 0L) return false;
      }
      return true;
    }


    // 使い方
    // List<String> list = new ArrayList<String>();
    // permutation(list, ""abc"", """");
    // for (String str : list) {
    //   out.print(str + "" "");
    // }
    // >> abc acb bac bca cab cba
    public static List<String> permutation(List<String> list, String target, String ans){
      if(target.length() <= 1) {
        list.add(ans + target);
      } else {
        for (int i = 0; i < target.length(); i++) {
          permutation(
            list,
            target.substring(0, i) + target.substring(i + 1),
            ans + target.charAt(i));
        }
      }
      return list;
    }

    // 使い方
    // String[] list2 = { ""A"", ""B"", ""C"", ""D""};
    // List<String[]> res = combination(list2, 3);
    // for (String[] arr : res) {
    //   out.print(""["");
    //   for (String a : arr) {
    //     out.print(a + "", "");
    //   }
    //   out.print(""], "");
    // }
    // >> [A, B, C], [A, B, D], [A, C, D], [B, C, D]
    static List<String[]> combination(String[] data, int k) {
        List<String[]> result = new ArrayList<String[]>();
        combination(data, 0, new String[k], 0, result);
        return result;
    }

    static void combination(String[] data, int di, String[] comb, int ci, List<String[]> result) {
        if (ci == comb.length) {
            result.add(comb.clone());
            return;
        }
        for ( ; di <= data.length - (comb.length - ci); di++) {
            comb[ci] = data[di];
            combination(data, di + 1, comb, ci + 1, result);
        }
    }

    public static int[] flatten(int[][] arr) {
       return Stream.of(arr)
          .flatMapToInt(row -> IntStream.of(row))
          .toArray();
    }

    public static int maxIntValueFromArray(int[] array) {

        int intMax = array[0];

        for (int i = 1; i < array.length; i++ ) {
            if(intMax < array[i]) {
                intMax = array[i];
            }
        }
        return intMax;
    }

    public static int minIntValueFromArray(int[] array) {

        int intMin = array[0];

        for (int i = 1; i < array.length; i++ ) {
            if(intMin > array[i]) {
                intMin = array[i];
            }
        }
        return intMin;
    }

    static class CF_Reader {
        BufferedReader br;
        StringTokenizer st;

        public CF_Reader() throws IOException {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        String next() throws IOException {
            while (st == null || !st.hasMoreTokens())
                st = new StringTokenizer(br.readLine().trim());
            return st.nextToken();
        }

        long longNext() throws IOException {
            return Long.parseLong(next());
        }

        int intNext() throws IOException {
            return Integer.parseInt(next());
        }

        double doubleNext() throws IOException {
            return Double.parseDouble(next());
        }

        char charNext() throws IOException {
            return next().charAt(0);
        }

        public int[] nextIntArray(final int n) throws IOException {
            final int[] a = new int[n];
            for (int i = 0; i < n; i++)
                a[i] = intNext();
            return a;
        }

        public long[] nextLongArray(final int n) throws IOException {
            final long[] a = new long[n];
            for (int i = 0; i < n; i++)
                a[i] = longNext();
            return a;
        }

        String line() throws IOException {
            return br.readLine().trim();
        }
    }
}"
167,"import java.util.*;
import java.io.*;

public class Sequence {
    public static void main(String [] args) {
        Reader in = new Reader ();
        Writer out = new Writer ();

        int n = in.nextInt();
        int [] a = new int [n + 5];

        for(int i = 1; i <= n; i++) {
            a[i] = in.nextInt();
        }
        long ans = (long) 1e16;
        for(int cs = 0; cs <= 1; cs++) {
            int pos = cs;
            long sum = 0;
            long res = 0;

            for(int i = 1; i <= n; i++) {
                if(pos == 1) {
                    long can = -sum + 1;
                    if(a[i] >= can) sum += a[i];
                    else {
                        res += Math.abs(can - a[i]);
                        sum += can;
                    }
                } else {
                    long can = -sum - 1;
                    if(a[i] <= can) sum += a[i];
                    else {
                        res += Math.abs(can - a[i]);
                        sum += can;
                    } 
                }
                pos ^= 1;
            }
            ans = Math.min(ans, res);
        }
        System.out.println(ans);
    }
    static class Reader {
        private StringTokenizer a;
        private BufferedReader b;
        Reader () {
            a = null;
            b = new BufferedReader (new InputStreamReader (System.in));
        }
        public String next () {
            while(a == null || !a.hasMoreTokens()) {
                try {
                    a = new StringTokenizer (b.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return a.nextToken();
        }
        public int nextInt() {
            return Integer.parseInt(this.next());
        }
        public long nextLong () {
            return Long.parseLong(this.next());
        }
        public double nextDouble () {
            return Double.parseDouble(this.next());
        }
        public String nextLine() {
            try {
                return b.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return """";
        }
    }
    static class Writer {
        private PrintWriter a;
        private StringBuffer b;
        Writer () {
            a = new PrintWriter (System.out);
            b = new StringBuffer ("""");
        }
        public void write (Object s) {
            b.append(s);
        }
        public void writeln(Object s) {
            b.append(s).append('\n');
        }
        public void flush () {
            a.print(b);
            a.flush();
            a.close();
        }
    }
    static class Pair implements Comparator <Pair> {
        int first;
        int second;
        Pair  (int a, int b) {
            this.first = a;
            this.second = b;
        }
        Pair (Pair a) {
            this.first = a.first;
            this.second = a.second;
        }
        Pair () {}
        public String toString () {
            return ""["" + first + "", "" + second + ""]"";
        }
        public int compare (Pair a, Pair b) {
            if(a.first == b.first) {
                return a.second - b.second;
            } else {
                return a.first - b.first;
            }
        }
    }
}
"
168,"import java.util.*;

public class Main{
  public static void main(String[] args){
   Scaneer sc = new Scanner(Syst0em.in);
    int n = sc.nextInt();
    int x = sc.nextInt();
    
    int[] l = new int[n];
    int bound = 0;
    int count = 1;
    
    for(int i =0; int i < n; i++){
      bound += sc.nextInt();
      count++;
      if(bound < x){
        break;
     }    
    }
    System.out.printlm(count);
  }
 }"
169,"import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ
		boolean hantei = false;
		int x = 0;
		int y = 0;
		while (hantei != true ) {
			Scanner scan = new Scanner(System.in);
			x = scan.nextInt();//配列に数値を代入
			y = scan.nextInt();//次の配列に数値を代入y
			if (x == 0 && y ==0) {
				hantei = true;
			}else{
				if (x > y) {
					System.out.println(y+"" ""+x);
				}else {
					System.out.println(x+"" ""+y);
				}
			}
			}//if end
	}
}
"
170,"
import java.awt.Point;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.util.LinkedList;
import java.util.Queue;
import java.util.SortedMap;

public class Main {
	InputStream is;

	boolean __FILE_DEBUG_FLAG__ = false;
	String __DEBUG_FILE_NAME__ = ""src/T"";

	FastScanner in;
	PrintWriter out;
	
	long count(int n) {
		long base = 10;
		long res = 0;
		int d = 1;
		for ( ; base <= n; d++, base *= 10) {
			res += d * (base - base / 10);			
		}
		res += d * (n - base / 10 + 1);
		return res;
	}
	
	public void solve() {	
		while (true) {
			int N = in.nextInt(), K = in.nextInt();
			if (N == 0) break;
			
			int lo = 0, hi = 100000000;
			while (hi - lo > 1) {
				int mid = (lo + hi) / 2;
				long c = count(mid);
				if (c < N)
					lo = mid;
				else
					hi = mid;
			}
			
			String res = """";
			int start = (int) (N - count(lo) - 1);
			for (int i = 0; i < K + start; i++) {
				res += hi + i;
			}
			System.out.println(res.substring(start, start + K));
		}
	}

	
	public void run() {
		if (__FILE_DEBUG_FLAG__) {
			try {
				is = new FileInputStream(__DEBUG_FILE_NAME__);
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
			System.out.println(""FILE_INPUT!!"");
		} else {
			is = System.in;
		}
		in = new FastScanner(is);
		out = new PrintWriter(System.out);

		solve();
	}

	public static void main(String[] args) {
		new Main().run();
	}

	public void mapDebug(int[][] a) {
		System.out.println(""--------map display---------"");

		for (int i = 0; i < a.length; i++) {
			for (int j = 0; j < a[i].length; j++) {
				System.out.printf(""%3d "", a[i][j]);
			}
			System.out.println();
		}

		System.out.println(""----------------------------"");
		System.out.println();
	}

	public void debug(Object... obj) {
		System.out.println(Arrays.deepToString(obj));
	}

	class FastScanner {
		private InputStream stream;
		private byte[] buf = new byte[1024];
		private int curChar;
		private int numChars;

		public FastScanner(InputStream stream) {
			this.stream = stream;
			//stream = new FileInputStream(new File(""dec.in""));

		}

		int read() {
			if (numChars == -1)
				throw new InputMismatchException();
			if (curChar >= numChars) {
				curChar = 0;
				try {
					numChars = stream.read(buf);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (numChars <= 0)
					return -1;
			}
			return buf[curChar++];
		}

		boolean isSpaceChar(int c) {
			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
		}

		boolean isEndline(int c) {
			return c == '\n' || c == '\r' || c == -1;
		}

		int nextInt() {
			return Integer.parseInt(next());
		}

		int[] nextIntArray(int n) {
			int[] array = new int[n];
			for (int i = 0; i < n; i++)
				array[i] = nextInt();

			return array;
		}

		int[][] nextIntMap(int n, int m) {
			int[][] map = new int[n][m];
			for (int i = 0; i < n; i++) {
				map[i] = in.nextIntArray(m);
			}
			return map;
		}

		long nextLong() {
			return Long.parseLong(next());
		}

		long[] nextLongArray(int n) {
			long[] array = new long[n];
			for (int i = 0; i < n; i++)
				array[i] = nextLong();

			return array;
		}

		long[][] nextLongMap(int n, int m) {
			long[][] map = new long[n][m];
			for (int i = 0; i < n; i++) {
				map[i] = in.nextLongArray(m);
			}
			return map;
		}

		double nextDouble() {
			return Double.parseDouble(next());
		}

		double[] nextDoubleArray(int n) {
			double[] array = new double[n];
			for (int i = 0; i < n; i++)
				array[i] = nextDouble();

			return array;
		}

		double[][] nextDoubleMap(int n, int m) {
			double[][] map = new double[n][m];
			for (int i = 0; i < n; i++) {
				map[i] = in.nextDoubleArray(m);
			}
			return map;
		}

		String next() {
			int c = read();
			while (isSpaceChar(c))
				c = read();
			StringBuilder res = new StringBuilder();
			do {
				res.appendCodePoint(c);
				c = read();
			} while (!isSpaceChar(c));
			return res.toString();
		}

		String[] nextStringArray(int n) {
			String[] array = new String[n];
			for (int i = 0; i < n; i++)
				array[i] = next();

			return array;
		}

		String nextLine() {
			int c = read();
			while (isEndline(c))
				c = read();
			StringBuilder res = new StringBuilder();
			do {
				res.appendCodePoint(c);
				c = read();
			} while (!isEndline(c));
			return res.toString();
		}
	}
}"
171,"import java.io.BufferedInputStream;
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(new BufferedInputStream(System.in));
		int M = sc.nextInt();
		long N = sc.nextLong();
		long[] a = new long[M+1];
		long all = 1;
		for(int i = 0;i< M;i++){
			a[i] = sc.nextLong();
			all = all * a[i] / gcd(all, a[i]);
		}
		all = all * a[M-1] / gcd(all, a[M-1]);
		sc.close();
		int flag = 0;
		for(int i = 0;i < M;i++){
			if(all/a[i]%2==0){
				System.out.println(0);
				break;
			}else{
				flag++;
			}
		}
		if(flag == M){
			System.out.println((2*N/all+1)/2);
		}
	}


	private static long gcd(long m, long n) {
	   //if(m < n) return gcd(n, m);
	    if(n == 0) return m;
	    long r = m%n;
	    return gcd(n, r);
	}
}"
172,"import java.util.Scanner;
import java.util.Arrays;
public class Mai{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int A = sc.nextInt();
        int B = sc.nextInt();
        int[] ans = new int[5];
        int count = 0;
        for(int i = A;i <= B;i++){
            int j = 0;
            int x = i;
            while(x > 0){
                ans[j++] = x % 10;
                x /= 10;
                //System.out.println(""i = "" + x);
                //System.out.println(""ans[] = "" + ans[j]);
            }
            if(ans[0] == ans[4] && ans[1] == ans[3]){
                count++;
            }
        }
        System.out.println(count);
    }
}
"
173,"import java.util.Scanner;
public class Main {

	public static void main(String[] args) {
		int a[]=new int[1000];
		int b[]=new int [1000];
		int answer[]=new int [1000];
		String op[]=new String[1000];
		int i;
		Scanner sc = new Scanner(System.in);
		for(i=0;i<1000;i++){
			a[i]=sc.nextInt();
			op[i]=sc.next();
			b[i]=sc.nextInt();
			switch(op[i]){
			 case ""+"":
				answer[i]=a[i]+b[i];
				break;

			 case ""-"":
				answer[i]=a[i]-b[i];
				break;

			 case ""*"":
				answer[i]=a[i]*b[i];
				break;

			 case ""/"":
				answer[i]=a[i]/b[i];
				break;
			 case""?"":
				break;

			}

			if(op[i].equals(""?""))
				break;

		}

		sc.close();
		for(int j=0;j<i;j++){
			System.out.println(answer[j]);
		}




		}
	}"
174,"import java.util.*;

public class Main{
  public static void main(String[]args){
    Scanner sc = new Scanner(System.in);
    int N = Integer.parseInt(sc.nextLine());
    List<Long> listA = new ArrayList<>();
    long[] listB = new long[N];
    List<Long> listC = new ArrayList<>();
    
    String[] A = sc.nextLine().split("" "");
    String[] B = sc.nextLine().split("" "");
    String[] C = sc.nextLine().split("" "");
    for(int i = 0; i < N; i++){
      listA.add(Long.parseLong(A[i]));
      listC.add(Long.parseLong(C[i]));
      listB[i] = Long.parseLong(B[i]);
    }
    
    Collections.sort(listA);
    Collections.sort(listC, Collections.reverseOrder());
    
    long sum = 0;
    for(int i = 0; i < N; i++){
      long n = listB[i];
      long a = N;
      long c = N;
      int bs1 = 0;
      int bs2 = N-1;
      while(true){
        int bs = (bs1+bs2)/2;
        if(listA.get(bs) >= n){
          bs2 = bs;
        }else{
          bs1 = bs+1;
        }
        
        if(bs1 == bs2){
          if(listA.get(bs1) >= n){
            a = bs1;
          }else{
            a = bs1+1;
          }
          break;
        }
      }
      
      bs1 = 0;
      bs2 = N-1;
      while(true){
        int bs = (bs1+bs2)/2;
        if(listC.get(bs) <= n){
          bs2 = bs;
        }else{
          bs1 = bs+1;
        }
        
        if(bs1 == bs2){
          if(listC.get(bs1) <= n){
            c = bs1;
          }else{
            c = bs1+1;
          }
          break;
        }
      }
      sum += a * c;
    }
    System.out.println(sum);
  }
}"
175,"import java.io.*; 
class Main {
public static void main(String[] args){
BufferedReader input = new BufferedReader(new FileReader(System.in));
int i=0;
int x;
while((x=Integer.parseInt(br.readLine())) != 0){
i++;
System.out.println(""Case "" +i+ "": "" + x);
}
}
}"
176,"import java.util.*;
import java.io.*;
import java.awt.geom.*;
import java.math.*;

public class Main {

	static final Scanner in = new Scanner(System.in);
	static final PrintWriter out = new PrintWriter(System.out,false);
	static boolean debug = false;

	static int[] dx = {0, 1, 1, 0, -1, -1};
	static int[] dy = {1, 1, 0, -1, -1, 0};
	static int[][] time;
	static int offset = 50;

	static boolean solve() {
		int t = in.nextInt();
		int n = in.nextInt();
		if (t + n == 0) return false;

		time = new int[100][100];
		for (int i=0; i<100; i++) {
			Arrays.fill(time[i], -1);
		}

		for (int i=0; i<n; i++) {
			int x = in.nextInt() + offset;
			int y = in.nextInt() + offset;
			time[x][y] = 1<<30;
		}

		int sx = in.nextInt() + offset;
		int sy = in.nextInt() + offset;

		ArrayDeque<int[]> deq = new ArrayDeque<>();
		deq.add(new int[]{sx, sy, t});
		while (!deq.isEmpty()) {
			int[] cur = deq.pollFirst();
			int cx = cur[0], cy = cur[1];
			int ct = cur[2];
			time[cx][cy] = ct;

			if (ct == 0) continue;

			for (int i=0; i<6; i++) {
				int nx = cx + dx[i];
				int ny = cy + dy[i];
				if (time[nx][ny] < t) {
					deq.add(new int[]{nx, ny, ct-1});
				}
			}
		}

		int ans = 0;

		for (int i=0; i<100; i++) {
			for (int j=0; j<100; j++) {
				if (time[i][j] < 0 || time[i][j] == 1<<30) continue;
				ans++;
			}
		}

		out.println(ans);

		return true;
	}

	public static void main(String[] args) {
		debug = args.length > 0;
		long start = System.nanoTime();

		while(solve());
		out.flush();

		long end = System.nanoTime();
		dump((end - start) / 1000000 + "" ms"");
		in.close();
		out.close();
	}

	static void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }
}"
177,"import java.util.ArrayList;
import java.util.Scanner;

/**
 * Kadai
 */
public class Main {

    public void go() {
        Scanner sc = new Scanner(System.in);
        while (sc.hasNextLine()) {
            String lines0;
            String lines1;
            lines0 = sc.nextLine();
            if (lines0.equals(""."")) {
                sc.close();
                return;
            }
            lines1 = sc.nextLine();

            if (lines0.equals(lines1)) {
                System.out.println(""IDENTICAL"");
                continue;
            }

            String[] strSplit0 = lines0.split(""\"""", -1);
            String[] strSplit1 = lines1.split(""\"""", -1);
            if (strSplit0.length != strSplit1.length) {
                System.out.println(""DIFFERENT"");
                continue;
            }

            int close = 0;
            for (int j = 0; j < strSplit0.length; j++) {
                if (!strSplit0[j].equals(strSplit1[j])) {
                    if (j % 2 == 1) {
                        close++;
                    } else {
                        close = 2;
                        break;
                    }
                }

            }
            switch (close) {
            case 1:
                System.out.println(""CLOSE"");
                break;
            case 0:
                System.out.println(""IDENTICAL"");
                break;
            default:
                System.out.println(""DIFFERENT"");

            }
        }
    }

    public static void main(String[] args) {
        Main kadai = new Main();
        kadai.go();
    }
}
"
178,"import java.io.InputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.BitSet;
import java.util.Comparator;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.InputMismatchException;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.PriorityQueue;
import java.util.TreeMap;
import java.math.BigDecimal;
import java.math.BigInteger;
    
public class Main{
 
static final InputStream in=System.in;
static final PrintWriter out=new PrintWriter(System.out);
static final int INF=Integer.MAX_VALUE;
static final long LINF=Long.MAX_VALUE;
static boolean[] p;
 
public static void main(String[] args) throws IOException{
InputReader ir=new InputReader(in);
int n=ir.nextInt();
out.print(n+"":"");
while(n!=1){
 for(int i=2;;i++){
  if(!p[i]) continue;
  if(n%i==0){
   out.print("" ""+i);
   n/=i;
   break;
  }
 }
}
out.println();
out.flush();
}

public static boolean[] sieveOfEratosthenes(int n){
 boolean[] res=new boolean[n+1];
 Arrays.fill(res,true);
 res[0]=res[1]=false;
 for(int i=2;i<=Math.sqrt(n);i++){
  if(res[i]){
   for(int j=i+i;j<=n;j+=i){
    res[j]=false;
   }
  }
 }
 return res;
}

static class InputReader {
 private InputStream in;
 private byte[] buffer=new byte[1024];
 private int curbuf;
 private int lenbuf;
 
 public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}
  
 public boolean hasNextByte() {
  if(curbuf>=lenbuf){
   curbuf= 0;
   try{
    lenbuf=in.read(buffer);
   }catch(IOException e) {
    throw new InputMismatchException();
   }
   if(lenbuf<=0) return false;
  }
  return true;
 }
 
 private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}

 private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}
 
 private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}

 public boolean hasNext(){skip(); return hasNextByte();}
 
 public String next(){
  if(!hasNext()) throw new NoSuchElementException();
  StringBuilder sb=new StringBuilder();
  int b=readByte();
  while(!isSpaceChar(b)){
   sb.appendCodePoint(b);
   b=readByte();
  }
  return sb.toString();
 }
 
 public int nextInt() {
  if(!hasNext()) throw new NoSuchElementException();
  int c=readByte();
  while (isSpaceChar(c)) c=readByte();
  boolean minus=false;
  if (c=='-') {
   minus=true;
   c=readByte();
  }
  int res=0;
  do{
   if(c<'0'||c>'9') throw new InputMismatchException();
   res=res*10+c-'0';
   c=readByte();
  }while(!isSpaceChar(c));
  return (minus)?-res:res;
 }
 
 public long nextLong() {
  if(!hasNext()) throw new NoSuchElementException();
  int c=readByte();
  while (isSpaceChar(c)) c=readByte();
  boolean minus=false;
  if (c=='-') {
   minus=true;
   c=readByte();
  }
  long res = 0;
  do{
   if(c<'0'||c>'9') throw new InputMismatchException();
   res=res*10+c-'0';
   c=readByte();
  }while(!isSpaceChar(c));
  return (minus)?-res:res;
 }
 
 public double nextDouble(){return Double.parseDouble(next());}
 
 public BigInteger nextBigInteger(){return new BigInteger(next());}
 
 public int[] nextIntArray(int n){
  int[] a=new int[n];
  for(int i=0;i<n;i++) a[i]=nextInt();
  return a;
 }
 
 public char[][] nextCharMap(int n,int m){
  char[][] map=new char[n][m];
  for(int i=0;i<n;i++) map[i]=next().toCharArray();
  return map;
 }
}
}"
179,"import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.NoSuchElementException;

public class Main {
	static FastScanner sc = new FastScanner();
	static PrintWriter out = new PrintWriter(System.out);
	static char [][] field;
	static int H;
	static int W;
	
	public static void main(String[] args) {
		H = sc.nextInt();
		W = sc.nextInt();
		
		field = new char [H][W];
		for (int i=0; i<H; i++)
			field [i]=sc.next().toCharArray();
		
		int cnt = -1;
		
		for (int i=0; i<H; i++){
			for (int j=0; j<W; j++){
				
				if (field[i][j]=='#')
					continue;
				
				int temp=1;
			
				temp+=dfs(i,j,0,1,0);
				temp+=dfs(i,j,0,-1,0);
				temp+=dfs(i,j,1,0,0);
				temp+=dfs(i,j,-1,0,0);
				
				cnt = Math.max(temp, cnt);
			}
			if (cnt == H+W-1)
				break;
		}
		out.println(cnt);
		
		out.flush();
	}
	static int dfs (int y, int x, int dirx, int diry, int cnt){
		y+=diry;
		x+=dirx;
			
		if (y<0 || y>=H || x<0 || x>=W) 
			return cnt;
			
		if (field[y][x]=='#') 
			return cnt;
            
		cnt++;
		return dfs (y,x, dirx, diry, cnt);
	}

	
	
	
		static class FastScanner {
		    private final InputStream in = System.in;
		    private final byte[] buffer = new byte[1024];
		    private int ptr = 0;
		    private int buflen = 0;

		    private boolean hasNextByte() {
		      if (ptr < buflen) {
		        return true;
		      } else {
		        ptr = 0;
		        try {
		          buflen = in.read(buffer);
		        } catch (IOException e) {
		          e.printStackTrace();
		        }
		        if (buflen <= 0) {
		          return false;
		        }
		      }
		      return true;
		    }

		    private int readByte() {
		      if (hasNextByte()) return buffer[ptr++];
		      else return -1;
		    }

		    private static boolean isPrintableChar(int c) {
		      return 33 <= c && c <= 126;
		    }

		    private void skipUnprintable() {
		      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
		    }

		    public boolean hasNext() {
		      skipUnprintable();
		      return hasNextByte();
		    }

		    public String next() {
		      if (!hasNext()) throw new NoSuchElementException();
		      StringBuilder sb = new StringBuilder();
		      int b = readByte();
		      while (isPrintableChar(b)) {
		        sb.appendCodePoint(b);
		        b = readByte();
		      }
		      return sb.toString();
		    }

		    public long nextLong() {
		      if (!hasNext()) throw new NoSuchElementException();
		      long n = 0;
		      boolean minus = false;
		      int b = readByte();
		      if (b == '-') {
		        minus = true;
		        b = readByte();
		      }
		      if (b < '0' || '9' < b) {
		        throw new NumberFormatException();
		      }
		      while (true) {
		        if ('0' <= b && b <= '9') {
		          n *= 10;
		          n += b - '0';
		        } else if (b == -1 || !isPrintableChar(b)) {
		          return minus ? -n : n;
		        } else {
		          throw new NumberFormatException();
		        }
		        b = readByte();
		      }
		    }

		    public int nextInt() {
		      return (int) nextLong();
		    }

		    public int[] nextIntArray(int N, boolean oneBased) {
		      if (oneBased) {
		        int[] array = new int[N + 1];
		        for (int i = 1; i <= N; i++) {
		          array[i] = sc.nextInt();
		        }
		        return array;
		      } else {
		        int[] array = new int[N];
		        for (int i = 0; i < N; i++) {
		          array[i] = sc.nextInt();
		        }
		        return array;
		      }
		    }

		    public long[] nextLongArray(int N, boolean oneBased) {
		      if (oneBased) {
		        long[] array = new long[N + 1];
		        for (int i = 1; i <= N; i++) {
		          array[i] = sc.nextLong();
		        }
		        return array;
		      } else {
		        long[] array = new long[N];
		        for (int i = 0; i < N; i++) {
		          array[i] = sc.nextLong();
		        }
		        return array;
		      }
		    }
		  }

		}	 



"
180,"import java.io.IOException;
import java.io.InputStream;
import java.util.NoSuchElementException;

public class Main {

	public static void main(String[] args) {
		FastScanner sc = new FastScanner();
		String S = sc.next();
		String T = sc.next();

		for (int i = 0; i < S.length(); i++) {
			if (!S.substring(i, i + 1).equals(T.substring(i, i + 1))) {
				String U = S;
				S = S.replace(S.substring(i, i + 1), ""*"").replace(T.substring(i, i + 1), U.substring(i, i + 1))
						.replace(""*"", T.substring(i, i + 1));
			}

		}

		if (S.equals(T))
			System.out.println(""Yes"");
		else
			System.out.println(""No"");
	}

	//以下、自作ライブラリ

	//最大公約数
	public static long gcd(long a, long b) {
		if (a < b)
			return gcd(b, a);
		long c = 0;
		c = a % b;
		if (c == 0)
			return b;
		return gcd(b, c);
	}

	//最小公倍数
	public static long lcm(long m, long n) {
		return m * n / gcd(m, n);
	}

	//素数判定
	public static boolean isPrime(int n) {
		if (n < 2)
			return false;
		if (n == 2)
			return true;
		if (n % 2 == 0)
			return false;

		for (int i = 3; i * i <= n; i += 2) {
			if (n % i == 0)
				return false;
		}
		return true;
	}
}

//以下、高速スキャナークラス
class FastScanner {
	private final InputStream in = System.in;
	private final byte[] buffer = new byte[1024];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) {
			return true;
		} else {
			ptr = 0;
			try {
				buflen = in.read(buffer);
			} catch (IOException e) {
				e.printStackTrace();
			}
			if (buflen <= 0) {
				return false;
			}
		}
		return true;
	}

	private int readByte() {
		if (hasNextByte())
			return buffer[ptr++];
		else
			return -1;
	}

	private static boolean isPrintableChar(int c) {
		return 33 <= c && c <= 126;
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext())
			throw new NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		int b = readByte();
		while (isPrintableChar(b)) {
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}

	public long nextLong() {
		if (!hasNext())
			throw new NoSuchElementException();
		long n = 0;
		boolean minus = false;
		int b = readByte();
		if (b == '-') {
			minus = true;
			b = readByte();
		}
		if (b < '0' || '9' < b) {
			throw new NumberFormatException();
		}
		while (true) {
			if ('0' <= b && b <= '9') {
				n *= 10;
				n += b - '0';
			} else if (b == -1 || !isPrintableChar(b)) {
				return minus ? -n : n;
			} else {
				throw new NumberFormatException();
			}
			b = readByte();
		}
	}

	public int nextInt() {
		long nl = nextLong();
		if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)
			throw new NumberFormatException();
		return (int) nl;
	}

	public double nextDouble() {
		return Double.parseDouble(next());
	}
}
"
181,"import java.util.LinkedList;
import java.util.Scanner;

public class Main {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		LinkedList<Character> q = new LinkedList<Character>();
		String input = """";
		while (!(input = scanner.nextLine()).equals(""."")) {
			boolean procFlag = false;
			char[] ch = input.toCharArray();
			int i = 0;
			while (i < ch.length) {
				char c = ch[i];
				switch (c) {
				case '(':
				case '[':
					procFlag = true;
					q.push(c);
					break;
				case ')':
					if (q.peek() == '(') {
						q.pop();
					} else {

					}F
					break;
				case ']':
					if (q.peek() == '[') {
						q.pop();
					} else {

					}
				default:
					break;
				}
				i++;
			}
			if (q.isEmpty() && procFlag || !procFlag) {
				System.out.println(""yes"");
			} else {
				System.out.println(""no"");
			}
		}
	}
}"
182,"import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Scanner;
import java.util.Set;
 
public class Main {
    public static class Walk implements Comparable<Walk>{
        int pos, time, limit;
 
        public Walk(int pos, int time, int limit) {
            super();
            this.pos = pos;
            this.time = time;
            this.limit = limit;
        }
 
        @Override
        public int compareTo(Walk o) {
            return this.time - o.time;
        }
    }
     
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        ArrayList<Map<Integer, Integer>> a_list = new ArrayList<Map<Integer, Integer>>(100);
        for(int i = 0; i < 100; i++){
            a_list.add(new HashMap<Integer, Integer>());
        }
        Set<Integer> cool = new HashSet<Integer>();
        
        while (true) {
            final int N = sc.nextInt();
            final int M = sc.nextInt();
            final int L = sc.nextInt();
            final int K = sc.nextInt();
            final int A = sc.nextInt();
            final int H = sc.nextInt();
             
            if(N == 0 && M == 0 && L == 0 && K == 0 && A == 0 && H == 0){
                break;
            }
            
            for(int i = 0; i < 100; i++){
                a_list.get(i).clear();
            }
            cool.clear();
             
            for(int i = 0; i < L; i++){
                cool.add(sc.nextInt());
            }
            cool.add(A);
            cool.add(H);
             
            for(int i = 0; i < K; i++){
                final int from = sc.nextInt();
                final int to = sc.nextInt();
                final int cost = sc.nextInt();
                 
                a_list.get(from).put(to, cost);
                a_list.get(to).put(from, cost);
            }
             
            boolean[][] is_visited = new boolean[N][M + 1];
            boolean[][] in_queue   = new boolean[N][M + 1];
             
            PriorityQueue<Walk> queue = new PriorityQueue<Walk>();
            queue.add(new Walk(A, 0, M));
             
            boolean flag = false;
            while(!queue.isEmpty()){
                Walk walk = queue.poll();
                 
                //System.out.println(walk.pos + "" "" + walk.time + "" "" + walk.limit);
                 
                in_queue[walk.pos][walk.limit] = false;
                if(is_visited[walk.pos][walk.limit]){
                    continue;
                }else{
                    is_visited[walk.pos][walk.limit] = true;
                }
                 
                if(walk.pos == H){
                    System.out.println(walk.time);
                    flag = true;
                    break;
                }
                 
                for(Map.Entry<Integer, Integer> entry : a_list.get(walk.pos).entrySet()){
                    if(!cool.contains(walk.pos)){
                        if(walk.limit < entry.getValue()){
                            continue;
                        }else if(is_visited[entry.getKey()][walk.limit - entry.getValue()]){
                            continue;
                        }else if(in_queue[entry.getKey()][walk.limit - entry.getValue()]){
                            continue;
                        }else{
                            queue.add(new Walk(entry.getKey(), walk.time + entry.getValue(), walk.limit - entry.getValue()));
                        }
                    }else{
                        for(int rest = 0; rest <= M; rest++){
                            if(walk.limit + rest > M){
                                break;
                            }
                             
                            if(walk.limit + rest < entry.getValue()){
                                continue;
                            }else if(is_visited[entry.getKey()][walk.limit - entry.getValue() + rest]){
                                continue;
                            }else if(in_queue[entry.getKey()][walk.limit - entry.getValue() + rest]){
                                continue;
                            }else{
                                queue.add(new Walk(entry.getKey(), walk.time + entry.getValue() + rest, walk.limit - entry.getValue() + rest));
                            }
                        }
                         
                         
                    }
                }
                 
            }
             
            if(!flag){
                System.out.println(""help!"");
            }
        }
 
        sc.close();
    }
 
}"
183,"import java.util.*;

public class Main{
    static long ans = 0;
    static int mod = 998244353;
    public static void main(String[] args) {
        ans = 0;
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();
        ArrayList<Integer>arr = new ArrayList<>();

        for(int i = 0;i < k;i++){
            int l = sc.nextInt();
            int r = sc.nextInt();
            for(int j = l;j <= r;j++){
                arr.add(j);
            }
        }
        arr.sort((o1, o2) -> o1 - o2);
        long[]dp = new long[n + 1];
        dp[1] = 1;
        for(int i = 2;i <= n ;i++){
            for(int j = 0;j < arr.size();j++){
                int bf = i - arr.get(j);
                if(bf >= 0){
                    dp[i] += dp[bf] % mod;
                    dp[i] %= mod;
                }else{
                    break;
                }
            }
        }
        System.out.println(dp[n]);
    }

}
"
184,"import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		try(Scanner scanner = new Scanner(System.in)) {
			String n = scanner.next();
			int N = Integer.parseInt(n.substring(1));

			if (N == 2 || N == 4 || N == 5 || N == 7 || N == 9) {
				System.out.print(""hon"");
			}else if (N == 0 || N == 1 || N == 6 || N == 8) {
				System.out.print(""pon"");
			} else {
				System.out.print(""bon"");
			}

		}
	}
}"
185,"import java.util.Scanner;

public class Main
{
    public static void main(String arg[])
    {
        int a=0,b=0;
        Scanner scan=new Scanner(System.in);
        a=scan.nextInt();
        b=scan.nextInt();
        if(a==b)
        System.out.println(""-1"");
        int c=a>b?a:b;
        c=c+1;
        while(2>1)
        {
            if(c%a==0&&c%b!=0)
            {
            System.out.println(c);
            break;
            }
            c=c+1;
        }
    }
}"
186,"
import java.util.Scanner;

class AtCoder_String {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
         String input = sc.next();
         int kekka = 0;
         for(int i = 0; i < input.length(); i++){
             Character c = input.charAt(i);
             switch(c) {
                 case '+':
                   kekka+=1;
                   break;
                 case '-':
                     kekka-=1;
                     break;
             }
         }
        System.out.println(kekka);
    }
}"
187,"import java.util.Scanner;
import java.util.Arrays;
/* Name of the class has to be ""Main"" only if the class is public. */
class Codechef
{
	public static void main (String[] args) throws java.lang.Exception
	{
		try {
		    Scanner sc = new Scanner(System.in);
		    int t,n,i,a,b,k,m;
		    n=sc.nextInt();
		    
		        m=k=0;
		        for(i=0;i<n;i++)
		        {
		            a=sc.nextInt();
		            b=sc.nextInt();
		            if(a==b)
		             k++;
		             else
		             {
		          
		                 if(k>m)
		                 m=k;
		                 k=0;
		             }
		        }
		         if(k>m)
		                 m=k;
		        if(m>=3)
		        System.out.println(""YES"");
		        else
		       System.out.println(""NO"");
		    }
		 catch(Exception e) {
		}
	}
}
"
188,"

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Scanner;

public final class Main {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        final String[] line = in.nextLine().split("" "");
        final int n = Integer.parseInt(line[0]);
        final int k = Integer.parseInt(line[1]);
        for (int i = 0; i < n; i++) {
            in.nextInt();
        }
        in.nextLine();
        System.out.println((int) Math.ceil((double) (n - 1) / (k - 1)));
    }
}
"
189,"import java.util.*;

public class Main {
	public static void main (String[] args) {
		Scanner sc = new Scanner(System.in);
		int h = sc.nextInt();
		int w = sc.nextInt();
		int q = sc.nextInt();
		boolean[][] field = new boolean[h + 1][w + 1];
		int[][] sums = new int[h + 1][w + 1];
		int[][] hCounts = new int[h + 1][w + 1];
		int[][] wCounts = new int[h + 1][w + 1];
		int[][] haCounts = new int[h + 1][w + 1];
		int[][] waCounts = new int[h + 1][w + 1];
		for (int i = 1; i <= h; i++) {
		    char[] arr = sc.next().toCharArray();
		    for (int j = 1; j <= w; j++) {
		        field[i][j] = arr[j - 1] == '1';
		        sums[i][j] = sums[i - 1][j] + sums[i][j - 1] - sums[i - 1][j - 1];
		        if (field[i][j]) {
		            sums[i][j]++;
		        }
		        hCounts[i][j] = hCounts[i - 1][j] + hCounts[i][j - 1] - hCounts[i - 1][j - 1];
		        haCounts[i][j] = haCounts[i][j - 1];
		        if (field[i][j] && field[i - 1][j]) {
		            hCounts[i][j]++;
		            haCounts[i][j]++;
		        }
		        wCounts[i][j] = wCounts[i - 1][j] + wCounts[i][j - 1] - wCounts[i - 1][j - 1];
		        waCounts[i][j] = waCounts[i - 1][j];
		        if (field[i][j] && field[i][j - 1]) {
		            wCounts[i][j]++;
		            waCounts[i][j]++;
		        }
		    }
		}
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < q; i++) {
		    int x1 = sc.nextInt();
		    int y1 = sc.nextInt();
		    int x2 = sc.nextInt();
		    int y2 = sc.nextInt();
		    int ans = sums[x2][y2] - sums[x1 - 1][y2] - sums[x2][y1 - 1] + sums[x1 - 1][y1 - 1];
		    ans -= hCounts[x2][y2] - hCounts[x1 - 1][y2] - hCounts[x2][y1 - 1] + hCounts[x1 - 1][y1 - 1] - (haCounts[x1][y2] - haCounts[x1][y1 - 1]);
		    ans -= wCounts[x2][y2] - wCounts[x1 - 1][y2] - wCounts[x2][y1 - 1] + wCounts[x1 - 1][y1 - 1] - (waCounts[x2][y1] - waCounts[x1 - 1][y1]);
		    sb.append(ans).append(""\n"");
		}
		System.out.print(sb);
	}
}
"
190,"import java.util.*;
import java.lang.*;
import java.math.*;
import java.io.*;
import static java.lang.Math.*;
import static java.util.Arrays.*;
import static java.util.Collections.*;

public class Main{
	Scanner sc=new Scanner(System.in);

	long INF=1L<<60;
	double EPS=1e-12;

	int n;
	long[] as, bs;

	void run() throws Exception{
		n=sc.nextInt();
		as=new long[n];
		bs=new long[n];
		for(int i=0; i<n; i++){
			bs[i]=sc.nextLong();
			as[i]=sc.nextLong();
		}
		solve();
	}

	void solve() throws Exception{
		if(n==0){
			println(""Yes 1"");
			return;
		}
		long[] ps=new long[5];
		ps[0]=nextPrime((int)1e3);
		ps[1]=nextPrime(ps[0]);
		ps[2]=nextPrime(ps[1]);
		ps[3]=nextPrime(ps[2]);
		ps[4]=nextPrime(ps[3]);
		// debug(""ps"", ps);

		long min=INF;
		long[] A={1, 1, 1, 1, 1}, B={0, 0, 0, 0, 0};
		ArrayList<Integer> list1=candidate((int)ps[0]);
		ArrayList<Integer> list2=candidate((int)ps[1]);
		ArrayList<Integer> list3=candidate((int)ps[2]);
		ArrayList<Integer> list4=candidate((int)ps[3]);
		ArrayList<Integer> list5=candidate((int)ps[4]);
		long size=(long)list1.size()*list2.size()*list3.size()*list4.size()
				*list5.size();
		// debug(list1.size(), list2.size());
		if(size>1e8){
			// new int[]{}[0]=0;
			StringBuilder sb=new StringBuilder();
			sb.append(n).append('\n');
			for(int i=0; i<n&&i<10; i++){
				sb.append(as[i]).append(' ').append(bs[i]).append('\n');
			}
			throw new Exception(sb.toString());
			// return;
		}
		for(int x1 : list1){
			for(int x2 : list2){
				for(int x3 : list3){
					for(int x4 : list4){
						for(int x5 : list5){
							B[0]=x1;
							B[1]=x2;
							B[2]=x3;
							B[3]=x4;
							B[4]=x5;
							long res=linearCongruence(A, B, ps);
							// debug(res);
							if(res!=-1&&res>0){
								min=min(min, res);
							}
						}
					}
				}
			}
		}
		if(min<INF){
			println(""Yes ""+min);
		}else{
			println(""No"");
		}
		// println(""""+(min<INF?min:-1));
	}

	long linearCongruence(long[] A, long[] B, long[] M){
		long x=0, m=1;
		for(int i=0; i<A.length; i++){
			long a=A[i]*m, b=B[i]-A[i]*x, d=gcd(M[i], a);
			if(b%d!=0)
				return -1;
			// x+=m*(b/d*invMod(a/d, M[i]/d)%(M[i]/d));
			x+=m*(mulMod(b/d, invMod(a/d, M[i]/d), (M[i]/d)));
			m*=M[i]/d;
			// debug(a, b, m);
		}
		return x%m;
		// if(false){
		// BigInteger[] A_=new BigInteger[A.length];
		// BigInteger[] B_=new BigInteger[B.length];
		// BigInteger[] M_=new BigInteger[M.length];
		// for(int i=0; i<A_.length; i++){
		// A_[i]=BigInteger.valueOf(A[i]);
		// B_[i]=BigInteger.valueOf(B[i]);
		// M_[i]=BigInteger.valueOf(M[i]);
		// }
		// BigInteger[] res=congruence(A_, B_, M_);
		// return new long[]{res[0].longValue(), res[1].longValue()};
		// }
	}

	BigInteger[] congruence(BigInteger[] A, BigInteger[] B, BigInteger[] M){
		// debug(""A"",A);
		// debug(""B"",B);
		// debug(""M"",M);
		BigInteger x=BigInteger.ZERO, m=BigInteger.ONE;
		for(int i=0; i<A.length; i++){
			BigInteger a=A[i].multiply(m), b=B[i].subtract(A[i].multiply(x)), d=a
					.gcd(M[i]);
			// debug(a,b,d);
			if(b.remainder(d).compareTo(BigInteger.ZERO)!=0)
				return null;
			// x+=m*(b/d*(a/d).modInv(M[i]/d)%(M[i]/d));
			x=x.add(m.multiply(b.divide(d)
					.multiply(a.divide(d).modInverse(M[i].divide(d)))
					.remainder(M[i].divide(d))));
			// m*=M[i]/d;
			m=m.multiply(M[i].divide(d));
		}
		return new BigInteger[]{x.remainder(m), m};
	}

	long gcd(long a, long b){
		return a==0?b:gcd(b%a, a);
	}

	long invMod(long a, long mod){
		return powMod(a, mod-2, mod);
	}

	ArrayList<Integer> candidate(int p){
		ArrayList<Integer> list=new ArrayList<Integer>();
		for(int i=0; i<p; i++){
			if(f(i, p)==0&&df(i, p)==0){
				list.add(i);
			}
		}
		return list;
	}

	long mulMod(long x, long y, long mod){
		if(y==0)
			return 0;
		if((y&1)==0)
			return mulMod((x<<1)%mod, y>>>1, mod);
		return (x+mulMod(x, y-1, mod))%mod;
	}

	long powMod(long x, long k, int mod){
		if(k==0){
			return 1%mod;
		}
		if(k%2==0){
			return powMod(x*x%mod, k>>>1, mod);
		}
		return x*powMod(x, k-1, mod)%mod;
	}

	long powMod(long x, long k, long mod){
		if(k==0){
			return 1%mod;
		}
		if(k%2==0){
			// return powMod(x*x%mod, k>>>1, mod);
			return powMod(mulMod(x, x, mod), k>>>1, mod);
		}
		// return x*powMod(x, k-1, mod)%mod;
		return mulMod(x, powMod(x, k-1, mod), mod);
	}

	long f(long x, int mod){
		long val=0;
		for(int i=0; i<n; i++){
			val=(val+as[i]%mod*powMod(x, bs[i], mod)%mod)%mod;
		}
		return val;
	}

	long df(long x, int mod){
		long val=0;
		for(int i=0; i<n; i++){
			if(bs[i]>0){
				val=(val+bs[i]%mod*as[i]%mod*powMod(x, bs[i]-1, mod)%mod)%mod;
			}
		}
		return val;
	}

	long nextPrime(long n){
		for(n++; !BigInteger.valueOf(n).isProbablePrime(200); n++);
		return n;
	}

	void debug(Object... os){
		System.err.println(Arrays.deepToString(os));
	}

	void print(String s){
		System.out.print(s);
	}

	void println(String s){
		System.out.println(s);
	}

	public static void main(String[] args) throws Exception{
		new Main().run();
	}
}"
191,"import java.util.*;
import java.io.*;
import java.math.*;
public class Main {
	static boolean DEBUG;
	public static void main(String[] args) {
		DEBUG = args.length > 0 && args[0].equals(""-DEBUG"");
		Solver solver = new Solver();
		solver.solve();
		solver.exit();
	}

	static class FastScanner {
		private final InputStream in = System.in;
		private final byte[] buffer = new byte[1024];
		private int ptr = 0;
		private int buflen = 0;
		private boolean hasNextByte() {
			if(ptr < buflen) {
				return true;
			}else{
				ptr = 0;
				try {
					buflen = in.read(buffer);
				} catch (IOException e) {
					e.printStackTrace();
				}
				if(buflen <= 0) {
					return false;
				}
			}
			return true;
		}
		private int readByte() { if(hasNextByte()) return buffer[ptr++]; else return -1;}
		private boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}
		private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}
		public boolean hasNext() { skipUnprintable(); return hasNextByte();}
		public String next() {
			if(!hasNext()) throw new NoSuchElementException();
			StringBuilder sb = new StringBuilder();
			int b = readByte();
			while(isPrintableChar(b)) {
				sb.appendCodePoint(b);
				b = readByte();
			}
			return sb.toString();
		}
		public long nextLong() {
			if(!hasNext()) throw new NoSuchElementException();
			long n = 0;
			boolean minus = false;
			int b = readByte();
			if(b == '-') {
				minus = true;
				b = readByte();
			}
			if(b < '0' || '9' < b) {
				throw new NumberFormatException();
			}
			while(true){
				if('0' <= b && b <= '9') {
					n *= 10;
					n += b - '0';
				}else if(b == -1 || !isPrintableChar(b)){
					return minus ? -n : n;
				}else{
					throw new NumberFormatException();
				}
				b = readByte();
			}
		}
	}

	static class Solver {
		FastScanner sc = new FastScanner();
		public Solver() { }

		String ns() { return sc.next(); }
		String[] ns(int n) {
			String a[] = new String[n];
			for(int i = 0; i < n; i ++) { a[i] = ns(); }
			return a;
		}
		String[][] ns(int n, int m) {
			String a[][] = new String[n][m];
			for(int i = 0; i < n; i ++) { a[i] = ns(m); }
			return a;
		}
		char[] nc(int n) {
			String str = ns();
			if(n < 0) n = str.length();
			char a[] = new char[n];
			for(int i = 0; i < n; i ++) { a[i] = str.charAt(i); }
			return a;
		}
		char[][] nc(int n, int m) {
			char a[][] = new char[n][m];
			for(int i = 0; i < n; i ++) { a[i] = nc(m); }
			return a;
		}
		boolean[] nb(int n, char t) {
			char c[] = nc(-1);
			if(n < 0) n = c.length;
			boolean a[] = new boolean[n];
			for(int i = 0; i < n; i ++) { a[i] = c[i] == t; }
			return a;
		}
		boolean[][] nb(int n, int m, char t) {
			boolean a[][] = new boolean[n][m];
			for(int i = 0; i < n; i ++) { a[i] = nb(m, t); }
			return a;
		}
		int ni() { return (int)sc.nextLong(); }
		int[] ni(int n) {
			int a[] = new int[n];
			for(int i = 0; i < n; i ++) { a[i] = ni(); }
			return a;
		}
		int[][] ni(int n, int m) {
			int a[][] = new int[n][m];
			for(int i = 0; i < n; i ++) { a[i] = ni(m); }
			return a;
		}
		long nl() { return sc.nextLong(); }
		long[] nl(int n) {
			long a[] = new long[n];
			for(int i = 0; i < n; i ++) { a[i] = nl(); }
			return a;
		}
		long[][] nl(int n, int m) {
			long a[][] = new long[n][m];
			for(int i = 0; i < n; i ++) { a[i] = nl(m); }
			return a;
		}
		double nd() { return Double.parseDouble(sc.next()); }
		double[] nd(int n) {
			double a[] = new double[n];
			for(int i = 0; i < n; i ++) { a[i] = nd(); }
			return a;
		}
		double[][] nd(int n, int m) {
			double a[][] = new double[n][m];
			for(int i = 0; i < n; i ++) { a[i] = nd(m); }
			return a;
		}

		PrintWriter out = new PrintWriter(System.out);
		PrintWriter err = new PrintWriter(System.err);
		void prt() { out.print(""""); }
		<T> void prt(T a) { out.print(a); }
		void prtln() { out.println(""""); }
		<T> void prtln(T a) { out.println(a); }
		void prtln(int... a) {
			StringBuilder sb = new StringBuilder();
			for(int element : a){ sb.append(element+"" ""); }
			prtln(sb.toString().trim());
		}
		void prtln(long... a) {
			StringBuilder sb = new StringBuilder();
			for(long element : a){ sb.append(element+"" ""); }
			prtln(sb.toString().trim());
		}
		void prtln(double... a) {
			StringBuilder sb = new StringBuilder();
			for(double element : a){ sb.append(element+"" ""); }
			prtln(sb.toString().trim());
		}
		void prtln(String... a) {
			StringBuilder sb = new StringBuilder();
			for(String element : a){ sb.append(element+"" ""); }
			prtln(sb.toString().trim());
		}
		void prtln(char... a) {
			StringBuilder sb = new StringBuilder();
			for(char element : a){ sb.append(element); }
			prtln(sb.toString().trim());
		}
		void prtln(int[][] a) { for(int[] element : a){ prtln(element); } }
		void prtln(long[][] a) { for(long[] element : a){ prtln(element); } }
		void prtln(double[][] a) { for(double[] element : a){ prtln(element); } }
		void prtln(String[][] a) { for(String[] element : a){ prtln(element); } }
		void prtln(char[][] a) { for(char[] element : a){ prtln(element); } }
		String errconvert(int a) { return isINF(a) ? ""_"" : String.valueOf(a); }
		String errconvert(long a) { return isINF(a) ? ""_"" : String.valueOf(a); }
		void errprt(int a) { if(DEBUG) { err.print(errconvert(a)); } }
		void errprt(long a) { if(DEBUG) { err.print(errconvert(a)); } }
		void errprt() { if(DEBUG) { err.print(""""); } }
		<T> void errprt(T a) { if(DEBUG) { err.print(a); } }
		void errprt(boolean a) { if(DEBUG) { errprt(a ? ""#"" : "".""); } }
		void errprtln() { if(DEBUG) { err.println(""""); } }
		void errprtln(int a) { if(DEBUG) { err.println(errconvert(a)); } }
		void errprtln(long a) { if(DEBUG) { err.println(errconvert(a)); } }
		<T> void errprtln(T a) { if(DEBUG) { err.println(a); } }
		void errprtln(boolean a) { if(DEBUG) { errprtln(a ? ""#"" : "".""); } }
		void errprtln(int... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(int element : a){ sb.append(errconvert(element)+"" ""); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(long... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(long element : a){ sb.append(errconvert(element)+"" ""); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(double... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(double element : a){ sb.append(element+"" ""); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(String... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(String element : a){ sb.append(element+"" ""); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(char... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(char element : a){ sb.append(element); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(boolean... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(boolean element : a){ sb.append((element ? ""#"" : ""."")+"" ""); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(int[][] a) { if(DEBUG) { for(int[] element : a){ errprtln(element); } } }
		void errprtln(long[][] a) { if(DEBUG) { for(long[] element : a){ errprtln(element); } } }
		void errprtln(double[][] a) { if(DEBUG) { for(double[] element : a){ errprtln(element); } } }
		void errprtln(String[][] a) { if(DEBUG) { for(String[] element : a){ errprtln(element); } } }
		void errprtln(char[][] a) { if(DEBUG) { for(char[] element : a){ errprtln(element); } } }
		void errprtln(boolean[][] a) { if(DEBUG) { for(boolean[] element : a){ errprtln(element); } } }

		void reply(boolean b) { prtln(b ? ""Yes"" : ""No""); }
		void REPLY(boolean b) { prtln(b ? ""YES"" : ""NO""); }

		void flush() { out.flush(); if(DEBUG) { err.flush(); } }
		void exit() { flush(); System.exit(0); }
		void assertion(boolean b) { if(!b) throw new AssertionError(); }

		int min(int a, int b) { return Math.min(a, b); }
		long min(long a, long b) { return Math.min(a, b); }
		double min(double a, double b) { return Math.min(a, b); }
		int min(int... x) {
			int min = x[0];
			for(int val : x) { min = min(min, val); }
			return min;
		}
		long min(long... x) {
			long min = x[0];
			for(long val : x) { min = min(min, val); }
			return min;
		}
		double min(double... x) {
			double min = x[0];
			for(double val : x) { min = min(min, val); }
			return min;
		}
		int max(int a, int b) { return Math.max(a, b); }
		long max(long a, long b) { return Math.max(a, b); }
		double max(double a, double b) { return Math.max(a, b); }
		int max(int... x) {
			int max = x[0];
			for(int val : x) { max = max(max, val); }
			return max;
		}
		long max(long... x) {
			long max = x[0];
			for(long val : x) { max = max(max, val); }
			return max;
		}
		double max(double... x) {
			double max = x[0];
			for(double val : x) { max = max(max, val); }
			return max;
		}
		long sum(int... a) {
			long sum = 0;
			for(int element : a) { sum += element; }
			return sum;
		}
		long sum(long... a) {
			long sum = 0;
			for(long element : a) { sum += element; }
			return sum;
		}
		double sum(double... a) {
			double sum = 0;
			for(double element : a) { sum += element; }
			return sum;
		}
		long sum(boolean... a) {
			long sum = 0;
			for(boolean element : a) { sum += element ? 1 : 0; }
			return sum;
		}
		long[] sums(int[] a) {
			long sum[] = new long[a.length + 1];
			sum[0] = 0;
			for(int i = 0; i < a.length; i ++) { sum[i + 1] = sum[i] + a[i]; }
			return sum;
		}
		long[] sums(long[] a) {
			long sum[] = new long[a.length + 1];
			sum[0] = 0;
			for(int i = 0; i < a.length; i ++) { sum[i + 1] = sum[i] + a[i]; }
			return sum;
		}
		double[] sums(double[] a) {
			double sum[] = new double[a.length + 1];
			sum[0] = 0;
			for(int i = 0; i < a.length; i ++) { sum[i + 1] = sum[i] + a[i]; }
			return sum;
		}
		long[] sums(boolean[] a) {
			long sum[] = new long[a.length + 1];
			sum[0] = 0;
			for(int i = 0; i < a.length; i ++) { sum[i + 1] = sum[i] + (a[i] ? 1 : 0); }
			return sum;
		}
		long[][] sums(int[][] a) {
			long sum[][] = new long[a.length + 1][a[0].length + 1];
			fill(sum, 0);
			for(int i = 0; i < a.length; i ++) {
				for(int j = 0; j < a[i].length; j ++) {
					sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + a[i][j];
				}
			}
			return sum;
		}
		long[][] sums(long[][] a) {
			long sum[][] = new long[a.length + 1][a[0].length + 1];
			fill(sum, 0);
			for(int i = 0; i < a.length; i ++) {
				for(int j = 0; j < a[i].length; j ++) {
					sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + a[i][j];
				}
			}
			return sum;
		}
		double[][] sums(double[][] a) {
			double sum[][] = new double[a.length + 1][a[0].length + 1];
			fill(sum, 0);
			for(int i = 0; i < a.length; i ++) {
				for(int j = 0; j < a[i].length; j ++) {
					sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + a[i][j];
				}
			}
			return sum;
		}
		long[][] sums(boolean[][] a) {
			long sum[][] = new long[a.length + 1][a[0].length + 1];
			fill(sum, 0);
			for(int i = 0; i < a.length; i ++) {
				for(int j = 0; j < a[i].length; j ++) {
					sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + (a[i][j] ? 1 : 0);
				}
			}
			return sum;
		}
		int constrain(int x, int l, int r) { return min(max(x, min(l, r)), max(l, r)); }
		long constrain(long x, long l, long r) { return min(max(x, min(l, r)), max(l, r)); }
		double constrain(double x, double l, double r) { return min(max(x, min(l, r)), max(l, r)); }

		int abs(int x) { return x >= 0 ? x : - x; }
		long abs(long x) { return x >= 0 ? x : - x; }
		double abs(double x) { return x >= 0 ? x : - x; }
		int signum(int x) { return x > 0 ? 1 : x < 0 ? -1 : 0; }
		int signum(long x) { return x > 0 ? 1 : x < 0 ? -1 : 0; }
		int signum(double x) { return x > 0 ? 1 : x < 0 ? -1 : 0; }
		long round(double x) { return Math.round(x); }
		long floor(double x) { return (long)Math.floor(x); }
		int divfloor(int a, int b) { return signum(a) == signum(b) ? a / b : - divceil(abs(a), abs(b)); }
		long divfloor(long a, long b) { return signum(a) == signum(b) ? a / b : - divceil(abs(a), abs(b)); }
		long ceil(double x) { return (long)Math.ceil(x); }
		int divceil(int a, int b) { return a >= 0 && b > 0 ? (a + b - 1) / b
											: a < 0 && b < 0 ? divceil(abs(a), abs(b))
											: - divfloor(abs(a), abs(b)); }
		long divceil(long a, long b) { return a >= 0 && b > 0 ? (a + b - 1) / b
											: a < 0 && b < 0 ? divceil(abs(a), abs(b))
											: - divfloor(abs(a), abs(b)); }
		double sqrt(int x) { return Math.sqrt((double)x); }
		double sqrt(long x) { return Math.sqrt((double)x); }
		double sqrt(double x) { return Math.sqrt(x); }
		double pow(double x, double y) { return Math.pow(x, y); }
		long pow(long x, long y) {
			if(y == 0) { return 1;
			}else {
				long tmp = pow(x, y / 2);
				return tmp * tmp * (y % 2 == 0 ? 1 : x);
			}
		}
		int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }
		long gcd(long a, long b) { return b == 0 ? a : gcd(b, a % b); }
		long lcm(long a, long b) { return a / gcd(a, b) * b; }
		int gcd(int[] array) {
			int gcd = 0;
			for(int i = 0; i < array.length; i ++) { gcd = gcd(gcd, array[i]); }
			return gcd;
		}
		long gcd(long[] array) {
			long gcd = 0;
			for(int i = 0; i < array.length; i ++) { gcd = gcd(gcd, array[i]); }
			return gcd;
		}

		int upperToInt(char a) { return a - 'A'; }
		int lowerToInt(char a) { return a - 'a'; }
		int numToInt(char a) { return a - '0'; }
		int charToInt(char a) { return a >= 'a' ? lowerToInt(a) : a >= 'A' ? upperToInt(a) : numToInt(a); }
		char intToUpper(int a) { return (char)(a + 'A'); }
		char intToLower(int a) { return (char)(a + 'a'); }
		char intToNum(int a) { return (char)(a + '0'); }
		int[] charToInt(char[] a) {
			int array[] = new int[a.length];
			for(int i = 0; i < a.length; i ++) { array[i] = charToInt(a[i]); }
			return array;
		}

		long[] div(long a) {
			List<Long> divList = new ArrayList<Long>();
			for(long i = 1; i * i <= a; i ++) {
				if(a % i == 0) {
					divList.add(i);
					if(i * i != a) { divList.add(a / i); };
				}
			}

			long div[] = new long[divList.size()];
			for(int i = 0; i < divList.size(); i ++) { div[i] = divList.get(i); }
			return div;
		}

		long[][] factor(long a) {
			List<Long> factorList = new ArrayList<Long>();
			List<Long> degreeList = new ArrayList<Long>();
			for(long i = 2; i * i <= a; i ++) {
				if(a % i == 0) {
					long count = 0;
					while(a % i == 0) {
						a /= i;
						count ++;
					}
					factorList.add(i);
					degreeList.add(count);
				}
			}
			if(a > 1) {
				factorList.add(a);
				degreeList.add(1L);
			}
			long factor[][] = new long[factorList.size()][2];
			for(int i = 0; i < factorList.size(); i ++) {
				factor[i][0] = factorList.get(i);
				factor[i][1] = degreeList.get(i);
			}
			Arrays.sort(factor, (sort1, sort2) -> Long.compare(sort1[0], sort2[0]));
			return factor;
		}

		boolean isPrime(long x) {
			boolean ok = x > 1;
			for(long i = 2; i * i <= x; i ++) {
				ok &= x % i != 0;
				if(!ok) return ok;
			}
			return ok;
		}
		boolean[] prime(int num) {
			boolean prime[] = new boolean[num];
			fill(prime, true);
			prime[0] = false;
			prime[1] = false;
			for(int i = 2; i < num; i ++) {
				if(prime[i]) {
					for(int j = 2; i * j < num; j ++) {
						prime[i * j] = false;
					}
				}
			}
			return prime;
		}

		long[][] countElements(long[] a, boolean sort) {
			int len = a.length;
			long array[] = new long[len];
			for(int i = 0; i < len; i ++) {
				array[i] = a[i];
			}
			if(sort) { Arrays.sort(array); }
			List<Long> elem = new ArrayList<Long>();
			List<Long> cnt = new ArrayList<Long>();
			long tmp = 1;
			for(int i = 1; i <= len; i ++) {
				if(i == len || array[i] != array[i - 1]) {
					elem.add(array[i - 1]);
					cnt.add(tmp);
					tmp = 1;
				}else {
					tmp ++;
				}
			}
			long counts[][] = new long[elem.size()][2];
			for(int i = 0; i < elem.size(); i ++) {
				counts[i][0] = elem.get(i);
				counts[i][1] = cnt.get(i);
			}
			return counts;
		}
		long[][] countElements(String str, boolean sort) {
			int len = str.length();
			char array[] = str.toCharArray();
			if(sort) { Arrays.sort(array); }
			List<Long> elem = new ArrayList<Long>();
			List<Long> cnt = new ArrayList<Long>();
			long tmp = 1;
			for(int i = 1; i <= len; i ++) {
				if(i == len || array[i] != array[i - 1]) {
					elem.add((long)array[i - 1]);
					cnt.add(tmp);
					tmp = 1;
				}else {
					tmp ++;
				}
			}
			long counts[][] = new long[elem.size()][2];
			for(int i = 0; i < elem.size(); i ++) {
				counts[i][0] = elem.get(i);
				counts[i][1] = cnt.get(i);
			}
			return counts;
		}

		int[] baseConvert(long x, int n, int len) {
			int digit[] = new int[len];
			int i = 0;
			long tmp = x;
			while(tmp > 0 && i < len) { digit[i ++] = (int)(tmp % n); tmp /= n; }
			return digit;
		}
		int[] baseConvert(long x, int n) {
			long tmp = x;
			int len = 0;
			while(tmp > 0) { tmp /= n; len ++; }
			return baseConvert(x, n, len);
		}
		int[] baseConvert(int x, int n, int len) {
			int digit[] = new int[len];
			int i = 0;
			int tmp = x;
			while(tmp > 0 && i < len) { digit[i ++] = (int)(tmp % n); tmp /= n; }
			return digit;
		}
		int[] baseConvert(int x, int n) {
			int tmp = x;
			int len = 0;
			while(tmp > 0) { tmp /= n; len ++; }
			return baseConvert(x, n, len);
		}

		int numDigits(long a) { return Long.toString(a).length(); }
		long bitFlag(int a) { return 1L << (long)a; }
		boolean isFlagged(long x, int a) { return (x & bitFlag(a)) != 0; }

		long countString(String str, String a) { return (str.length() - str.replace(a, """").length()) / a.length(); }
		long countStringAll(String str, String a) { return str.length() - str.replaceAll(a, """").length(); }

		int lowerBound(int[] array, int key) {
			return BS(array, key, true, true, true);
		}
		int lowerBound(int[] array, int key, int ng, int ok) {
			return BS(array, key, true, true, true, ng, ok);
		}
		int upperBound(int[] array, int key) {
			return BS(array, key, true, true, false);
		}
		int upperBound(int[] array, int key, int ng, int ok) {
			return BS(array, key, true, true, false, ng, ok);
		}
		int cntBS(int[] array, int key, boolean ascending, boolean greater, boolean equals) {
			return BS(array, key, ascending, greater, equals, true);
		}
		int cntBS(int[] array, int key, boolean ascending, boolean greater, boolean equals, int ng, int ok) {
			return BS(array, key, ascending, greater, equals, true, ng, ok);
		}
		int BS(int[] array, int key, boolean ascending, boolean greater, boolean equals) {
			return BS(array, key, ascending, greater, equals, false);
		}
		int BS(int[] array, int key, boolean ascending, boolean greater, boolean equals, int ng, int ok) {
			return BS(array, key, ascending, greater, equals, false, ng, ok);
		}
		int BS(int[] array, int key, boolean ascending, boolean greater, boolean equals, boolean count) {
			int ng = ascending ^ greater ? array.length : -1;
			int ok = ascending ^ greater ? -1 : array.length;
			return BS(array, key, ascending, greater, equals, count, ng, ok);
		}
		int BS(int[] array, int key, boolean ascending, boolean greater, boolean equals, boolean count, int ng, int ok) {
			int index = binarySearch(array, key, greater, equals, ng, ok);
			return count ? (int)abs(ok - index) : index;
		}
		int binarySearch(int[] array, int key, boolean greater, boolean equals, int ng, int ok) {
			while (abs(ok - ng) > 1) {
				int mid = (ok + ng) / 2;
				if(isOKforBinarySearch(array, mid, key, greater, equals)) {
					ok = mid;
				}else {
					ng = mid;
				}
			}
			return ok;
		}
		boolean isOKforBinarySearch(int[] array, int index, int key, boolean greater, boolean equals) {
			return (array[index] > key && greater)
				|| (array[index] < key && !greater)
				|| (array[index] == key && equals);
		}
		int lowerBound(long[] array, long key) {
			return BS(array, key, true, true, true);
		}
		int lowerBound(long[] array, long key, int ng, int ok) {
			return BS(array, key, true, true, true, ng, ok);
		}
		int upperBound(long[] array, long key) {
			return BS(array, key, true, true, false);
		}
		int upperBound(long[] array, long key, int ng, int ok) {
			return BS(array, key, true, true, false, ng, ok);
		}
		int cntBS(long[] array, long key, boolean ascending, boolean greater, boolean equals) {
			return BS(array, key, ascending, greater, equals, true);
		}
		int cntBS(long[] array, long key, boolean ascending, boolean greater, boolean equals, int ng, int ok) {
			return BS(array, key, ascending, greater, equals, true, ng, ok);
		}
		int BS(long[] array, long key, boolean ascending, boolean greater, boolean equals) {
			return BS(array, key, ascending, greater, equals, false);
		}
		int BS(long[] array, long key, boolean ascending, boolean greater, boolean equals, int ng, int ok) {
			return BS(array, key, ascending, greater, equals, false, ng, ok);
		}
		int BS(long[] array, long key, boolean ascending, boolean greater, boolean equals, boolean count) {
			int ng = ascending ^ greater ? array.length : -1;
			int ok = ascending ^ greater ? -1 : array.length;
			return BS(array, key, ascending, greater, equals, count, ng, ok);
		}
		int BS(long[] array, long key, boolean ascending, boolean greater, boolean equals, boolean count, int ng, int ok) {
			int index = binarySearch(array, key, greater, equals, ng, ok);
			return count ? (int)abs(ok - index) : index;
		}
		int binarySearch(long[] array, long key, boolean greater, boolean equals, int ng, int ok) {
			while (abs(ok - ng) > 1) {
				int mid = (ok + ng) / 2;
				if(isOKforBinarySearch(array, mid, key, greater, equals)) {
					ok = mid;
				}else {
					ng = mid;
				}
			}
			return ok;
		}
		boolean isOKforBinarySearch(long[] array, int index, long key, boolean greater, boolean equals) {
			return (array[index] > key && greater)
				|| (array[index] < key && !greater)
				|| (array[index] == key && equals);
		}
		int lowerBound(double[] array, double key) {
			return BS(array, key, true, true, true);
		}
		int lowerBound(double[] array, double key, int ng, int ok) {
			return BS(array, key, true, true, true, ng, ok);
		}
		int upperBound(double[] array, double key) {
			return BS(array, key, true, true, false);
		}
		int upperBound(double[] array, double key, int ng, int ok) {
			return BS(array, key, true, true, false, ng, ok);
		}
		int cntBS(double[] array, double key, boolean ascending, boolean greater, boolean equals) {
			return BS(array, key, ascending, greater, equals, true);
		}
		int cntBS(double[] array, double key, boolean ascending, boolean greater, boolean equals, int ng, int ok) {
			return BS(array, key, ascending, greater, equals, true, ng, ok);
		}
		int BS(double[] array, double key, boolean ascending, boolean greater, boolean equals) {
			return BS(array, key, ascending, greater, equals, false);
		}
		int BS(double[] array, double key, boolean ascending, boolean greater, boolean equals, int ng, int ok) {
			return BS(array, key, ascending, greater, equals, false, ng, ok);
		}
		int BS(double[] array, double key, boolean ascending, boolean greater, boolean equals, boolean count) {
			int ng = ascending ^ greater ? array.length : -1;
			int ok = ascending ^ greater ? -1 : array.length;
			return BS(array, key, ascending, greater, equals, count, ng, ok);
		}
		int BS(double[] array, double key, boolean ascending, boolean greater, boolean equals, boolean count, int ng, int ok) {
			int index = binarySearch(array, key, greater, equals, ng, ok);
			return count ? (int)abs(ok - index) : index;
		}
		int binarySearch(double[] array, double key, boolean greater, boolean equals, int ng, int ok) {
			while (abs(ok - ng) > 1) {
				int mid = (ok + ng) / 2;
				if(isOKforBinarySearch(array, mid, key, greater, equals)) {
					ok = mid;
				}else {
					ng = mid;
				}
			}
			return ok;
		}
		boolean isOKforBinarySearch(double[] array, int index, double key, boolean greater, boolean equals) {
			return (array[index] > key && greater)
				|| (array[index] < key && !greater)
				|| (array[index] == key && equals);
		}
		<T> int lowerBound(T[] array, T key, Comparator<? super T> c) {
			return BS(array, key, true, true, true, c);
		}
		<T> int lowerBound(T[] array, T key, int ng, int ok, Comparator<? super T> c) {
			return BS(array, key, true, true, true, ng, ok, c);
		}
		<T> int upperBound(T[] array, T key, Comparator<? super T> c) {
			return BS(array, key, true, true, false, c);
		}
		<T> int upperBound(T[] array, T key, int ng, int ok, Comparator<? super T> c) {
			return BS(array, key, true, true, false, ng, ok, c);
		}
		<T> int cntBS(T[] array, T key, boolean ascending, boolean greater, boolean equals, Comparator<? super T> c) {
			return BS(array, key, ascending, greater, equals, true, c);
		}
		<T> int cntBS(T[] array, T key, boolean ascending, boolean greater, boolean equals, int ng, int ok, Comparator<? super T> c) {
			return BS(array, key, ascending, greater, equals, true, ng, ok, c);
		}
		<T> int BS(T[] array, T key, boolean ascending, boolean greater, boolean equals, Comparator<? super T> c) {
			return BS(array, key, ascending, greater, equals, false, c);
		}
		<T> int BS(T[] array, T key, boolean ascending, boolean greater, boolean equals, int ng, int ok, Comparator<? super T> c) {
			return BS(array, key, ascending, greater, equals, false, ng, ok, c);
		}
		<T> int BS(T[] array, T key, boolean ascending, boolean greater, boolean equals, boolean count, Comparator<? super T> c) {
			int ng = ascending ^ greater ? array.length : -1;
			int ok = ascending ^ greater ? -1 : array.length;
			return BS(array, key, ascending, greater, equals, count, ng, ok, c);
		}
		<T> int BS(T[] array, T key, boolean ascending, boolean greater, boolean equals, boolean count, int ng, int ok, Comparator<? super T> c) {
			int index = binarySearch(array, key, greater, equals, ng, ok, c);
			return count ? (int)abs(ok - index) : index;
		}
		<T> int binarySearch(T[] array, T key, boolean greater, boolean equals, int ng, int ok, Comparator<? super T> c) {
			while (abs(ok - ng) > 1) {
				int mid = (ok + ng) / 2;
				if(isOKforBinarySearch(array, mid, key, greater, equals, c)) {
					ok = mid;
				}else {
					ng = mid;
				}
			}
			return ok;
		}
		<T> boolean isOKforBinarySearch(T[] array, int index, T key, boolean greater, boolean equals, Comparator<? super T> c) {
			int compare = c.compare(array[index], key);
			return (compare > 0 && greater)
				|| (compare < 0 && !greater)
				|| (compare == 0 && equals);
		}



		void reverse(String[] array) {
			for(int i = 0; i < array.length / 2; i ++) { swap(array, i, array.length - i - 1); }
		}
		void reverse(int[] array) {
			for(int i = 0; i < array.length / 2; i ++) { swap(array, i, array.length - i - 1); }
		}
		void reverse(long[] array) {
			for(int i = 0; i < array.length / 2; i ++) { swap(array, i, array.length - i - 1); }
		}
		void reverse(double[] array) {
			for(int i = 0; i < array.length / 2; i ++) { swap(array, i, array.length - i - 1); }
		}
		void reverse(char[] array) {
			for(int i = 0; i < array.length / 2; i ++) { swap(array, i, array.length - i - 1); }
		}
		void reverse(boolean[] array) {
			for(int i = 0; i < array.length / 2; i ++) { swap(array, i, array.length - i - 1); }
		}
		<T> void reverse(T[] array) {
			for(int i = 0; i < array.length / 2; i ++) { swap(array, i, array.length - i - 1); }
		}
		void fill(int[] array, int x) { Arrays.fill(array, x); }
		void fill(long[] array, long x) { Arrays.fill(array, x); }
		void fill(double[] array, double x) { Arrays.fill(array, x); }
		void fill(char[] array, char x) { Arrays.fill(array, x); }
		void fill(boolean[] array, boolean x) { Arrays.fill(array, x); }
		void fill(int[][] array, int x) { for(int[] a : array) { fill(a, x); } }
		void fill(long[][] array, long x) { for(long[] a : array) { fill(a, x); } }
		void fill(double[][] array, double x) { for(double[] a : array) { fill(a, x); } }
		void fill(char[][] array, char x) { for(char[] a : array) { fill(a, x); } }
		void fill(boolean[][] array, boolean x) { for(boolean[] a : array) { fill(a, x); } }
		void fill(int[][][] array, int x) { for(int[][] a : array) { fill(a, x); } }
		void fill(long[][][] array, long x) { for(long[][] a : array) { fill(a, x); } }
		void fill(double[][][] array, double x) { for(double[][] a : array) { fill(a, x); } }
		void fill(char[][][] array, char x) { for(char[][] a : array) { fill(a, x); } }
		void fill(boolean[][][] array, boolean x) { for(boolean[][] a : array) { fill(a, x); } }

		int[] resize(int[] array, int m, int x) {
			int resized[] = new int[m];
			for(int i = 0; i < array.length && i + x < m; i ++) { resized[i + x] = array[i]; }
			return resized;
		}
		long[] resize(long[] array, int m, int x) {
			long resized[] = new long[m];
			for(int i = 0; i < array.length && i + x < m; i ++) { resized[i + x] = array[i]; }
			return resized;
		}
		double[] resize(double[] array, int m, int x) {
			double resized[] = new double[m];
			for(int i = 0; i < array.length && i + x < m; i ++) { resized[i + x] = array[i]; }
			return resized;
		}
		char[] resize(char[] array, int m, int x) {
			char resized[] = new char[m];
			for(int i = 0; i < array.length && i + x < m; i ++) { resized[i + x] = array[i]; }
			return resized;
		}
		boolean[] resize(boolean[] array, int m, int x) {
			boolean resized[] = new boolean[m];
			for(int i = 0; i < array.length && i + x < m; i ++) { resized[i + x] = array[i]; }
			return resized;
		}
		Object[] resize(Object[] array, int m, int x) {
			Object resized[] = new Object[m];
			for(int i = 0; i < array.length && i + x < m; i ++) { resized[i + x] = array[i]; }
			return resized;
		}

		void shuffleArray(int[] array){
			int n = array.length;
			Random rnd = new Random();
			for(int i = 0; i < n; i ++){
				int tmp = array[i];
				int randomPos = i + rnd.nextInt(n - i);
				array[i] = array[randomPos];
				array[randomPos] = tmp;
			}
		}
		void shuffleArray(long[] array){
			int n = array.length;
			Random rnd = new Random();
			for(int i = 0; i < n; i ++){
				long tmp = array[i];
				int randomPos = i + rnd.nextInt(n - i);
				array[i] = array[randomPos];
				array[randomPos] = tmp;
			}
		}
		void shuffleArray(double[] array){
			int n = array.length;
			Random rnd = new Random();
			for(int i = 0; i < n; i ++){
				double tmp = array[i];
				int randomPos = i + rnd.nextInt(n - i);
				array[i] = array[randomPos];
				array[randomPos] = tmp;
			}
		}

		void swap(String[] array, int i, int j) {
			String tmp = array[i];
			array[i] = array[j];
			array[j] = tmp;
		}
		void swap(int[] array, int i, int j) {
			int tmp = array[i];
			array[i] = array[j];
			array[j] = tmp;
		}
		void swap(long[] array, int i, int j) {
			long tmp = array[i];
			array[i] = array[j];
			array[j] = tmp;
		}
		void swap(double[] array, int i, int j) {
			double tmp = array[i];
			array[i] = array[j];
			array[j] = tmp;
		}
		void swap(char[] array, int i, int j) {
			char tmp = array[i];
			array[i] = array[j];
			array[j] = tmp;
		}
		void swap(boolean[] array, int i, int j) {
			boolean tmp = array[i];
			array[i] = array[j];
			array[j] = tmp;
		}
		<T> void swap(T[] array, int i, int j) {
			T tmp = array[i];
			array[i] = array[j];
			array[j] = tmp;
		}

		long INF = (long)1e18 + 7;
		boolean isINF(long a) { return abs(a) > INF / 1000; }
		boolean isPlusINF(long a) { return a > 0 && isINF(a); }
		boolean isMinusINF(long a) { return isPlusINF(- a); }
		int I_INF = (int)1e9 + 7;
		boolean isINF(int a) { return abs(a) > I_INF / 1000; }
		boolean isPlusINF(int a) { return a > 0 && isINF(a); }
		boolean isMinusINF(int a) { return isPlusINF(- a); }


		// mods
		final long MOD = (long)1e9 + 7; // 998244353;
		public long mod(long i) { i %= MOD; return i + (i < 0 ? MOD : 0); }

		long pow_m(long x, long y) {
			if(y == 0) { return 1;
			}else {
				long tmp = pow_m(x, y / 2);
				return mod(mod(tmp * tmp) * (y % 2 == 0 ? 1 : x));
			}
		}
		long[] pows_m(long x, int max) {
			long pow[] = new long[max + 1];
			pow[0] = 1;
			for(int i = 0; i < max; i ++) {
				pow[i + 1] = mod(pow[i] * x);
			}
			return pow;
		}

		int MAX_INV_SIZE = 100_100;
		HashMap<Long, Long> invMap = new HashMap<>();
		long inv(long x) {
			x = mod(x);
			if(invMap.containsKey(x)) { return invMap.get(x); }
			if(invMap.size() >= MAX_INV_SIZE) { return calInv(x); }
			invMap.put(x, calInv(x));
			return invMap.get(x);
		}
		long calInv(long x) { return pow_m(x, MOD - 2); }

		int MAX_FACT = 5_000_100;
		long fact[];
		long invFact[];
		boolean isFactPrepared = false;
		HashMap<Integer, long[]> factMap;
		void prepareFact() {
			fact = new long[MAX_FACT];
			Arrays.fill(fact, 0);
			invFact = new long[MAX_FACT];
			Arrays.fill(invFact, 0);
			fact[0] = 1;
			int maxIndex = min(MAX_FACT, (int)MOD);
			for(int i = 1; i < maxIndex; i ++) { fact[i] = mod(fact[i - 1] * i); }
			invFact[maxIndex - 1] = inv(fact[maxIndex - 1]);
			for(int i = maxIndex - 1; i > 0; i --) { invFact[i - 1] = mod(invFact[i] * i); }

			factMap = new HashMap<>();
			isFactPrepared = true;
		}

		long P(int n, int r) {
			if(!isFactPrepared) { prepareFact(); }
			if(n < 0 || r < 0 || n < r) { return 0; }
			if(n >= MAX_FACT) {
				if(!factMap.containsKey(n)) {
					long largeFact[] = new long[MAX_FACT];
					factMap.put(n, largeFact);
					fill(largeFact, -INF);
					largeFact[0] = 1;
				}
				long largeFact[] = factMap.get(n);
				int i = r;
				while(isINF(largeFact[i])) { i --; }
				for(; i < r; i ++) { largeFact[i + 1] = mod(largeFact[i] * (n - i)); }
				return largeFact[r];
			}
			return mod(fact[n] * invFact[n - r]);
		}
		long C(int n, int r) {
			if(!isFactPrepared) { prepareFact(); }
			if(n < 0 || r < 0 || n < r) { return 0; }
			return mod(P(n, r) * invFact[r]);
		}
		long H(int n, int r) { return C((n - 1) + r, r); }


		// grid
		class Grids {
			int h;
			int w;
			Grid[][] gs;
			Grid[] gi;
			Grids(int h, int w) {
				this.h = h;
				this.w = w;
				gs = new Grid[h][w];
				gi = new Grid[h * w];
				for(int i = 0; i < h; i ++) {
					for(int j = 0; j < w; j ++) {
						gs[i][j] = new Grid(i, j, h, w);
						gi[gs[i][j].i] = gs[i][j];
					}
				}
			}

			void init(boolean[][] b) {
				for(int i = 0; i < h; i ++) {
					for(int j = 0; j < w; j ++) {
						gs[i][j].b = b[i][j];
					}
				}
			}
			void init(long[][] val) {
				for(int i = 0; i < h; i ++) {
					for(int j = 0; j < w; j ++) {
						gs[i][j].val = val[i][j];
					}
				}
			}

			Grid get(int x, int y) { return isValid(x, y, h, w) ? gs[x][y] : null; }

			int dx[] = {0, -1, 1, 0, 0, -1, 1, -1, 1};
			int dy[] = {0, 0, 0, -1, 1, -1, -1, 1, 1};
			Grid next(int x, int y, int i) { return next(gs[x][y], i); }
			Grid next(Grid g, int i) {
				return isValid(g.x + dx[i], g.y + dy[i], g.h, g.w)
					? gs[g.x + dx[i]][g.y + dy[i]]
					: null;
			}
		}
		class Grid implements Comparable<Grid> {
			int x;
			int y;
			int h;
			int w;
			int i;
			boolean b;
			long val;

			Grid() {  }
			Grid(int x, int y, int h, int w) { init(x, y, h, w, false, 0); }
			Grid(int x, int y, int h, int w, boolean b) { init(x, y, h, w, b, 0); }
			Grid(int x, int y, int h, int w, long val) { init(x, y, h, w, false, val); }
			Grid(int x, int y, int h, int w, boolean b, long val) { init(x, y, h, w, b, val); }

			void init(int x, int y, int h, int w, boolean b, long val) {
				this.x = x;
				this.y = y;
				this.h = h;
				this.w = w;
				this.b = b;
				this.val = val;
				i = x * w + y;
			}

			@Override
			public int compareTo(Grid g) {
				return Long.compare(this.val, g.val);
			}
		}

		boolean isValid(int x, int y, int h, int w) {
			return x >= 0 && x < h && y >= 0 && y < w;
		}
		boolean isValid(Grid g) {
			return isValid(g.x, g.y, g.h, g.w);
		}

		// graph
		class Graph {
			int numNode;
			int numEdge;
			boolean directed;
			Edge edges[];
			Node nodes[];
			Node reversedNodes[];

			Graph(int numNode, int numEdge, boolean directed) {
				this.numNode = numNode;
				this.numEdge = numEdge;
				this.directed = directed;
				nodes = new Node[numNode];
				reversedNodes = new Node[numNode];
				for(int i = 0; i < numNode; i ++) {
					nodes[i] = new Node(i);
					reversedNodes[i] = new Node(i);
				}
			}

			void init(Edge[] edges) {
				this.edges = edges;
				for(Edge edge : edges) {
					nodes[edge.source].add(edge.target, edge.cost);
					if(directed) {
						reversedNodes[edge.target].add(edge.source, edge.cost);
					}else {
						nodes[edge.target].add(edge.source, edge.cost);
					}
				}
			}

			void clearNodes() {
				for(Node n : nodes) { n.clear(); }
				for(Node n : reversedNodes) { n.clear(); }
			}
		}

		class Node extends ArrayList<Edge> {
			int id;

			Node(int id) {
				this.id = id;
			}
			void add(int target, long cost) {
				add(new Edge(id, target, cost));
			}
		}

		class Edge implements Comparable<Edge> {
			int source;
			int target;
			long cost;
			Edge(int source, int target, long cost) {
				this.source = source;
				this.target = target;
				this.cost = cost;
			}

			@Override
			public int compareTo(Edge e) {
				return Long.compare(this.cost, e.cost);
			}
		}

public void solve() {
	int c[] = charToInt(nc(-1));
	int num = c.length;
	long dp[][] = new long[num + 1][2019];
	fill(dp, 0);
	for(int i = 0; i < num; i ++) {
		for(int j = 0; j < 2019; j ++) {
			dp[i + 1][(j * 10 + c[i]) % 2019] += dp[i][j];
		}
		dp[i + 1][c[i]] ++;
	}
	long ans = 0;
	for(int i = 0; i <= num; i ++) {
		ans += dp[i][0];
	}
	prtln(ans);
}



	}
}"
192,"import java.util.*;
public class Main {
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); 
        int ans = 0;
		int [] in = new int [n];
        for(int i=0;i<n;i++){in[i] = sc.nextInt();}
        Arrays.sort(in);
        for(int i=0;i<n-2;i++){
        for(int j=i+1;j<n-1;j++){
        int small = j;
        int big = n;
        int point = (small+big)/2;
        int size = point-small;               
        while(big-small>1){size = Math.max(size/2,1);
                         if(in[i]+in[j]>in[point]){small=point;point+=size;}
                         else{big=point;point-=size;}                
                        }
        ans+=small-j;
        }                              
                              }         
        System.out.println(ans);
	}
}"
193,"import java.util.Scanner;
import java.util.ArrayList;
import java.util.HashMap;
import java.lang.Integer;
import java.lang.StringBuilder;
import java.lang.Math;

public class Main {

  public static boolean isDayDreamInternal(String s) {
    if (s.length() == 0) return true;
    if (s.length() <= 4) return false;

    if (s.startsWith(""dreamer"")) {
      String next = s.substring(7);
      if (isDayDreamInternal(next)) {
        return true;
      }
    }

    if (s.startsWith(""eraser"")) {
      String next = s.substring(6);
      if (isDayDreamInternal(next)) {
        return true;
      }
    }

    if (s.startsWith(""erase"") || s.startsWith(""dream"")) {
      String next = s.substring(5);
      if (isDayDreamInternal(next)) {
        return true;
      }
    }

    return false;
  }

  public static boolean isDayDream(String s) {
    return isDayDreamInternal(s);
  }

  public static void main(String[] args) {
    Scanner in = new Scanner(System.in);
    String s = in.next();

    boolean result = isDayDream(s);

    if (result) {
      System.out.println(""YES"");
    } else {
      System.out.println(""NO"");
    }
    //System.out.println(s.substring(s.length()));
  }
}"
194,"import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Scanner;

class Main {
	public static void main(String[] args) throws IOException {
		new Main().run();
	}

	void run() {
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		long L = sc.nextLong();
		double[] t = new double[N];
		double[] v = new double[N];
		for (int i = 0; i < N; ++i) {
			t[i] = sc.nextDouble();
			v[i] = sc.nextDouble();
		}
		class T {
			double water;
			double salt;

			public T(double water, double salt) {
				this.water = water;
				this.salt = salt;
			}
		}

		double[] ans = new double[N];
		ArrayDeque<T> deque = new ArrayDeque<>();
		deque.addLast(new T(0, 0));
		deque.addLast(new T(v[0], t[0] * v[0]));
		T p = new T(0, 0);
		ans[0] = t[0];
		for (int i = 1; i < N; ++i) {
			p.water += v[i];
			p.salt += t[i] * v[i];
			deque.addFirst(new T(-p.water, -p.water * p.salt));
			while (deque.size() >= 2) {
				T t2 = deque.pollLast();
				T t1 = deque.pollLast();
				if (t1.water + p.water > L && t2.water + p.water > L)
					continue;
				if (t1.water + p.water == L) {
					deque.addLast(t1);
					break;
				}
				if (t1.water + p.water < L && L < t2.water + p.water) {
					double r1 = (t2.water + p.water - L) / (t2.water - t1.water);
					double r2 = (L - (t1.water + p.water)) / (t2.water - t1.water);
					T tLast = new T(r1 * (t1.water + p.water) + r2 * (t2.water + p.water),
							r1 * (t1.salt + p.salt) + r2 * (t2.salt + p.salt));
					tLast.water -= p.water;
					tLast.salt -= p.salt;
					deque.addLast(t1);
					deque.addLast(tLast);
					break;
				}
			}
			deque.pollFirst();
			while (deque.size() >= 2) {
				T t1 = deque.pollFirst();
				T t2 = deque.pollFirst();
				if ((t1.salt + p.salt) / (t1.water + p.water) > (t2.salt + p.salt) / (t2.water + p.water)) {
					deque.addFirst(t2);
					deque.addFirst(t1);
					break;
				}
				deque.addFirst(t2);
			}
			deque.addFirst(new T(-p.water, -p.salt));
			ans[i] = (deque.peekFirst().salt + p.salt) / (deque.peekFirst().water + p.water);
			if (deque.size() < 2)
				throw new AssertionError();
			ans[i] = (deque.peekLast().salt + p.salt) / (deque.peekLast().water + p.water);
		}
		PrintWriter pw = new PrintWriter(System.out);
		for (int i = 0; i < N; ++i) {
			pw.println(ans[i]);
		}
		pw.close();

	}

	void tr(Object... objects) {
		System.out.println(Arrays.deepToString(objects));
	}
}"
195,"import java.util.ArrayList;
import java.util.Scanner;

class Main {
	static int primeNum(int n){
		int count = 0;
		
		for(int i = 2; i <= n; i ++){
			if(isThisPrime(i)){
				count ++;
			}
		}
		
		return count;
	}
	
	static boolean isThisPrime(int n){
		if(n != 2 | n % 2 == 0){
			for(int i = 2; i < n; i = i + 1){
				if(n % i == 0){
					return false;
				}
			}
		}
		
		return true;
	}
	
    public static void main(String[] args){
    	Scanner in = new Scanner(System.in);
    	
    	while(in.hasNext()){
    		System.out.println(primeNum(in.nextInt()));
    	}
    	
    	in.close();
	}
}"
196,"import java.util.Scanner;
public class Main {
	public static void main(String[]args) {
		Scanner teclado = new Scanner (System.in);
		int a;
		int b;
		a=teclado.nextInt();
		b=teclado.nextInt();
		
		
		if(((a*2)-1) > a+b &&  (((a*2)-1)) > ((b*2)-1) ){
			System.out.println((a*2)-1);
		}else if(((b*2)-1) > a+b && ((b*2)-1) >((a*2)-1) ) {
			System.out.println((b*2)-1);			
		}else {
			System.out.println(a+b);
		}
	}
	
}
"
197,"import java.util.*;

public class Main {

  public static void main (String[] args) {

    Scanner sc = new Scanner(System.in);
    
    int N = sc.nextInt();
    
    int[] H = new int[N];

    for (int i = 0; i < N; i++) {
      H[i] = sc.nextInt();
    }

    sc.close();

    for (int i = N-2; 0 <= i; i--) {

      if (H[i] > H[i+1]) {
        if (H[i] - H[i+1] == 1) {
          H[i]--;
        } else {
          System.out.println(""No"");
          return;
        }
      }
    }

    System.out.println(""Yes"");
    
  }

}"
198,"import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.*;

public class Main {
    public static void main(String[] args) {
        PrintWriter out = new PrintWriter(System.out);
        InputStreamScanner in = new InputStreamScanner(System.in);
        new Main().solve(in, out);
        out.flush();
    }

    private void solve(InputStreamScanner in, PrintWriter out) {
        int n = in.nextInt();
        int[] a = new int[n + 1];
        for (int i = 0; i < n; i++) {
            a[i] = in.nextInt();
        }

        ArrayDeque<Act> q = new ArrayDeque<>();
        q.push(new Act(new int[0], a));
        List<Act> memo = new ArrayList<>();

        while (!q.isEmpty()) {
            Act x = q.pop();
            if (x.r[0] == 0) {
                for (int i = x.p.length - 1; i >= 0; i--) {
                    out.println(x.p[i]);
                }
                return;
            }

            for (int i = x.r.length - 1; i >= 0; i--) {
                if (x.r[i] == 0) {
                    continue;
                }
                if (x.r[i] == i + 1) {
                    int[] p = Arrays.copyOf(x.p, x.p.length + 1);
                    p[x.p.length] = i + 1;
                    int[] r = Arrays.copyOf(x.r, n + 1);
                    for (int j = i; j < n; j++) {
                        r[j] = r[j + 1];
                    }
                    Act na = new Act(p, r);
                    if (!memo.contains(na)) {
                        memo.add(na);
                        q.push(new Act(p, r));
                        break;
                    }
                }
            }
        }

        out.println(-1);
    }

    static class Act {
        int[] p;
        int[] r;

        Act (int[] p, int[] r) {
            this.p = p;
            this.r = r;
        }

        @Override
        public boolean equals(Object obj) {
            Act o = (Act)obj;
            return Arrays.equals(this.r, o.r);
        }
    }

    static class InputStreamScanner {

        private InputStream in;

        private byte[] buf = new byte[1024];
        private int len = 0;
        private int off = 0;

        InputStreamScanner(InputStream in)	{
            this.in = in;
        }

        String next() {
            StringBuilder sb = new StringBuilder();
            for (int b = skip(); !isSpace(b);){
                sb.appendCodePoint(b);
                b = read();
            }
            return sb.toString();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        char nextChar() {
            return (char)skip();
        }

        int skip() {
            for (int b; (b = read()) != -1;) {
                if (!isSpace(b)) {
                    return b;
                }
            }
            return -1;
        }

        private boolean isSpace(int c) {
            return c < 33 || c > 126;
        }

        private int read() {
            if (len == -1) {
                throw new InputMismatchException(""End of Input"");
            }
            if (off >= len){
                off = 0;
                try {
                    len = in.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException(e.getMessage());
                }
                if (len <= 0) {
                    return -1;
                }
            }
            return buf[off++];
        }
    }
}"
199,"import java.util.*;
class string_m
{
	public static void main(String args[])
	{
		Scanner sc=new Scanner(System.in);
		int n=sc.nextInt();
		ArrayList<String> str= new ArrayList<String>();
		for(int i=0;i<n;i++)
		{
		          String data=str.nextLine();
		          str.add();
		}
		HashSet set=new HashSet(str);
		set.remove(null);
		System.out.println(set.size());


	}
}"
200,"import java.math.BigInteger;
import java.util.*;

public class Main {
  public static void main(String[] args){
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    int k = sc.nextInt();
    BigInteger point = BigInteger.ONE;
    List<BigInteger> aList = new ArrayList<>();
    for (int i = 0; i < n; i++) {
      BigInteger a = new BigInteger(sc.next());
      aList.add(a);
      BigInteger prev = point;
      point = point.multiply(a);
      if (i < k) {
        continue;
      }
      point = point.divide(aList.get(i - k));
      System.out.println(point.compareTo(prev) > 0 ? ""Yes"" : ""No"");
    }
  }
}
"
