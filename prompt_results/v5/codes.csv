case_no,code_token
1,"import java.util.Arrays;
import java.util.Scanner;


public class Main {
	
	static class Team implements Comparable<Team>{
		int number;
		int time;
		
		Team(int n, int t){
			number = n;
			time = t;
		}
		
		@Override
		public int compareTo(Team arg0) {
			return Integer.compare(this.time, arg0.time);
		}
		
		@Override
		public String toString(){
			return Integer.toString(number);
		}
	}

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		while(true){
			final int n = sc.nextInt();
			
			if(n == 0){
				break;
			}
			
			Team[] array = new Team[n];
			
			for(int i = 0; i < n; i++){
				int number = sc.nextInt();
				int time = sc.nextInt()*60 + sc.nextInt()
						 + sc.nextInt()*60 + sc.nextInt()
						 + sc.nextInt()*60 + sc.nextInt()
						 + sc.nextInt()*60 + sc.nextInt();
				array[i] = new Team(number, time);
			}
			
			Arrays.sort(array);
			
			System.out.println(array[0]);
			System.out.println(array[1]);
			System.out.println(array[n-2]);
		}
		
	}

}"
2,"import java.util.Scanner;

   class Red{
     public static void main(String[] args){
       Scanner stdIn = new Scanner(System.in)
       int A = stdIn.nextInt();
       String S = stdIn.next();
       if(A < 5000 && A >= 3200){
         System.out.println(S);
       }else if(A >= 2800 && A < 3200){
         System.out.println(""red"");
       }
     }
   }"
3,"
import java.util.PriorityQueue;
import java.util.Scanner;

public class Main {

	Scanner sc;

	Main() {
		sc = new Scanner(System.in);
	}

	int encode(String a, int n) {
		int ret = 0;
		for (int i = 0; i < n; i++) {
			ret = ret << 1;

			if (a.charAt(i) == 'W') {
				ret += 1;
			}
		}
		return ret;
	}

	class S implements Comparable<S> {
		int s;
		int c;
		int p;

		S(int ss, int cc, int pp) {
			s = ss;
			c = cc;
			p = pp;
		}

		public int compareTo(S tar) {
			return c - tar.c;
		}

	}

	void run() {
		for (;;) {
			int n = sc.nextInt();
			if (n == 0) {
				break;
			}
			String a = sc.next();
			String b = sc.next();

			int s = encode(a, n);
			int g = encode(b, n);
			PriorityQueue<S> q = new PriorityQueue<S>();
			for (int sp = 0; sp < n; sp++) {
				if (((s ^ g) & (1 << sp)) != 0) {
					q.add(new S(s, 0, sp));
				}
			}
			boolean used[][] = new boolean[(1 << n)][n];
			for (;;) {
				if (q.isEmpty()) {
					System.err.println(""err"");
				}
				S now = q.poll();
				if (used[now.s][now.p]) {
					continue;
				}
				
//				System.out.println(Integer.toBinaryString((1 << 10) + now.s)
//						+ "" "" + now.p + "" "" + now.c);
				if ((now.s) == g) {
					System.out.println(now.c);
					break;
				}
				used[now.s][now.p] = true;
				for (int i = 0; i < n; i++) {
					int shi = 1 << i;
					if (((now.s & ~g) & shi) != 0) {
						for (int j = 0; j < n; j++) {
							int shj = 1 << j;
							if (((~now.s & g) & shj) != 0) {
								int cost = Math.abs(i - now.p);
								cost += Math.abs(j - i);
								int pos = j;
								int ns = now.s - shi + shj;
								if (!used[ns][pos])
									q.add(new S(ns, now.c + cost, pos));
								
								
								cost = Math.abs(j - now.p);
								cost += Math.abs(j - i);
								pos = i;
								ns = now.s - shi + shj;
								if (!used[ns][pos])
									q.add(new S(ns, now.c + cost, pos));
							}
						}
					}
				}
			}
		}
	}

	public static void main(String[] args) {
		Main m = new Main();
		m.run();
	}

}"
4,"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Scanner;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        Scanner in = new Scanner(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskD solver = new TaskD();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskD {
        public void solve(int testNumber, Scanner in, PrintWriter out) {
            final long k = in.nextLong();
            long n = k;
            long max = 3000000 * k;
            long min = Long.MAX_VALUE;
            while (n < max) {
                String s = String.valueOf(n);
                long sum = 0;
                for (int i = 0; i < s.length(); i++) {
                    sum += Long.parseLong(s.substring(i, i + 1));
                }
                if (sum < min) min = sum;
                n += k;
            }
            out.println(min);
        }

    }
}

"
1,"import java.util.Scanner;

public class Main{
	public static void main(String args[]){

		//????????????????????????
		Scanner sc = new Scanner(System.in);
		String s = sc.nextLine();
		String p = sc.nextLine();
		String ans = ""No"";

		//vanceknowledgetoad
		//advance
		for (int i = 0; i < s.length(); i++) {
			String str = s.substring(i, i + p.length());

			if(p.equals(str)){
				ans = ""Yes"";
				break;
			}
		}
		System.out.println(ans);
		sc.close();
	}
}"
2,"import java.io.*;
import java.util.*;

class Solver {
  final ModCalculator mc;
  final ModCombinationCache mcc;
  final int n;
  final int k;
  
  Solver (int n, int k) {
    this.mc = new ModCalculator(1_000_000_007L);
    this.mcc = new ModCombinationCache(n, this.mc);
    this.n = n;
    this.k = k;
  }
  
  private long solve(int i) {
    if (i > n - k + 1) {
      return 0L;
    }
    return mc.mul(mcc.getCombination(n - k + 1, i), mcc.getCombination(k - 1, i - 1));
  }
  
  public long[] solve() {
    long[] answers = new long[k];
    for (int i = 0; i < k; i++) {
      answers[i] = solve(i + 1);
    }
    return answers;
  }
}

public class Main {
  private static void execute(ContestReader reader, PrintWriter out) {
    int n = reader.nextInt();
    int k = reader.nextInt();
    long[] answers = new Solver(n, k).solve();
    for (long answer : answers) {
      out.println(answer);
    }
  }
  
  public static void main(String[] args) {
    ContestReader reader = new ContestReader(System.in);
    PrintWriter out = new PrintWriter(System.out);
    execute(reader, out);
    out.flush();
  }
}

class ContestReader {
  private BufferedReader reader;
  private StringTokenizer tokenizer;
  
  ContestReader(InputStream in) {
    reader = new BufferedReader(new InputStreamReader(in));
  }
  
  public String next() {
    while (tokenizer == null || !tokenizer.hasMoreTokens()) {
      try {
        tokenizer = new java.util.StringTokenizer(reader.readLine());
      } catch (Exception e) {
        throw new RuntimeException(e);
      }
    }
    return tokenizer.nextToken();
  }
  
  public int nextInt() {
    return Integer.parseInt(next());
  }
  
  public long nextLong() {
    return Long.parseLong(next());
  }
  
  public double nextDouble() {
    return Double.parseDouble(next());
  }
  
  public String[] nextArray(int n) {
    String[] array = new String[n];
    for (int i = 0; i < n; i++) {
      array[i] = next();
    }
    return array;
  }
  
  public int[] nextIntArray(int n) {
    int[] array = new int[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextInt();
    }
    return array;
  }
  
  public long[] nextLongArray(int n) {
    long[] array = new long[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextLong();
    }
    return array;
  }
  
  public double[] nextDoubleArray(int n) {
    double[] array = new double[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextDouble();
    }
    return array;
  }
  
  public int[][] nextIntMatrix(int n, int m) {
    int[][] matrix = new int[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextInt();
      }
    }
    return matrix;
  }
  
  public long[][] nextLongMatrix(int n, int m) {
    long[][] matrix = new long[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextLong();
      }
    }
    return matrix;
  }
  
  public double[][] nextDoubleMatrix(int n, int m) {
    double[][] matrix = new double[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextDouble();
      }
    }
    return matrix;
  }
}

class ModCalculator {
  private final long mod;
  
  ModCalculator(long mod) {
    this.mod = mod;
  }
  
  public long add(long a, long b) {
    return (a + b) % mod;
  }
  
  public long mul(long a, long b) {
    return (a * b) % mod;
  }
  
  public long pow(long a, long b) {
    if (b == 0) {
      return 1;
    }
    long v = pow(mul(a, a), b / 2);
    if (b % 2 == 1) {
      return mul(v, a);
    } else {
      return v;
    }
  }
  
  public long inverse(long a) {
    return pow(a, mod - 2);
  }
  
  public long div(long a, long b) {
    return mul(a, inverse(b));
  }
}
 
class ModCombinationCache {
  private final ModCalculator modCalculator;
  private final long[] factorialCache;
  private final long[] factorialInverseCache;
  
  public ModCombinationCache(int n, ModCalculator modCalculator) {
    this.modCalculator = modCalculator;
    factorialCache = new long[n];
    factorialCache[0] = 1;
    for (int i = 1; i < n; i++) {
      factorialCache[i] = modCalculator.mul(factorialCache[i-1], i);
    }
    
    factorialInverseCache = new long[n];
    for (int i = 0; i < n; i++) {
      factorialInverseCache[i] = modCalculator.inverse(factorialCache[i]);
    }
  }
  
  public long getFactorial(int n) {
    return factorialCache[n];
  }
  
  public long getCombination(int n, int k) {
    return modCalculator.mul(factorialCache[n], modCalculator.mul(factorialInverseCache[k], factorialInverseCache[n-k]));
  }
}

class Algorithm {
  private static void swap(Object[] list, int a, int b) {
    Object tmp = list[a];
    list[a] = list[b];
    list[b] = tmp;
  }
  
  public static <T extends Comparable<? super T>> boolean nextPermutation(T[] ts) {
    int rightMostAscendingOrderIndex = ts.length - 2;
    while (rightMostAscendingOrderIndex >= 0 &&
        ts[rightMostAscendingOrderIndex].compareTo(ts[rightMostAscendingOrderIndex + 1]) >= 0) {
      rightMostAscendingOrderIndex--;
    }
    if (rightMostAscendingOrderIndex < 0) {
      return false;
    }
    
    int rightMostGreatorIndex = ts.length - 1;
    while (ts[rightMostAscendingOrderIndex].compareTo(ts[rightMostGreatorIndex]) >= 0) {
      rightMostGreatorIndex--;
    }
    
    swap(ts, rightMostAscendingOrderIndex, rightMostGreatorIndex);
    for (int i = 0; i < (ts.length - rightMostAscendingOrderIndex - 1) / 2; i++) {
      swap(ts, rightMostAscendingOrderIndex + 1 + i, ts.length - 1 - i);
    }
    return true;
  }
  
  public static void shuffle(int[] array) {
    Random random = new Random();
    int n = array.length;
    for (int i = 0; i < n; i++) {
      int randomIndex = i + random.nextInt(n - i);
      
      int temp = array[i];
      array[i] = array[randomIndex];
      array[randomIndex] = temp;
    }
  }
  
  public static void shuffle(long[] array) {
    Random random = new Random();
    int n = array.length;
    for (int i = 0; i < n; i++) {
      int randomIndex = i + random.nextInt(n - i);
      
      long temp = array[i];
      array[i] = array[randomIndex];
      array[randomIndex] = temp;
    }
  }
  
  public static void sort(int[] array) {
    shuffle(array);
    Arrays.sort(array);
  }
  
  public static void sort(long[] array) {
    shuffle(array);
    Arrays.sort(array);
  }
}

"
3,"import java.util.*;

public class Main {
    public static void main(String[] args) throws Exception {
        // Your code here!
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int startA = sc.nextInt() - 1;
        int startB = sc.nextInt() - 1;
        int goalA = sc.nextInt() - 1;
        int goalB = sc.nextInt() - 1;
        String str = sc.next();
        String str2 = str.substring(startA, Math.max(goalA, goalB));
        String str3 = str.substring(Math.max(0, startB - 1), Math.min(n - 1, goalB + 2));
        
        if (str2.contains(""##"")) {
            System.out.println(""No"");
            return;
        }
        
        if (goalA < goalB) {
            System.out.println(""Yes"");
        } else {
            if (str3.contains(""..."")) {
                System.out.println(""Yes"");
            } else {
                System.out.println(""No"");
            }
        }
    }
}
"
4,"

import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		String t = sc.next();
		if (t.equals(""?"")) {
			System.out.println(""D"");
			return;
		}
		boolean next = false;
		int length = 0;
		for (int i = 0; i < t.length(); i++) {
			boolean is = false;
			if (next) {
				next = false;
				continue;
			}
//			if (i!= t.length()-1 && t.charAt(i) == '?' && t.charAt(i+1) == '?') {
//				length+=1;
//			}

			if (t.charAt(i) == '?') {
				if (i >= 1) {
					if (t.charAt(i-1) == 'P') {
						StringBuilder stringBuilder = new StringBuilder(t);
						stringBuilder.setCharAt(i, 'D');
						t = stringBuilder.toString();
						is = true;
					} else if (i == t.length()-1) {
						StringBuilder stringBuilder = new StringBuilder(t);
						stringBuilder.setCharAt(i, 'D');
						t = stringBuilder.toString();
						is = true;
					}
				}
				if (i != t.length()-1 && !is) {
					if (t.charAt(i+1) == 'D' || t.charAt(i+1) == '?') {
						StringBuilder stringBuilder = new StringBuilder(t);
						stringBuilder.setCharAt(i, 'P');
						stringBuilder.setCharAt(i+1, 'D');
						t = stringBuilder.toString();
						next = true;
					} else {
						StringBuilder stringBuilder = new StringBuilder(t);
						stringBuilder.setCharAt(i, 'D');
						t = stringBuilder.toString();
					}
				}
			}
		}
		System.out.println(t);
	}

}
"
5,"import java.util.*;

import lib.MyMath;

import java.io.*;


public class Main{
    public static void main(String[] args) {
        FastScanner sc = new FastScanner();
        PrintWriter out = new PrintWriter(System.out);
        int N = sc.nextInt();
        int K = sc.nextInt();
        double res = 0;
        for(int i=1;i<=N;i++){
            int pow = 0;
            while(i * MyMath.repeatSquarePow(2, pow, Integer.MAX_VALUE) <K){
                pow++;
            }
            // out.println(pow);
            res += (double) 1 / (double) MyMath.repeatSquarePow(2, pow, Integer.MAX_VALUE) / (double) N;
        }
        out.println(res);
        out.flush();
    }
}

class BinaryIndexedTree{
    int[] data;
    int[] tree;
    int n;

    public BinaryIndexedTree(int[] data){
        this.data = data;
        this.n = data.length;
        this.tree = new int[n+1];
        buildTree();
    }

    public void buildTree(){
        for(int i=0;i<n;i++){
            add(i+1, data[i]);
        }
    }

    public void add(int index, int value){
        for(int i=index; i<=n; i+=i & -i){
            tree[i] += value;
        }
    }

    public int sum(int from, int to){
        return sum(to) - sum(from-1);
    }

    public int sum(int index){
        int sum = 0;
        for(int i=index; i>0; i-=i & -i){
            sum += tree[i];
        }
        return sum;
    }
}

class nextPermutation{
    public static int[] swap(int data[], int left, int right)
    {

        // Swap the data
        int temp = data[left];
        data[left] = data[right];
        data[right] = temp;

        // Return the updated array
        return data;
    }

    // Function to reverse the sub-array
    // starting from left to the right
    // both inclusive
    public static int[] reverse(int data[], int left, int right)
    {

        // Reverse the sub-array
        while (left < right) {
            int temp = data[left];
            data[left++] = data[right];
            data[right--] = temp;
        }

        // Return the updated array
        return data;
    }

    // Function to find the next permutation
    // of the given integer array
    public static boolean findNextPermutation(int data[])
    {

        // If the given dataset is empty
        // or contains only one element
        // next_permutation is not possible
        if (data.length <= 1)
            return false;

        int last = data.length - 2;

        // find the longest non-increasing suffix
        // and find the pivot
        while (last >= 0) {
            if (data[last] < data[last + 1]) {
                break;
            }
            last--;
        }

        // If there is no increasing pair
        // there is no higher order permutation
        if (last < 0)
            return false;

        int nextGreater = data.length - 1;

        // Find the rightmost successor to the pivot
        for (int i = data.length - 1; i > last; i--) {
            if (data[i] > data[last]) {
                nextGreater = i;
                break;
            }
        }

        // Swap the successor and the pivot
        data = swap(data, nextGreater, last);

        // Reverse the suffix
        data = reverse(data, last + 1, data.length - 1);

        // Return true as the next_permutation is done
        return true;
    }
}

class graph{
    int[][] graph;
    public graph(int[][] graph){
        this.graph = graph;
    }

    public long dijkstra(int s, int t){
        Integer[] dist = new Integer[graph.length];
        int[] prev = new int[graph.length];
        Arrays.fill(prev, -1);
        PriorityQueue<Integer> manage = new PriorityQueue<>((x,y) -> dist[x]-dist[y]);
        HashSet<Integer> searched = new HashSet<>();
        Arrays.fill(dist,Integer.MAX_VALUE);
        dist[s] = 0;
        searched.add(s);
        for(int i=0;i<graph.length;i++){
            if(graph[s][i]!=Integer.MAX_VALUE){
                dist[i] = graph[s][i];
                prev[i] = s;
                manage.add(i);
            }
        }
        while(manage.size()>0){
            int now = manage.poll();
            searched.add(now);
            for(int i=0;i<graph.length;i++){
                if(graph[now][i]!=Integer.MAX_VALUE){
                    if(!searched.contains(i)){
                        if(dist[i]==Integer.MAX_VALUE){
                            dist[i] = dist[now] + graph[now][i];
                            prev[i] = now;
                            manage.add(i);
                        }
                        else{
                            dist[i] = Math.min(dist[i],dist[now]+graph[now][i]);
                            if(dist[i]==dist[now]+graph[now][i]) prev[i] = now;
                            manage.remove(i);
                            manage.add(i);
                        }
                    }
                }
            }
            if(searched.contains(t)) break;
        }

        return dist[t];
    }

    public boolean judgeBipartitegraph(){
        int[] color = new int[graph.length];
        PriorityQueue<Integer> queue = new PriorityQueue<>();
        HashSet<Integer> visited = new HashSet<>();
        queue.add(0);
        color[0] = 1;
        while(queue.size()>0){
            int now = queue.poll();
            visited.add(now);
            for(int j=0;j<graph[now].length;j++){
                if(visited.contains(j)) continue;
                if(graph[now][j]!=0){
                    if(color[j]==color[now]) return false;
                    queue.add(j);
                    if(color[j]==0) color[j] = -1*color[now];
                }
            }
        }
        return true;
    }

    public int[][] prim(){
        int[] mincost = new int[graph.length];
        boolean[] used = new boolean[graph.length];
        int[][] spanning = new int[graph.length][graph.length];
        for(int i=0;i<graph.length;i++){
            mincost[i] = Integer.MAX_VALUE;
            used[i] = false;
        }
        mincost[0] = 0;
        int totalCost = 0;
        while(true){
            int v = -1;
            for(int u=0;u<graph.length;u++){
                if(!used[u] && (v==-1||mincost[u]<mincost[v])){
                    v = u;
                }
            }
            if(v==-1) break;
            used[v] = true;
            totalCost += mincost[v];
            for(int u=0;u<graph.length;u++){
                if(graph[v][u]<mincost[u]){
                    mincost[u] = graph[v][u];
                }
            }
            for(int u=0;u<graph.length;u++){
                if(mincost[u]==graph[v][u]){
                    spanning[v][u] = 1;
                    spanning[u][v] = 1;
                    break;
                }
            }
        }
        return spanning;
        // return totalCost;
    }

    public int[][] wf(){
        int[][] dist = new int[graph.length][graph.length];
        dist = graph.clone();
        // for(int i=0;i<graph.length;i++){
        //     dist[i][i] = 0;
        // }
        for(int k=0;k<graph.length;k++){
            for(int i=0;i<graph.length;i++){
                for(int j=0;j<graph.length;j++){
                    if(dist[i][k]==Integer.MAX_VALUE || dist[k][j]==Integer.MAX_VALUE) continue;

                    dist[i][j] = Math.min(dist[i][j],dist[i][k]+dist[k][j]);

                }
            }
        }
        for(int i=0;i<graph.length;i++){
            if(dist[i][i]<0) return null;
        }
        return dist;
    }
}

class FastScanner {
    private final InputStream in = System.in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}
    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}
    public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}
    public String next() {
        if (!hasNext()) throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
    public long nextLong() {
        if (!hasNext()) throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while(true){
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() { return Double.parseDouble(next());}
}

class UnionFindTree {
    int[] root;
    int[] rank;
    int[] size;
    public UnionFindTree(int n) {
        this.root = new int[n];
        this.rank = new int[n];
        this.size = new int[n];
        for(int i=0;i<n;i++){
            root[i] = i;
            size[i] = 1;
        }
    }

    public int find(int x){
        if(root[x]==x) return x;
        else{
            return root[x] = find(root[x]);
        }
    }

    public void unite(int x, int y){
        x = find(x);
        y = find(y);
        if(x==y) return;
        if(rank[x] < rank[y]){
            size[find(y)] = size[find(x)];
            root[x] = y;
        }
        else{
            size[find(x)] = size[find(y)];
            root[y] = x;
            if(rank[x]==rank[y]) rank[x]++;
        }
    }

    public boolean same(int x, int y){
        return find(x) == find(y);
    }

    public int size(int i){
        return this.size[find(i)];
    }
}"
6,"import java.util.Scanner;

public class Main{


	public static void main(String[] args){

		int n;

		Scanner scan=new Scanner(System.in);
		n=scan.nextInt();
		int[] box=new int[n];
		int max=-1000000000;

		for(int i=0;i<n;i++){
		box[i]=scan.nextInt();
		}

		for(int i=0;i<n-1;i++){
			for(int j=i+1;j<n;j++){
				if(max<box[j]-box[i])max=box[j]-box[i];
			}
		}
		System.out.println(max);



		scan.close();

	}

}"
7,"import java.util.*;

class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int M = sc.nextInt();
        int[] A = new int[N];
        int sum = 0;
        for(int i=0; i<N; i++) {
            A[i] = sc.nextInt();
            sum += A[i];
        }
        float check = (float)sum / (4 * M);
        int count = 0;

        for(int i=0; i < N; i++) {
            
            if(A[i] >= check) count++;
        }

        if(count >= M) System.out.println(""Yes"");
        else System.out.println(""No"");       
    }
}"
8,"import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int n = in.nextInt();
		int m = in.nextInt();
		in.close();
		int mod = 1000000007;
		List<Integer> list = new ArrayList<>();
		for(int i=2;i*i<=m;i++) {
			int count = 0;
			while(m%i==0) {
				m /= i;
				count++;
			}
			if(count!=0) {
				list.add(count);
			}
		}
		if(m>1) list.add(1);
		long ans = 1;
		for(int q : list) {
			ans = (ans * comb(n+q-1,q,mod)) % mod;
		}
		System.out.println(ans);
		

	}
	
	//return pCq % r
	public static long comb(int p,int q,int mod) {
		if(p-q<q) q = p-q;
		long[] array = new long[q];
		for(int i=0;i<q;i++) {
			array[i] = p - i;
		}
		List<Integer> list = new ArrayList<>();
		for(int num=2;num<=q;num++) {
			int x = num;
			for(int i=2;i*i<=x;i++) {
				while(x%i==0) {
					x /= i;
					list.add(i);
				}
			}
			if(x>1) list.add(x);
		}
		
		for(int num : list) {
			for(int i=0;i<q;i++) {
				if(array[i]%num==0) {
					array[i] /= num;
					break;
				}
			}
		}
		
		long ans = array[0] % mod;
		for(int i=1;i<q;i++) {
			ans = (ans * (array[i] % mod))%mod;
		}
		return ans;	
	}

}
"
9,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayDeque;

public class Main{
	public static void main(String[] args)throws IOException{
		InputStreamReader isr = new InputStreamReader(System.in);
		BufferedReader reader = new BufferedReader(isr);
		ArrayDeque<int[]> que = new ArrayDeque<int[]>();
		Main app = new Main();
		String string;
		
		int map[][] = new int[100][100], max = 0, y = 0, x = 0, sum = 0, res = 0;
		while((string = reader.readLine()) != null){
			if(string.length() == 0) break;
			int hoge[] = app.splitter(string);
			max = max > hoge.length ? max : hoge.length;
			int i = 0;
			for(int var : hoge){
				map[max - 1 - i][max - hoge.length + i] = var;
				i++;
			}
		}
		
		que.addLast(new int[]{y , x, map[y][x]});
		while(!que.isEmpty()){
			y = que.getFirst()[0];
			x = que.getFirst()[1];
			sum = que.getFirst()[2];
			que.removeFirst();
			
			if(res < sum) res = sum;
			
			if(y + 1< max){ que.addLast(new int[]{y + 1, x, sum + map[y + 1][x]}); }
			if(x + 1< max){ que.addLast(new int[]{y, x + 1, sum + map[y][x + 1]}); }
		}
		System.out.println(res);
		reader.readLine();
	}
	
	public int[] splitter(String source){
		String str[] = source.split("","");
		int hoge[] = new int[str.length];
		for(int i = 0; i < str.length; i++)
			hoge[i] = Integer.valueOf(str[i]);
		return hoge;
	}
}"
10,"import java.util.Scanner;

public class Main{
	public static void main(String[] args){
		Scanner scan=new Scanner(System.in);
		int i,j,n,q,count=0,mid;
		n=scan.nextInt();
		int[] s=new int[n];
		for(i=0;i<n;i++) {
			s[i]=scan.nextInt();
		}
		mid=n/2;
		q=scan.nextInt();
		int[] t=new int[q];
		for(i=0;i<q;i++) {
			t[i]=scan.nextInt();
		}
		for(i=0;i<q;i++) {
			if(t[i]<s[mid]) {
				for(j=0;j<mid;j++) {
					if(t[i]==s[j]) {
						count++;
						break;
					}
				}
			}
			else {
				for(j=mid;j<n;j++) {
					if(t[i]==s[j]) {
						count++;
						break;
					}
				}
			}
		}
		System.out.println(count);
	}
}
"
11,"package jp.lemon;

import java.util.Scanner;

public class Example {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);

		int n1 = 0;
		int n2 = 0;
		int n3 = 0;
		int num = 0;
		for (int i = 0; i < 10; i++) {
			num = scan.nextInt();
			if (num >= n1) {
				n3 = n2;
				n2 = n1;
				n1 = num;
			} else if (num >= n2) {
				n3 = n2;
				n2 = num;
			} else if (num >= n3) {
				n3 = num;
			}
		}
		System.out.println(n1 + ""\n"" + n2 + ""\n"" + n3);
	}
}"
12,"import java.util.Scanner;

public class Main {
    void run() {
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt();
        int k = scan.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = scan.nextInt();
            if (a[i] == k) {
                System.out.println(""POSSIBLE"");
                return;
            }
        }
        int max = 0;
        for (int num : a)
            max = Math.max(max, num);
        int g = calcGcd(a);
//        System.out.println(g);
        if (k%g == 0 && max >= k)
            System.out.println(""POSSIBLE"");
        else
            System.out.println(""IMPOSSIBLE"");
    }
    
    int calcGcd(int... params) {
        int length = params.length;
        int g = gcd(params[0], params[1]);
        if (g == 1)
            return g;
        for (int i = 0; i < length - 1; i++) {
            g = gcd(g, params[i + 1]);
        }
        return g;
    }
    
    int gcd(int a, int b) {
        if (b == 0)
            return a;
        return gcd(b, a % b);
    }

    public static void main(String[] args) {
        new Main().run();
    }
}
"
13,"import java.util.Scanner;

public class one {
	public static void main(String[] args){
		try(Scanner input = new Scanner(System.in)){
			String testCase = input.nextLine();
			solution(testCase);
		}
	}
	public static void solution(String str){
		String onesDigit = str.substring(str.length()-1);
		int x = Integer.parseInt(onesDigit);
		if (x==2||x==4||x==5||x==7||x==9){
			System.out.println(""hon"");
		}
		if (x==0||x==1||x==6||x==8){
			System.out.println(""pon"");
		}
		if (x==3){
			System.out.println(""bon"");
		}
	}
}
"
14,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
	public static int N;
	public static long C;
	public static long[] positions, values, prefixes, suffixes;
	public static boolean[][][] visited = new boolean[102][102][2];

	public static void main(String[] args) throws IOException {
		BufferedReader f = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(f.readLine());
		N = Integer.parseInt(st.nextToken());
		C = Long.parseLong(st.nextToken());
		positions = new long[N + 1];
		values = new long[N + 1];
		prefixes = new long[N + 1];
		suffixes = new long[N + 1];
		positions[0] = 0;
		values[0] = 0;
		for (int i = 0; i < N; i++) {
			st = new StringTokenizer(f.readLine());
			long x = Long.parseLong(st.nextToken());
			long v = Long.parseLong(st.nextToken());
			positions[i + 1] = x;
			values[i + 1] = v;
		}
		for (int i = 1; i <= N; i++) {
			prefixes[i] = prefixes[i - 1] + values[i];
		}
		for (int i = N - 1; i >= 0; i--) {
			suffixes[i] = suffixes[i + 1] + values[i + 1];
		}
		long res = 0;
		for (int i = 0; i <= N; i++) {
			res = Math.max(res, prefixes[i] - positions[i]);
			res = Math.max(res, suffixes[i] - (C - positions[i]));
			for (int j = i + 1; j <= N; j++) {
				res = Math.max(res, prefixes[i] + suffixes[j - 1] - positions[i] - positions[i] - (C - positions[j]));
				res = Math.max(res, prefixes[i] + suffixes[j - 1] - 2 * (C - positions[j]) - positions[i]);
			}
		}
		System.out.println(res);
	}
}"
15,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.*;

public class Main {

    int N;
    int count = 0;
    Map<Integer, List<Integer>> map = new HashMap<>();

    public static void main(String[] args) throws IOException {
        new Main().run();
    }

    void run() {
        Scanner sc = new Scanner(System.in);
        N = sc.nextInt();
        int M = sc.nextInt();

        for(int i=0; i<M; i++){
            List<Integer> list = new ArrayList<>();
            int x = sc.nextInt() -1;
            int y = sc.nextInt() -1;
            list.add(x);
            list.add(y);
            if(map.get(x) == null){
                List<Integer> a = new ArrayList<>();
                a.add(y);
                map.put(x, a);
            } else {
                List<Integer> a = map.get(x);
                a.add(y);
                map.put(x, a);
            }

            if(map.get(y) == null){
                List<Integer> a = new ArrayList<>();
                a.add(x);
                map.put(y, a);
            } else {
                List<Integer> a = map.get(y);
                a.add(x);
                map.put(y, a);
            }
        }

        for(Integer i: map.get(0)){
            List<Integer> list = new ArrayList<>();
            list.add(i);
            boolean[] reachedNodes = new boolean[N];
            reachedNodes[0] = true;
            dfs(0, list, reachedNodes);
        }

        System.out.println(count);
    }

    void dfs(int from, List<Integer> list, boolean[] reachedNodes){
//        System.out.println(eachCount);
        int eachCount = 0;
        for(boolean b: reachedNodes){
            if(b){
                eachCount++;
            }
        }
        if(eachCount == N){
            count++;
            return;
        }
//
        for(int i: list){
            if(reachedNodes[i]){
                continue;
            }
            reachedNodes[i] = true;
//            System.out.println(String.format(""%s %s"", from+1, i+1));
            dfs(i, map.get(i), reachedNodes);
            reachedNodes[i] = false;
        }
    }

//    void dfs(int from, List<Integer> toList, boolean[] eachReachedNode, boolean[][] threwEdge, boolean countedFlug) {
//
//        reachedNode[from] = true;
//        eachReachedNode[from] = true;
//
//        for (int i : toList) {
//            if ((threwEdge[from][i] || threwEdge[i][from])) {
//                continue;
//            } else if(eachReachedNode[i] && !countedFlug){
////                System.out.println(String.format(""%s %s"", from , i));
//                count++;
//                countedFlug = true;
//                threwEdge[from][i] = true;
//                threwEdge[i][from] = true;
////                return;
//            } else {
//                if(map.get(i) == null){
//                    return;
//                } else {
//                    threwEdge[from][i] = true;
//                    threwEdge[i][from] = true;
//                    dfs(i, map.get(i), eachReachedNode, threwEdge, countedFlug);
//                }
//            }
//        }
//    }
//    void dfs(int from, int to) {
//
//        if (from > 100 || to > 100 || reachedArray[from][to]) {
//            return;
//        }
//
//        reachedArray[from][to] = true;
//
//        if (hasArray[from][to]) {
//            count++;
//        }
//        dfs(to, to + 1);
//        dfs(to + 1, to);
//    }
}
"
16,"
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
//		executeCountBalls();
//		executeTaxIncrease();
		executeStringFormation();
	}

	private static void execute() {

		Scanner in = new Scanner(System.in);

		try {
			String s1 = in.nextLine();
			String s2 = in.nextLine();
			String s3 = in.nextLine();

			int  a = Integer.parseInt(s1);
			String[] s2Array = s2.split("" "");
			int b = Integer.parseInt(s2Array[0]);
			int c = Integer.parseInt(s2Array[1]);

			int sum  = a + b + c;

//			System.out.println(a + "","" + b + "","" + c );

			System.out.println(sum + "" "" + s3);
		} catch (NumberFormatException e) {
			// TODO 自動生成された catch ブロック
			System.out.println("""");
//			e.printStackTrace();
		}

	}

	public static void execute_product() {

		Scanner in = new Scanner(System.in);

		try {
			int a  = in.nextInt();
			int b  = in.nextInt();

			if( (a*b)%2 == 0 ) {
				System.out.println(""Even"");
			} else {
				System.out.println(""Odd"");
			}
		} catch (Exception e) {
			// TODO 自動生成された catch ブロック
			e.printStackTrace();
		}
	}

	public static void executeCountBalls() {
		Scanner in = new Scanner(System.in);

		try {
			long N = in.nextLong();
			long A = in.nextLong();
			long B = in.nextLong();

			long surplus = N%(A+B);
			long surplusA = surplus >= A ? A : surplus;

			 long countA = N/(A+B) * A + surplusA;

			System.out.println(countA);
		} catch (Exception e) {
			// TODO 自動生成された catch ブロック
			e.printStackTrace();
		}
	}


	public static final int TAX_RATE_8 = 8;
	public static final int TAX_TATE_10 = 10;

	public static void executeTaxIncrease(){

		Scanner in = new Scanner(System.in);

		double tax8 = (double)in.nextInt();
		double tax10 = (double)in.nextInt();

		int taxExclude_min = (int)Math.ceil((tax8 * 100)/TAX_RATE_8);

		int taxExclude_max = 0;
		if( ((tax8 + 1)*100)%8 == 0 ) {
			taxExclude_max = (int)(((tax8 + 1) * 100)/TAX_RATE_8 - 1);
		}	else {
			taxExclude_max = (int)Math.floor(((tax8 + 1) * 100)/TAX_RATE_8);
		}

//		System.out.println(taxExclude_min + "" "" + taxExclude_max);

		int taxExclude_fix = -1;
		for( int val = taxExclude_min; val <= taxExclude_max; val++) {
			if ( (int)Math.ceil(val/TAX_TATE_10) == tax10 ) {
				taxExclude_fix = val;
				break;
			}
		}
		System.out.println(taxExclude_fix);
	}



	private static final int ENTRY_HEAD = 0x0;
	private static final int ENTRY_TAIL = 0xFFFFFFFF;
	private static int headFlag = ENTRY_HEAD;

	public static void executeStringFormation() {


//		long start = System.currentTimeMillis();

		String s1 = null;
		String s2 = null;
		int num = 0;
		List<String> queryList = new ArrayList<String>();

		if( false ) {
			Scanner in = new Scanner(System.in);

			s1 = in.nextLine();
			s2 = in.nextLine();
			num =Integer.parseInt(s2);

			for(  int i=0; i<num; i++ ) {
				queryList.add(in.nextLine());
			}

		} else {

			try {

				BufferedReader stdin = new BufferedReader(new InputStreamReader(System.in));

				s1 = stdin.readLine();
				s2 = stdin.readLine();
				num = Integer.parseInt(s2);

				for(int i = 0;i<num;i++) {
					queryList.add(stdin.readLine());
				}
			} catch (NumberFormatException e) {
				// TODO 自動生成された catch ブロック
				e.printStackTrace();
			} catch (IOException e) {
				// TODO 自動生成された catch ブロック
				e.printStackTrace();
			}
		}
//		long p1 = System.currentTimeMillis();

		StringBuilder sb = new StringBuilder();
		sb.append(s1);

		for( int i=0; i<num; i++ ) {
			String query = queryList.get(i);

			String[] queryArray = query.split("" "");
			if( ""1"".equals(queryArray[0]) ) {
				// 反転
				exchange(~headFlag);

			} else if( ""2"".equals(queryArray[0]) ) {
				// 追加
				if( ""1"".equals(queryArray[1] )) {
					// 先頭追加
					if(  headFlag == ENTRY_HEAD) {
						sb = addHead(sb, queryArray[2]);
					} else {
						sb = addTail(sb, queryArray[2]);
					}
				} else if( ""2"".equals(queryArray[1])) {
					// 末尾追加
					if( headFlag == ENTRY_HEAD ) {
						sb = addTail(sb, queryArray[2]);
					} else {
						sb = addHead(sb, queryArray[2]);
					}
				} else {
					;
				}
			} else {
				;
			}
		}

//long p2 = System.currentTimeMillis();
		// 出力処理
		if( headFlag == ENTRY_TAIL ) {
			sb = sb.reverse();
		}

//		System.out.println(sb.toString());
		try {
			PrintWriter pw = new PrintWriter(System.out);
			pw.println(sb);
			pw.flush();
			pw.close();
		} catch (Exception e) {
			// TODO 自動生成された catch ブロック
			e.printStackTrace();
		}

//long end = System.currentTimeMillis();

//		System.out.println(""start-end "" + (end-start) + ""ms"");
//		System.out.println(""start-p1 "" + (p1-start) + ""ms"");
//		System.out.println(""p1-p2 "" + (p2-p1) + ""ms"");
//		System.out.println(""p2-end "" + (end-p2) + ""ms"");

	}


	private static void exchange(int entry){
		headFlag = entry;
	}

	private static StringBuilder addTail(StringBuilder sbuilder, String c) {
		return sbuilder.append(c);
	}

	private static StringBuilder addHead(StringBuilder sbuilder, String c) {
		return sbuilder.insert(0, c);
	}
}
"
17,"import java.util.Scanner;
class Main{
  public static void main (String[] args){
    Scanner sc = new Scanner(System.in);
    int N = sc.nextInt();
    int M = sc.nextInt();
    
    if(N==M){
      System.out.println(""Yes"");
    }else{
      System.out.println(""No"");
    }
  }
}
"
18,"package abc081.B;

import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Scanner;

/*
 * AtCoder Beginner Contest 081 B ""Shift only""
 */
public class Main {

	public static void main(String[] args) {

		InputScanner in = new InputScanner(System.in);
		PrintWriter out = new PrintWriter(System.out);

		int N = in.nextInt();
		int[] A = in.nextIntArray(N);

		int ans = Integer.MAX_VALUE;
		for (int Ai : A) {
			int count = 0;
			while (Ai > 1) {
				if (Ai % 2 == 0) {
					Ai /= 2;
					count++;
				} else {
					break;
				}
			}
			ans = Math.min(ans, count);
		}

		out.println(ans);

		in.close();
		out.close();
	}

	/*
	 * extends java.util.Scanner
	 */
	static class InputScanner {

		Scanner scanner;

		public InputScanner(InputStream inputStream) {
			this.scanner = new Scanner(inputStream);
		}

		public int nextInt() {
			return scanner.nextInt();
		}

		public long nextLong() {
			return scanner.nextLong();
		}

		public double nextDouble() {
			return scanner.nextDouble();
		}
		public String next() {
			return scanner.next();
		}

		public int[] nextIntArray(int n) {
			int[] ret = new int[n];
			for (int i = 0; i < n; i++) {
				ret[i] = scanner.nextInt();
			}
			return ret;
		}

		public int[][] nextIntArray(int h, int w) {
			int[][] ret = new int[h][w];
			for (int i = 0; i < h; i++) {
				for (int j = 0; j < w; j++) {
					ret[i][j] = scanner.nextInt();
				}
			}
			return ret;
		}

		public long[] nextLongArray(int n) {
			long[] ret = new long[n];
			for (int i = 0; i < n; i++) {
				ret[i] = scanner.nextLong();
			}
			return ret;
		}

		public long[][] nextlongArray(int h, int w) {
			long[][] ret = new long[h][w];
			for (int i = 0; i < h; i++) {
				for (int j = 0; j < w; j++) {
					ret[i][j] = scanner.nextLong();
				}
			}
			return ret;
		}

		public double[] nextDoubleArray(int n) {
			double[] ret = new double[n];
			for (int i = 0; i < n; i++) {
				ret[i] = scanner.nextDouble();
			}
			return ret;
		}

		public double[][] nextDoubleArray(int h, int w) {
			double[][] ret = new double[h][w];
			for (int i = 0; i < h; i++) {
				for (int j = 0; j < w; j++) {
					ret[i][j] = scanner.nextLong();
				}
			}
			return ret;
		}

		public String[] nextStringArray(int n) {
			String[] ret = new String[n];
			for (int i = 0; i < n; i++) {
				ret[i] = scanner.next();
			}
			return ret;
		}

		public String[] nextStringArray(int n, String split) {
			String[] ret = scanner.next().split(split);
			return ret;
		}

		public String[][] nextStringArray(int h, int w) {
			String[][] ret = new String[h][w];
			for (int i = 0; i < h; i++) {
				for (int j = 0; j < w; j++) {
					ret[i][j] = scanner.next();
				}
			}
			return ret;
		}

		public String[][] nextStringArray(int h, int w, String split) {
			String[][] ret = new String[h][w];
			for (int i = 0; i < h; i++) {
				ret[i] = scanner.next().split(split);
			}
			return ret;
		}

		public void close() {
			scanner.close();
		}

	}

}
"
19,"public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        String b = sc.next();
        
        switch(b){
            case ""A"":
                System.out.println(""T"");
                break;
            case ""T"":
                System.out.println(""A"");
                break;
            case ""G"":
                System.out.println(""C"");
                break;
            case ""C"":
                System.out.println(""G"");
            default:
                System.out.println(""You Wrong"");
                
        
    }
        
        
    }"
20,"import java.util.*;

public class Main {
  public static void main (String[] args) {
    Scanner sc = new Scanner(System.in);

    int n = sc.nextInt();
    int[] l = new int[n];
    for (int i = 0; i < n; i++) {
      l[i] = sc.nextInt();
    }

    int ans = 0;
    for (int i = 0; i < n; i++) {
      for (int j = i+1; j < n; j++) {
        for (int k = j+1; k < n; k++) {
          if (l[i] + l[j] > l[k] && l[j] + l[k] > l[i] && l[i] + l[k] > l[j]) ans++;
        }
      }
    }
    
    System.out.println(ans);
  }
}
"
21,"import java.util.*;
import java.lang.*;
import java.io.*;
import java.math.BigDecimal;

public class Main{
    public static void main (String[] args) throws java.lang.Exception {
        InputReader in = new InputReader(System.in);
        PrintWriter w = new PrintWriter(System.out);
        char[] a = in.next().toCharArray();
        String s = """";
        for (int i = 0; i < a.length; i++) {
            if (i % 2 == 0)
                s += a[i];
        }
        w.println(s);

        w.close();
    }

    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1)
                throw new UnknownError();
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new UnknownError();
                }
                if (numChars <= 0)
                    return -1;
            }
            return buf[curChar++];
        }

        public int peek() {
            if (numChars == -1)
                return -1;
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    return -1;
                }
                if (numChars <= 0)
                    return -1;
            }
            return buf[curChar];
        }

        public void skip(int x) {
            while (x-- > 0)
                read();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public String nextString() {
            return next();
        }

        public String next() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            StringBuffer res = new StringBuffer();
            do {
                res.appendCodePoint(c);
                c = read();
            } while (!isSpaceChar(c));

            return res.toString();
        }

        public String nextLine() {
            StringBuffer buf = new StringBuffer();
            int c = read();
            while (c != '\n' && c != -1) {
                if (c != '\r')
                    buf.appendCodePoint(c);
                c = read();
            }
            return buf.toString();
        }

        public double nextDouble() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            double res = 0;
            while (!isSpaceChar(c) && c != '.') {
                if (c == 'e' || c == 'E')
                    return res * Math.pow(10, nextInt());
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            if (c == '.') {
                c = read();
                double m = 1;
                while (!isSpaceChar(c)) {
                    if (c == 'e' || c == 'E')
                        return res * Math.pow(10, nextInt());
                    if (c < '0' || c > '9')
                        throw new InputMismatchException();
                    m /= 10;
                    res += (c - '0') * m;
                    c = read();
                }
            }
            return res * sgn;
        }
        public int[] nextIntArray(int n) {
            int[] a = new int[n];
            for (int i = 0; i < n; i++)
                a[i] = nextInt();
            return a;
        }
        public long[] nextLongArray(int n) {
            long[] a = new long[n];
            for (int i = 0; i < n; i++)
                a[i] = nextLong();
            return a;
        }
        public boolean hasNext() {
            int value;
            while (isSpaceChar(value = peek()) && value != -1)
                read();
            return value != -1;
        }

        private boolean isSpaceChar(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

    }
}"
22,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;

public class Main {
	private static final Integer[] primeNumberArray = getPrimeNumberArray(5000);

	public static void main(String[] args) throws IOException {
		try (BufferedReader input = new BufferedReader(new InputStreamReader(System.in))) {
			while (input.ready()) {
				final int dataset = Integer.valueOf(input.readLine());
				if (dataset == 0)
					break;
				System.out.println(getGoldbachsByArray(dataset));
			}
		}
	}

	private static int getGoldbachsByArray(int number) {
		final long time1 = System.nanoTime();
		if (number % 2 != 0)
			return 0;
		int ret = 0;
		int tmp = 0;
		for (int i = 0; i < primeNumberArray.length; i++) {
			if (primeNumberArray[i] >= number)
				break;
			for (int j = i; j < primeNumberArray.length; j++) {
				tmp = primeNumberArray[i] + primeNumberArray[j];
				if (tmp > number) {
					break;
				}
				if (tmp == number) {
					ret++;
				}
			}
		}
		final long time2 = System.nanoTime();
		System.out.println(String.format(""%1$,3d ns"", time2 - time1));
		return ret;
	}

	public static Integer[] getPrimeNumberArray(int maxNumber) {
		ArrayList<Integer> primeNumberList = new ArrayList<>();
		primeNumberList.add(2);
		primeNumberList.add(3);
		primeNumberList.add(5);
		primeNumberList.add(7);

		final int[] oneDigitList = { 1, 3, 7, 9 };

		int tmp;
		int sqrtTmp;
		boolean addFlag;
		for (int i = 10; i <= maxNumber; i += 10) {
			for (int oneDigit : oneDigitList) {
				addFlag = true;
				tmp = i + oneDigit;
				sqrtTmp = (int) Math.sqrt(tmp);
				for (int primeNumber : primeNumberList) {
					if (tmp % primeNumber == 0) {
						addFlag = false;
						break;
					}
					if (sqrtTmp < primeNumber) {
						break;
					}
				}
				if (addFlag) {
					primeNumberList.add(tmp);
				}
			}
		}

		return primeNumberList.toArray(new Integer[0]);
	}
}"
23,"import java.util.*;

 class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        long N = sc.nextLong();
        long K = sc.nextLong();
        double p=0;
        
        for(int i=1;i<=N;i++) {
        	double k = 1.0/N;
        	for(int j=i;j<K;j=j*2){
        		k=k/2;
        	}
        	p=p+k;
        }
        System.out.println(p);
    }"
24,"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

class Main{

	public static void main(String[] args) throws IOException {

		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		LinkedList list = new LinkedList();
		int n = Integer.parseInt(br.readLine());

		for(int i = 0; i < n; i++){

			String[] input = br.readLine().split("" "");
			String ope = input[0];
			int x = Integer.parseInt(input[1]);

			if(ope.equals(""insert"")){
				list.insert(x);
			}else if(ope.equals(""delete"")){
				list.delete(x);
			}else if(ope.equals(""deleteFirst"")){
				list.deleteFirst();
			}else if(ope.equals(""deleteLast"")){
				list.deleteLast();
			}


		}

		list.output();

	}

}

class Cell{

	int data;
	Cell next;
	Cell back;

	public Cell(int x){

		data = x;

	}

}

class LinkedList{

	Cell head;

	public LinkedList(){

		head = new Cell(-1);
		head.next = head;
		head.back = head;

	}

	public void insert(int x){

		Cell first = head.next;
		Cell c = new Cell(x);
		c.next = first;
		c.back = head;
		first.back = c;
		head.next = c;


	}

	public void delete(int x){

		Cell refe = head.next;

		while(refe.data != -1){

			if(refe.data == x){

				refe.next.back = refe.back;
				refe.back.next = refe.next;
				break;

			}else{

				refe = refe.next;

			}

		}

	}

	public void deleteFirst(){

		head.next = head.next.next;
		head.next.back = head;

	}

	public void deleteLast(){

		head.back = head.back.back;
		head.back.next = head;

	}

	public void output(){

		Cell refe = head.next;
		StringBuilder sb = new StringBuilder();

		while(refe.data != -1){

			sb.append(refe.data);
			refe = refe.next;

			if(refe.data != -1){
				sb.append("" "");
			}

		}

		sb.append(""\n"");

		System.out.print(sb);

	}

}"
25,"import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;

public class Main {
    private static Scanner scan;

    public static void main(String[] args) {
        scan = new Scanner(System.in);
        System.out.println(sort(scan.nextInt() , scan.nextInt(), scan.nextInt()));
    }

    /**
     * ソートして返します。
     */
    private static String sort(int a, int b, int c) {
        List<Integer> list = new ArrayList<Integer>();
        list.add(a);
        list.add(b);
        list.add(c);
        Collections.sort(list);
        return list.get(0) + "" "" + list.get(1) + "" "" + list.get(2);
    }
}"
26,"public class A41203 {
	public static void main(String[] args) {
		int ans=0;
		for(int i=1;i<=9;i++){
			for(int j=1;j<=9;j++){
				ans=i*j;
				System.out.println(i+""x""+j+""=""+ans);
			}
		}
	}
}"
27,"

import java.util.Comparator;
import java.util.PriorityQueue;
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int V = sc.nextInt();
		int E = sc.nextInt();
			
		int[][] matrix = new int[V][V];
		for (int i = 0; i < E; i++) {
			int s = sc.nextInt();
			int t = sc.nextInt();
			int w = sc.nextInt();
			matrix[s][t] = w;
			matrix[t][s] = w;
		}
		solve(V, E, matrix);
	}
	
	public static void solve(int V, int E, int[][] matrix) {
		boolean[] visited = new boolean[V];
		PriorityQueue<Edge> que = new PriorityQueue<Edge>(10, new Comparator<Edge>() {
			@Override
			public int compare(Edge o1, Edge o2) {
				return o1.w - o2.w;
			}
		});
		
		int node = 0;
		visited[node] = true;
		int d = 0;
		int count = 0;
		for (int i = 0; i < V; i++) {
			if (matrix[node][i] > 0) {
				que.add(new Edge(node, i, matrix[node][i]));
			}
		}
		while(que.isEmpty() == false) {
			Edge edge = que.poll();
			if (visited[edge.t]) 
				continue;
			
			visited[edge.t] = true;
			node = edge.t;
			d += edge.w;
					
			for (int i = 0; i < V; i++) {
				if (matrix[node][i] > 0 && !visited[i]) {
					que.add(new Edge(node, i, matrix[node][i]));
				}
			}
			count++;
			if (count >= V-1)
				break;
		}
		System.out.println(d);
	}
}

class Edge {
	int s;
	int t;
	int w;
	public Edge(int s, int t, int w) {
		this.s = s;
		this.t = t;
		this.w = w;
	}
}"
28,"import java.util.Scanner;
class Main{
    public static void main(String args[]){
        Scanner scan = new Scanner(System.in);
        int a = 100;
        double num = scan.nextDouble();
        int i = 0;
        while(true){
            a = a + (a/100);
            i++;
            if(a >= num){
                System.out.println(i);
                break;
            }
             
        }      
    }
}
"
29,"import java.util.*;

public class Main{
    public static void main(String[] args){
    Scanner sc = new Scanner(System.in);
       
       try {
        String x =sc.next();
        SimpleDateFormat sdFormat = new SimpleDateFormat(""yyyy/MM/dd hh:mm:ss"");
        Date date = sdFormat.parse(strDate);
     
        String str = new SimpleDateFormat(""yyyy-MM-dd hh:mm:ss"").format(date);
       if(str<=2019/04/30){
           System.out.println(""Heisei"");
       }else{
           System.out.println(""TBD"");
       }
     
    } catch (ParseException e) {
        e.printStackTrace();
    }
    }
}"
30,"import java.util.*;
public class Main{
	public static void main(String[] args){
		int ans = 0;
		Scanner sc = new Scanner(System.in);
		
		int n = sc.nextInt();
		int list[] = new int[n];
		for(int i=0; i<n; i++){
			list[i] = sc.nextInt();
		}
		
		int count1, count2;
		int max1=0, max2=0, max3=0, max4=0;
		int where1=0, where2=0, where3=0, where4=0;
		int check1=0, check2=0, check3=0, check4=0;
		for(int i=0; i<n; i+=2){
			count1 = 0;
			count2 = 0;
			for(int j=0; j<n; j+=2){
				if(list[i] == list[j]){
					count1++;
				}
				if(list[i+1] == list[j+1]){
					count2++;
				}
			}
			if(count1 >= max1 && (list[i] != list[where1] || check1 == 0)){
				max2 = max1;
				where2 = where1;
				max1 = count1;
				where1 = i;
				check1 = 1;
			}
			else if(count1 >= max2 && (list[i] != list[where1] && (list[i] != list[where2] || check2 == 0))){
				max2 = count1;
				where2 = i;
				check2 = 1;
			}
			if(count2 >= max3 && (list[i+1] != list[where3] || check3 == 0)){
				max4 = max3;
				where4 = where3;
				max3 = count2;
				where3 = i+1;
				check3 = 1;
			}
			else if(count2 >= max4 && (list[i+1] != list[where3] && (list[i+1] != list[where4] || check4 == 0))){
				max4 = count2;
				where4 = i+1;
				check4 = 1;
			}
		}
		
		if(list[where1] != list[where3]){
			ans = n - max1 - max3;
		}
		else{
			ans = n - Math.max(max1 + max4, max2 + max3);
		}
		
		System.out.println(ans);
	}
}"
31,"import java.util.Scanner;
public class Main {
	public static void main(String[] args){
		Scanner as = new Scanner(System.in);
		/*long n = Long.parseLong(as.next());
		long l = 0;
		if(n%2==0){
			l+=n/2;
		}else{
			l+=(n-1)/2;
		}
		l = l%(int)(Math.pow(10, 9)+7);
		System.out.println(l);*/
		int n = Integer.parseInt(as.next());
		int[] a;
		a = new int[n];
		for(int i=0;i<n;i++){
			a[i]  = Integer.parseInt(as.next());
		}
		int[] t;
		t = new int[n];
		boolean s = true;
		int l = 0;
		if(n%2==0){
			for(int i=0;i<n-1;i+=2){
				t[i] = 0;
				t[i+1]  = 2;
			}
			for(int i=0;i<n;i++){
				t[a[i]] --;
			}
			for(int i=0;i<n;i++){
				if(t[i]<0){
					s = false;
					break;
				}
			}
			if(s){
				l = (int)(Math.pow(2, n/2))%(int)(Math.pow(10, 9)+7);
			}
		}else{
			t[0] = 1;
			for(int i=1;i<n-1;i+=2){
				t[i] = 0;
				t[i+1]  = 2;
			}
			for(int i=0;i<n;i++){
				t[a[i]] --;
			}
			for(int i=0;i<n;i++){
				if(t[i]<0){
					s = false;
					break;
				}
			}
			if(s){
				l = (int)(Math.pow(2, (n-1)/2))%(int)(Math.pow(10, 9)+7);
			}
		}
		System.out.println(l);
	}
}"
32,"import java.util.*;

class Main{

    void solve(){
        Scanner sc = new Scanner(System.in);

        int INF = Integer.MAX_VALUE/10;

        while(true){
            int n = sc.nextInt(), m =sc.nextInt();
            if(n==0 && m==0) break;

            int[][] aruki = new int[n][n];
            int[][] fune = new int[n][n];
            for(int i=0; i<n; i++){
                Arrays.fill(aruki[i], INF);
                Arrays.fill(fune[i], INF);
                aruki[i][i] = 0; fune[i][i] = 0;
            }
            for(int i=0; i<m; i++){
                int x = sc.nextInt()-1, y = sc.nextInt()-1, t = sc.nextInt();
                char s = sc.next().charAt(0);
                if(s=='L'){
                    aruki[x][y] = t; aruki[y][x] = t;
                }else{
                    fune[x][y] = t; fune[y][x] = t;
                }
            }

            for(int k=0; k<n; k++)
                for(int i=0; i<n; i++)
                    for(int j=0; j<n; j++){
                        aruki[i][j] = Math.min(aruki[i][j], aruki[i][k]+aruki[k][j]);
                        fune[i][j] = Math.min(fune[i][j], fune[i][k]+fune[k][j]);
                    }
            
            int r = sc.nextInt();
            int[] z = new int[r];
            for(int i=0; i<r; i++) z[i] = sc.nextInt()-1;

            int[][] dp = new int[r][n];
            for(int i=0; i<r; i++) Arrays.fill(dp[i], INF);
            dp[0][z[0]] = 0;
            for(int i=1; i<r; i++){
                for(int j=0; j<n; j++){
                    if(dp[i-1][j]==INF) continue;
                    dp[i][j] = Math.min(dp[i][j], dp[i-1][j] + aruki[z[i-1]][z[i]]);
                    if(aruki[z[i-1]][j]==INF) continue;
                    for(int k=0; k<n; k++)
                        dp[i][k] = Math.min(dp[i][k], dp[i-1][j] + aruki[z[i-1]][j] + 
                                            fune[j][k] + aruki[k][z[i]]);
                    
                }
            }

            int min = INF;
            for(int i=0; i<n; i++) min = Math.min(min, dp[r-1][i]);
            System.out.println(min);
        }
    }

    public static void main(String[] args){
        new Main().solve();
    }
}"
33,"import java.util.Arrays;
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		int H = scanner.nextInt();
		int W = scanner.nextInt();
		int A = scanner.nextInt();
		int B = scanner.nextInt();

		int r = (int)Math.pow(10, 9) + 7;
		int[] dp = new int[W];
		Arrays.fill(dp, 0);

		for(int i = 0 ; i < H - A ; i++) {
			for(int j = 0 ; j < W ; j++) {
				if(i - 1 < 0) {
					dp[j] += 1;
				} else if(j - 1 >= 0) {
					dp[j] = (dp[j] % r) + (dp[j - 1] % r);
				}
			}
		}

		for(int i = H - A ; i < H ; i++) {
			for(int j = B ; j < W ; j++) {
				if(j - (B + 1) >= 0) {
					dp[j] = (dp[j] % r) + (dp[j - 1] % r);
				}
			}
		}

		System.out.println(dp[W - 1] % r);
		scanner.close();
	}
}
"
34,"import java.util.*;

public class Main{

	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		int length = sc.nextInt();
		int times = sc.nextInt();
		String s = sc.next();

		int flag =0;
		int counter=0;
		String st[] = s.split("""");
		if(st[0].equals(""1"")){
			flag=1;
		}

		for(int i=0;i<length-1;i++){
			if(Integer.st[i] != Integer.st[i+1]){
				counter++;
			}
		}

		int counter2=0;
		int point[] = new int[counter+1];
		int j=0;
		for(int i=0;i<length-1;i++){
			if(Integer.st[i] != Integer.st[i+1]){
				point[j] = i-counter2+1;
				counter2 =i;
				j++;
			}
		}
		if(st[length-1].equals(st[length])){
			point[counter2-1]=1;
		}

		int[] cumulativesum = new int[counter2];
		cumulativesum[0]=0;
		for(int i=1;i<=counter2;i++)
			cumulativesum[i]=cumulativesum[i-1]+point[i];

		int max1=0;
		int max2=0;
		int k=0;

		if(counter2>2*times){
			k=counter2-2*times+1;
		}else
			k=counter2;

		for(int i=0;i<k;i++){
			if(cumulativesum[i]>max1)
				max1=cumulativesum[i]
		}

		if(counter2>2*k-1){
			k=counter2-2*times;
		}else
			k=counter2;

		for(int i=0;i<k;i++){
			if(cumulativesum[i]>max2)
		}

		System.out.println(Math.max(max1,max2));
	}
}"
35,"import java.util.*;
public class Main{
 public static void main(String[] args){
   Scanner sc = new Scanner(System.in);
   int A = sc.nextInt();
   int B = sc.nextInt();
   int C = sc.nextInt();
   int D = sc.nextInt();
 
   if(B<=C || D<=A)System.out.println(0);
   else if(C<=A&& B<=D) System.out.println(B-A);
   else if(A<=C&& D<=B) System.out.println(D-C);
   else if(A<C&&B>C) System.out.println(B-C);
   else System.out.println(D-A);
 }
}"
36,"import java.util.*;
import java.util.stream.*;

public class Main {
	Scanner sc;
	int N, NN;
	Integer[] S;
	TreeSet<Slime> slimes;
	Slime[] indexed;
	Comparator<Slime> hier;
	
	static class Slime {
		int id, val;
		Slime(int id) {
			this.id = id;
		}
	}
	
	public Main() {
		sc = new Scanner(System.in);
		hier = Comparator.comparingInt( (Slime s) -> (0x7fffffff & (-lsb(s.id))) ).
				thenComparingInt( s -> countOnes(s.id) ).
				thenComparingInt( s -> s.id );
	}
	
	private void calc() {
		N = sc.nextInt();
		NN = 1<<N;
		S = new Integer[NN];
		for (int i = 0; i < NN; i++) S[i] = sc.nextInt();
		Arrays.sort(S, Comparator.reverseOrder());
		slimes = new TreeSet<Slime>(hier);
		indexed = new Slime[NN];
		for (int i = 0; i < NN; i++) {
			indexed[i] = new Slime(i);
			slimes.add(indexed[i]);
		}
		
		Iterator<Slime> it = slimes.iterator();
		it.next().val = S[0];
		it.remove();
		int j = 1;
		while (!slimes.isEmpty()) {
			Slime s = it.next();
			Slime parent = indexed[s.id ^ lsb(s.id)];
			if (parent.val > S[j]) {
				s.val = S[j++];
				it.remove();
				it = slimes.iterator();
				continue;
			}
			//if ((s.id & 1) == 1) {
			//	System.out.println(""No"");
			//	return;
			//}
			//it = slimes.tailSet(indexed[lsb(s.id)>>>1], true).iterator();
		}
		if (j == NN) System.out.println(""Yes"");
		else System.out.println(""No"");
	}
	
	static int countOnes(int t) {
		t = (t & 0x55555555) + (t >> 1 & 0x55555555);
		t = (t & 0x33333333) + (t >> 2 & 0x33333333);
		t = (t & 0x0f0f0f0f) + (t >> 4 & 0x0f0f0f0f);
		t = (t & 0x00ff00ff) + (t >> 8 & 0x00ff00ff);
		return (t & 0x0000ffff) + (t >>16 & 0x0000ffff);
	}
	
	static int lsb(int t) {
		return t&(-t);
	}
	
	public static void main(String[] args) {
		new Main().calc();
	}
}
"
37,"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.io.UncheckedIOException;
import java.util.List;
import java.util.stream.Stream;
import java.util.StringTokenizer;
import java.io.BufferedReader;
import java.io.InputStream;
import java.util.function.IntFunction;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author mikit
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        LightScanner in = new LightScanner(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        DPeopleOnALine solver = new DPeopleOnALine();
        solver.solve(1, in, out);
        out.close();
    }

    static class DPeopleOnALine {
        private static final String YES = ""Yes"";
        private static final String NO = ""No"";

        public void solve(int testNumber, LightScanner in, PrintWriter out) {
            int n = in.ints(), m = in.ints();
            int[] l = new int[m], r = new int[m], d = new int[m];
            ShortestPathSolver solver = ShortestPathSolver.Algorithm.WARSHALL_FLOYD.getInstance(n);
            for (int i = 0; i < m; i++) {
                l[i] = in.ints() - 1;
                r[i] = in.ints() - 1;
                d[i] = in.ints();
                solver.addEdge(l[i], r[i], d[i]);
            }
            for (int i = 0; i < m; i++) {
                if (solver.shortestPath(l[i], r[i]) != d[i] || solver.shortestPath(r[i], l[i]) < Integer.MAX_VALUE) {
                    out.println(NO);
                    return;
                }
            }
            out.println(YES);
        }

    }

    static class BellmanFord implements ShortestPathSolver {
        int nodes;
        List<BellmanFord.Edge> edges;
        long[] distance;

        public BellmanFord(int n) {
            nodes = n;
            edges = new ArrayList<>();
            distance = new long[n];
        }

        public void addEdge(int from, int to, int cost) {
            edges.add(new BellmanFord.Edge(from, to, cost));
        }

        public long shortestPath(int src, int dst) {
            Arrays.fill(distance, Long.MAX_VALUE);
            distance[src] = 0;
            for (int i = 0; i < 2 * nodes; i++) {
                for (BellmanFord.Edge e : edges) {
                    if (distance[e.from] < Long.MAX_VALUE && distance[e.to] > distance[e.from] + e.cost) {
                        distance[e.to] = distance[e.from] + e.cost;
                        if (i == nodes - 1 && e.to == dst) {
                            throw new RuntimeException(""negative loop"");
                        }
                    }
                }
            }
            return distance[dst];
        }

        private static class Edge {
            int from;
            int to;
            long cost;

            Edge(int from, int to, long cost) {
                this.from = from;
                this.to = to;
                this.cost = cost;
            }

        }

    }

    static class LightScanner {
        private BufferedReader reader = null;
        private StringTokenizer tokenizer = null;

        public LightScanner(InputStream in) {
            reader = new BufferedReader(new InputStreamReader(in));
        }

        public String string() {
            if (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new UncheckedIOException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int ints() {
            return Integer.parseInt(string());
        }

    }

    static class WarshallFloyd implements ShortestPathSolver {
        private static final int INF = 0x2fffffff;
        private int[][] graph;
        private boolean calculated = false;

        public WarshallFloyd(int n) {
            graph = new int[n][n];
            Arrays.stream(graph).forEach(a -> Arrays.fill(a, INF));
        }

        public void addEdge(int from, int to, int cost) {
            graph[from][to] = cost;
        }

        public long shortestPath(int src, int dst) {
            if (!calculated) {
                for (int i = 0; i < graph.length; i++) {
                    for (int j = 0; j < graph.length; j++) {
                        for (int k = 0; k < graph.length; k++) {
                            graph[j][k] = Math.min(graph[j][k], graph[j][i] + graph[i][k]);
                        }
                    }
                }
                calculated = true;
            }
            return graph[src][dst] == INF ? Integer.MAX_VALUE : graph[src][dst];
        }

    }

    static interface ShortestPathSolver {
        void addEdge(int from, int to, int cost);

        long shortestPath(int src, int dst);

        enum Algorithm {
            WARSHALL_FLOYD(WarshallFloyd::new),
            BELLMAN_FORD(BellmanFord::new),
            DIJKSTRA(null),
            ;
            private final IntFunction<ShortestPathSolver> constructor;

            Algorithm(IntFunction<ShortestPathSolver> constructor) {
                this.constructor = constructor;
            }

            public ShortestPathSolver getInstance(int nodes) {
                return constructor.apply(nodes);
            }

        }

    }
}

"
38,"import java.util.Scanner;
??
public class Main{
??
????????public static void main(String[] args) {
????????????????// TODO Auto-generated method stub
????????????????Scanner sc = new Scanner(System.in);
????????????????int bannum = sc.nextInt();
????????????????String keyword = sc.next();
????????????????String kanban;
????????????????int cnt = 2;
????????????????int knum = 0;
????????????????for(int s = 0;s < bannum;s++){
????????????????????????kanban = sc.next();
????????????????????????loop:for(int i = 0; kanban.length()-i > keyword.length()-1;i++){
????????????????????????????????if(keyword.charAt(0) == kanban.charAt(i)){
????????????????????????????????????????for(int j = kanban.length()-1;j-i>=keyword.length()-1;j--){
????????????????????????????????????????????????if(keyword.charAt(keyword.length()-1) == kanban.charAt(j)){
????????????????????????????????????????????????????????cnt = 2;
????????????????????????????????????????????????????????for(int k = 1;k <= keyword.length()-1;k++){
????????????????????????????????????????????????????????????????//System.out.println(keyword.charAt(k));
????????????????????????????????????????????????????????????????//System.out.println(kanban.charAt((j-i)/(keyword.length()-1)*k+i));
????????????????????????????????????????????????????????????????if(keyword.charAt(k) == kanban.charAt((j-i)/(keyword.length()-1)*k+i)){
????????????????????????????????????????????????????????????????????????cnt++;
????????????????????????????????????????????????????????????????????????if(cnt-1 == keyword.length()){
????????????????????????????????????????????????????????????????????????????????knum++;
????????????????????????????????????????????????????????????????????????????????break loop;
????????????????????????????????????????????????????????????????????????}???????????????????????????????????????????????????????????? 
????????????????????????????????????????????????????????????????}
????????????????????????????????????????????????????????}
????????????????????????????????????????????????}
????????????????????????????????????????}
????????????????????????????????}
????????????????????????}???????????????????? 
????????????????}
????????????????System.out.println(knum);??????????????????
????????}

}"
39,"import java.io.*;
import java.util.*;
import java.lang.*;

public class Main {
	
	public static void main(String[] args) {
		FastScanner sc = new FastScanner();
		out = new PrintWriter(new BufferedOutputStream(System.out));
		
		int n=sc.nextInt();
		int a[]=new int[n];
		for (int i = 0; i < n; i++) {
			a[i]=sc.nextInt();
		}
		int b[]=new int[n];
		for (int i = 0; i < n; i++) {
			if(i==0) {
				b[i]=a[1];
			}else {
				b[i]=a[0];
			}
			
			
			for(int j=0;j<n;j++) {
				
				if(i==j) {
					
				}else {
					b[i]=gcd(b[i],a[j]);
				}
				
			}
		
			
		}
		
		
		out.println(l_max(b));
		out.close();
	}
	static int gcd(int a,int b) {
		if(a==0) {
			return b;
		}
		return gcd(b%a,a);
	
	}

	
	
	
	
//----------------------------------------------------------
	static int l_min(int[] a) {
		Arrays.sort(a);
		return a[0];
	}
	static int l_max(int[] a) {
		int l=a.length;
		Arrays.sort(a);
		return a[l-1];
	}
	public static PrintWriter out;

	public static class MyScanner {
		BufferedReader br;
		StringTokenizer st;

		public MyScanner() {
			br = new BufferedReader(new InputStreamReader(System.in));
		}

		String next() {
			while (st == null || !st.hasMoreElements()) {
				try {
					st = new StringTokenizer(br.readLine());
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			return st.nextToken();
		}

		int nextInt() {
			return Integer.parseInt(next());
		}

		long nextLong() {
			return Long.parseLong(next());
		}

		double nextDouble() {
			return Double.parseDouble(next());
		}

		String nextLine() {
			String str = """";
			try {
				str = br.readLine();
			} catch (IOException e) {
				e.printStackTrace();
			}
			return str;
		}

	}
	
}


class UnionFind{
	int parent[];
	int rank[];
	int size[];
	UnionFind(int n) {
		parent=new int[n];
		rank=new int[n];
		size=new int[n];
		for(int i=0;i<n;i++) {
			parent[i]=i;
			rank[i]=0;
			size[i]=1;
		}
	}
	
	void union(int x,int y) {
		int xRoot=find(x);
		int yRoot=find(y);


		if(xRoot!=yRoot) {
			
			if(rank[xRoot]>rank[yRoot]) {
				parent[yRoot]=xRoot;
				size[xRoot]+=size[yRoot];
				
			}else if(rank[xRoot]<rank[yRoot]){
				parent[xRoot]=yRoot;
				size[yRoot]+=size[xRoot];
				
			}else {
				parent[yRoot]=xRoot;
				rank[xRoot]++;
				size[xRoot]+=size[yRoot];
			}
		}
		
	}
	
	int find(int x) {
		if(parent[x]==x) {
			return x;
		}else {
			return find(parent[x]);
		}
		
	}
	
	boolean same(int x,int y) {
		return find(x)==find(y);
	}
	
	
	
}





class FastScanner {
    private final InputStream in = System.in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}
    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}
    public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}
    public String next() {
        if (!hasNext()) throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
    public long nextLong() {
        if (!hasNext()) throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while(true){
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() { return Double.parseDouble(next());}
}"
40,"import java.io.UnsupportedEncodingException;
import java.util.*;

public class Main {

	static int max_X;
	static int max_Y;

	public static void main(String[] args) throws UnsupportedEncodingException {

		Scanner sc = new Scanner(System.in);

		String ans = ""Yes"";

		int i = sc.nextInt();
		int j = sc.nextInt();
		max_X = i;
		max_Y = j;

		// 適当に格納
		ArrayList<byte[]> map = new ArrayList<byte[]>();
		int h, w;
		for (h = 0; h < j; h++) {
			String st = sc.next();
			map.add(st.getBytes());
		}

		for (h = 0; h < j; h++) {
			byte[] now_x = map.get(h);
			for (w = 0; w < i; w++) {
				if (!check(w,h, now_x, map)) {
					ans = ""No"";
					break;

				}
			}
		}
		System.out.println(ans);
		sc.close();
	}

	private static boolean check(int w, int h, byte[] now_x, ArrayList<byte[]> map) {
		boolean ischeck = false;

		if (now_x[w] == '.') {
			return true;
		}

		// 左
		if (w - 1 >= 0) {
			if (now_x[w] == now_x[w - 1]) {
				ischeck = true;
				return ischeck;
			}
		}

		// 右
		if (w + 1 < max_X) {
			if (now_x[w] == now_x[w + 1]) {
				ischeck = true;
				return ischeck;
			}
		}

		// 上
		if (h - 1 >= 0) {
			byte[] up_x = map.get(h - 1);
			if (now_x[w] == up_x[w]) {
				ischeck = true;
				return ischeck;
			}
		}

		// 下
		if (h + 1 < max_Y) {
			byte[] down_x = map.get(h + 1);
			if (now_x[w] == down_x[w]) {
				ischeck = true;
				return ischeck;
			}
		}
		return ischeck;
	}

}
"
41,"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scan = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int N = scan.nextInt();
        int Ma = scan.nextInt();
        int Mb = scan.nextInt();
        int[] a = new int[N+1];
        int[] b = new int[N+1];
        int[] c = new int[N+1];
        for (int i = 1; i <= N; i++) {
            a[i] = scan.nextInt();
            b[i] = scan.nextInt();
            c[i] = scan.nextInt();
        }
        int[][][][] dp = new int[N+1][N*10+1][N*10+1][2];
        for (int i = 0; i <= N; i++) {
            for (int j = 0; j <= N*10; j++) {
                for (int k = 0; k <= N*10; k++) {
                    dp[i][j][k][0] = 0;
                    dp[i][j][k][1] = Integer.MAX_VALUE;
                }
            }
        }
        dp[0][0][0][0] = 1;
        dp[0][0][0][1] = 0;
        for (int i = 1; i <= N; i++) {
            for (int j = 0; j <= N*10; j++) {
                for (int k = 0; k <= N*10; k++) {
                    if (dp[i - 1][j][k][0] == 0) {
                        continue;
                    }
                    dp[i][j][k][0] = 1;
                    dp[i][j][k][1] = Math.min(dp[i][j][k][1], dp[i - 1][j][k][1]);
                    dp[i][j + a[i]][k + b[i]][0] = 1;
                    dp[i][j + a[i]][k + b[i]][1] = Math.min(dp[i][j + a[i]][k + b[i]][1], dp[i - 1][j][k][1] + c[i]);
                }
            }
        }
        int answer = Integer.MAX_VALUE;
        for (int i = 1; i <= N*10; i++) {
            for (int j = 1; j <= N*10; j++) {
                if (dp[N][i][j][0] == 0) {
                    continue;
                }
                if (i * Mb == j * Ma) {
                    answer = Math.min(answer, dp[N][i][j][1]);
                }
            }
        }
        if (answer == Integer.MAX_VALUE) {
            answer = -1;
        }
        System.out.println(answer);
    }
}
"
42,"
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.*;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;
import java.math.*;
/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */



public class Main {
	
	

	static int k;
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader();
        PrintWriter out = new PrintWriter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskC {
        public void solve(int testNumber, InputReader in, PrintWriter out) {

        	int n=in.nextInt();
        	int k=in.nextInt();
        	int[] w=new int[n];
        	int[] v=new int[n];
        //	int[] c=new int[n];

        	int[][] dp=new int[n+1][k+1];
        	
        	for(int i=0;i<n;i++) {
        		w[i]=in.nextInt();
        		v[i]=in.nextInt();
        	//	c[i]=in.nextInt();
        		
        	}
        	for(int j=1;j<=n;j++) {
        		for(int i=1;i<=k;i++) {
            		if(w[j-1]<=i) {
            			dp[j][i]=Math.max(dp[j-1][i], dp[j-1][i-w[j-1]]+v[j-1]);
            		}
            		else {
            			dp[j][i]=dp[j-1][i];
            		}

            		
            	}
        	}
        	System.out.println(dp[n][k]);

           	
        }	
        
    }
   
    		
    	
    	
    
    static long sumAP(long a, long d, long n) 
    { 
    	int mod = 1000000007;
    	long sum = (n*modInverse(2,mod)%mod) ; 
    	long temp = (n-1)%mod;
    	temp+= 2*a;
    	temp%=mod;
    	temp = (temp * d)%mod;
    	sum = (sum*temp)%mod;	
        return (long) sum; 
    }
    public static long digSum(long number) {
        long digitSum = 0;

        while (number > 0) {
            digitSum = digitSum + (number % 10);
            number = number / 10;
        }

        return digitSum;
    }
    
    static int comb(int n , int r)
	{
		if( r== 0 || n == r)
			return 1;
		else
			return comb(n-1,r)+comb(n-1,r-1);
	}
    public static long fexp(long x, long y, long p) {
    	long res = 1;      
        
       
        x = x % p;  
      
        while (y > 0) 
        { 
         
            if((y & 1)==1) 
                res = (res * x) % p; 
      
          
            y = y >> 1;  
            x = (x * x) % p;  
        } 
        return res; 
    	
    }
    static int gcd(int a, int b) 
    { 
        if (b == 0) 
            return a; 
        return gcd(b, a % b);  
          
    } 
    static int mod(String num, int a) 
    { 
          
        int res = 0; 
  

        for (int i = 0; i < num.length(); i++) 
            res = (res * 10 + (int)num.charAt(i) 
                                     - '0') % a; 
  
        return res; 
    } 
        
    

    static class InputReader
    {
        BufferedReader br;
        StringTokenizer st;

        public InputReader()
        {
            br = new BufferedReader(new
                     InputStreamReader(System.in));
        }

        String next()
        {
            while (st == null || !st.hasMoreElements())
            {
                try
                {
                    st = new StringTokenizer(br.readLine());
                }
                catch (IOException  e)
                {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }
   
        int nextInt()
        {
            return Integer.parseInt(next());
        }

        long nextLong()
        {
            return Long.parseLong(next());
        }

        double nextDouble()
        {
            return Double.parseDouble(next());
        }

        String nextLine()
        {
            String str = """";
            try
            {
                str = br.readLine();
            }
            catch (IOException e)
            {
                e.printStackTrace();
            }
            return str;
        }
    
    }
    public static void sort(int[] a, int low, int high) 
    {
        int N = high - low;         
        if (N <= 1) 
            return; 
        int mid = low + N/2; 
        // recursively sort 
        sort(a, low, mid); 
        sort(a, mid, high); 
        // merge two sorted subarrays
        int[] temp = new int[N];
        int i = low, j = mid;
        for (int k = 0; k < N; k++) 
        {
            if (i == mid)  
                temp[k] = a[j++];
            else if (j == high) 
                temp[k] = a[i++];
            else if (a[j]<a[i]) 
                temp[k] = a[j++];
            else 
                temp[k] = a[i++];
        }    
        for (int k = 0; k < N; k++) 
            a[low + k] = temp[k];         
    }
    static long modInverse(int a, int m) 
    { 
        int g = gcd(a, m); 
        if (g != 1) {
        	
        }          
        else 
        { 
        	return  fexp(a, m - 2, m); 
        }
		return g; 
    } 
   
    
}

"
43,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * 0147:Fukushimaken
 * 
 * @author MS14A
 * @version 2015/05/09
 */
public class Main {

    private static int[] seatWaitTime = new int[17];

    /**
     * メインメソッド
     * 
     * @param args
     * @throws IOException
     */
    public static void main(String[] args) throws IOException {

        List<Integer> inputGroupNumbers = getGroupNumbers();

        for (Integer inputGroupNumber : inputGroupNumbers) {
            Arrays.fill(seatWaitTime, 0);

            System.out.println(getWaitingTime(inputGroupNumber.intValue()));
        }
    }

    private static int getWaitingTime(int inputGroupNumber) {

        boolean canSit = false;
        List<Integer> waitingGroups = new ArrayList<Integer>();
        int groupNumber = 0;

        int time = 0;
        int waitingStartTime = 0;
        int waitingEndTime = 0;

        while (!canSit) {
            // 食事時間を一分進める
            for (int seatTime : seatWaitTime) {
                if (seatTime > 0) {
                    seatTime -= 1;
                }
            }

            // グループが来る
            if (time % 5 == 0) {
                groupNumber = time / 5;
                waitingGroups.add(Integer.valueOf(groupNumber));

                if (groupNumber == inputGroupNumber) {
                    waitingStartTime = time;
                }
            }

            if (!waitingGroups.isEmpty()) {
                // 座れる場合は待ちリストから削除していく
                canSit = sit(getNumberOfGuy(waitingGroups.get(0)), getEatingTime(waitingGroups.get(0)));

                while (canSit) {
                    if (waitingGroups.get(0) == inputGroupNumber) {
                        waitingEndTime = time;
                        break;
                    }
                    waitingGroups.remove(0);
                    if (waitingGroups.isEmpty()) {
                        canSit = false;
                    } else {
                        canSit = sit(getNumberOfGuy(waitingGroups.get(0)), getEatingTime(waitingGroups.get(0)));
                    }
                }
            }

            ++time;
        }

        return waitingEndTime - waitingStartTime;
    }

    private static boolean sit(int NumberOfGroupMember, int eatingTimeOfGroup) {
        int count = 0;
        for (int i = 0; i < seatWaitTime.length; ++i) {
            if (seatWaitTime[i] == 0) {
                count += 1;
                if (count == NumberOfGroupMember) {
                    Arrays.fill(seatWaitTime, i - NumberOfGroupMember + 1, i + 1, eatingTimeOfGroup);
                    return true;
                }
            } else {
                count = 0;
            }
        }

        return false;
    }

    private static int getNumberOfGuy(int groupNumber) {
        if (groupNumber % 5 == 1) {
            return 5;
        }
        return 2;
    }

    private static int getEatingTime(int groupNumber) {
        return 17 * (groupNumber % 2) + 3 * (groupNumber % 3) + 19;
    }

    private static List<Integer> getGroupNumbers() throws IOException {
        // 入力読取り
        InputStreamReader streamReader = new InputStreamReader(System.in);
        BufferedReader bufferedReader = new BufferedReader(streamReader);

        String line = null;
        List<Integer> groupNumbers = new ArrayList<Integer>();

        try {
            while ((line = bufferedReader.readLine()) != null) {
                groupNumbers.add(Integer.parseInt(line));
            }
            return groupNumbers;
        } finally {
            bufferedReader.close();
            streamReader.close();
        }

    }
}"
44,"import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		new Main().solve();
	}

	void solve(){
		Scanner sc=new Scanner(System.in);
		String s=sc.next();
		String ans="""";
		for(int i=0;i<s.length();i++) {
			if(i%2==0)ans+=s.charAt(i);
		}
		System.out.println(ans);
	}
}
"
45,"//package codeforces;

import java.util.Scanner;
import java.io.BufferedReader; 
import java.io.IOException; 
import java.io.InputStreamReader; 
import java.util.StringTokenizer; 
import java.util.HashMap;
import java.util.TreeMap;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;

import java.util.Stack;

public class main {
	static Scanner scn = new Scanner(System.in);
	static long cunt = 0;
	static class FastReader 
    { 
        BufferedReader br; 
        StringTokenizer st; 
  
        public FastReader() 
        { 
            br = new BufferedReader(new
                     InputStreamReader(System.in)); 
        } 
  
        String next() 
        { 
            while (st == null || !st.hasMoreElements()) 
            { 
                try
                { 
                    st = new StringTokenizer(br.readLine()); 
                } 
                catch (IOException  e) 
                { 
                    e.printStackTrace(); 
                } 
            } 
            return st.nextToken(); 
        } 
  
        int nextInt() 
        { 
            return Integer.parseInt(next()); 
        } 
  
        long nextLong() 
        { 
            return Long.parseLong(next()); 
        } 
  
        double nextDouble() 
        { 
            return Double.parseDouble(next()); 
        } 
  
        String nextLine() 
        { 
            String str = """"; 
            try
            { 
                str = br.readLine(); 
            } 
            catch (IOException e) 
            { 
                e.printStackTrace(); 
            } 
            return str; 
        } 
    }
	static FastReader s=new FastReader(); 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		// System.out.format(""%.10f"", ans);char c = sc.next().charAt(0);
		int h=scn.nextInt();
		int a=scn.nextInt();
		int count=1;
		while(h>a)
		{
			h=h-a;
			count++;
		}
		System.out.println(count);
		
		
}
		
	public static String factorial(int n) {
		BigInteger fact = new BigInteger(""1"");
		for (int i = 1; i <= n; i++) {
			fact = fact.multiply(new BigInteger(i + """"));
		}
		return fact.toString();
	}

	public static int bs(int arr[], int k) {
		int high = 0, low = Integer.MIN_VALUE, ans = 0;
		for (int i = 0; i < arr.length; i++) {
			high += arr[i];
			if (arr[i] > low)
				low = arr[i];
		}
		while (low <= high) {
			int mid = (high + low) / 2;
			if (valid(arr, mid, k)) {
				ans = mid;
				high = mid - 1;
			} else
				low = mid + 1;
		}
		return ans;
	}

	public static boolean valid(int arr[], int mid, int k) {
		int sum = 0, cs = 1;
		for (int i = 0; i < arr.length; i++) {
			if (sum + arr[i] > mid) {
				cs++;
				if (cs > k)
					return false;
				sum = arr[i];
			} else
				sum += arr[i];
		}
		return true;
	}

	public static long gcd(long a, long n) {

		if (a == 0)
			return n;
		return gcd(n % a, a);
	}

}
"
46,"import java.util.*;

// ABC 50-C
// http://abc050.contest.atcoder.jp/tasks/arc066_a

public class Main {
	
	static int MOD = 1000000007;

	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		
		String s = in.next();
		boolean isValid = true;
		
		// Investigate from the end of the string
		while (s.length() > 0 && isValid) {
			int l = s.length();
			// Check dream
			if (l >= 5 && s.substring(l - 5).equals(""dream"")) {
				s = s.substring(0, l - 5);
				continue;
			}
			// Check dreamer
			if (l >= 7 && s.substring(l - 7).equals(""dreamer"")) {
				s = s.substring(0, l - 7);
				continue;
			}
			// Check erase
			if (l >= 5 && s.substring(l - 5).equals(""erase"")) {
				s = s.substring(0, l - 5);
				continue;
			}
			// Check eraser
			if (l >= 6 && s.substring(l - 6).equals(""eraser"")) {
				s = s.substring(0, l - 6);
				continue;
			}
			isValid = false;
		}
		System.out.println(isValid ? ""YES"" : ""NO"");
		
	}
}"
47,"import java.util.Arrays;
import java.util.LinkedList;
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		while(true){
			LinkedList<Puzzle> oList = new LinkedList<Puzzle>();
			LinkedList<Puzzle> cList = new LinkedList<Puzzle>();
			int[] tmp = new int[8];
			int i0=-1;
			for(int i=0; i<8; i++){
				tmp[i] = in.nextInt();
				if(tmp[i]==0) 	i0=i;
			}
			oList.addFirst(new Puzzle(tmp, 0, i0));
			int n = -1;
			while((n=routine(oList, cList))==-1){}
			System.out.println(n);
		}
	}
	
	private static int routine(LinkedList<Puzzle> oList, LinkedList<Puzzle> cList){
		Puzzle p = oList.removeFirst();
		if(p.isGoal()){
			return p.g;
		}else{
			for(Puzzle pp : cList)	if(Arrays.equals(p.panel, pp.panel))	 return -1;
			int i0 = p.i0;	// 0の位置
			if(i0!=0 && i0!=4)	addNextPuzzle(i0,i0-1,p,oList);
			if(i0!=3 && i0!=7)	addNextPuzzle(i0,i0+1,p,oList);
			if(i0>3)			addNextPuzzle(i0,i0-4,p,oList);
			else				addNextPuzzle(i0,i0+4,p,oList);
			cList.addLast(p);
			return -1;
		}
	}
	
	private static void addNextPuzzle(int i, int j, Puzzle p, LinkedList<Puzzle> oList){
		int[] tmp = Arrays.copyOf(p.panel, 8);
		tmp[i] = tmp[j];
		tmp[j] = 0;
		Puzzle newP = new Puzzle(tmp, p.g+1, j);
		for(Puzzle pp : oList){
			if(newP.f <= pp.f){
				oList.add(oList.indexOf(pp), newP);
				return;
			}
		}
		oList.addLast(newP);
		return;
	}
}

class Puzzle {
	int[] panel;
	int g, f, i0;
	public Puzzle(int[] panel, int g, int i0) {
		this.panel = panel;
		this.g = g;
		this.i0 = i0;
		calcH();
	}
	public boolean isGoal(){
		if(Arrays.equals(panel, new int[]{0,1,2,3,4,5,6,7}))	return true;
		else													return false;
	}
	public void calcH(){
		int h=0;
		for(int i=0; i<8; i++){
			if(panel[i]!=0){
				h += Math.abs(panel[i]-i)/4 + Math.abs(panel[i]-i)%4;
			}
		}
		f = g+h;
		return;
	}
}"
48,"import java.util.Scanner;
public class ARC090_1 {
public class Main {
 
        public static void main(String[] args) {
            Scanner scanner = new Scanner(System.in);
            int N = scanner.nextInt();
            int [][] A = new int[2][N];
            for (int i=0; i<2; i++)
                for (int j=0; j<N; j++)
                    A[i][j] = scanner.nextInt();
            int i=2-1;
            int j=N-1;
            int Point = A[i][j];
            while ((0<i) || (0<j)){
                if (i<1) j--;
                else if (j<1) i--;
                else if (A[i-1][j] > A[i][j-1]) i--;
                else j--;
                Point += A[i][j]; 
                //System.out.println(""i=""+i+""  j=""+j);
            }
            //System.out.println(""Point=""+Point);
            i=0;
            j=0;
            int Point2 = A[0][0];
            while ((i<1) || (j<(N-1))){
                if (i>=1) j++;
                else if (j>=(N-1)) i++;
                else if (A[i+1][j] > A[i][j+1]) i++;
                else j++;
                Point2 += A[i][j]; 
                //System.out.println(""i=""+i+""  j=""+j);
            }
            if (Point < Point2) System.out.println(Point2);
            else System.out.println(Point);
        }
}"
49,"import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

public class Main {
  public static void main(String[] args) {

    Scanner sc = new Scanner(System.in);
    
    int n = sc.nextInt();

    long[] a = new long[n];
    long[] plus = new long[n];
    for(int i=0; i<n; i++){
      a[i] = sc.nextLong();
    }

    plus[n- 2] = a[n - 1];

    long base = 1000000007;

    for(int i=n - 3; i >= 0; i--){
      plus[i] += (a[i+1] + plus[i+1]) % base;
    }

    long result = 0;

    for(int i=0; i<n - 1; i++){

      result += ((plus[i] * a[i]));
      result = result % base;
    }

    System.out.println(result);

    return;

  }
}
"
50,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;
public class Main
{
    static class FastReader
    {
        BufferedReader br;
        StringTokenizer st;
        public FastReader()
        {
            br = new BufferedReader(new
                     InputStreamReader(System.in));
        }
        String next()
        {
            while (st == null || !st.hasMoreElements())
            {
                try
                {
                    st = new StringTokenizer(br.readLine());
                }
                catch (IOException  e)
                {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }
 
        int nextInt()
        {
            return Integer.parseInt(next());
        }
 
        long nextLong()
        {
            return Long.parseLong(next());
        }
 
        double nextDouble()
        {
            return Double.parseDouble(next());
        }
 
        String nextLine()
        {
            String str = """";
            try
            {
                str = br.readLine();
            }
            catch (IOException e)
            {
                e.printStackTrace();
            }
            return str;
        }
    }
 
    public static void main(String[] args)
    {
        FastReader s=new FastReader();
        int d = s.nextInt();
        int t = s.nextInt();
        int sp = s.nextInt();

        String ans;

        double time = 1.0 * d / sp;
        if(time <= t)
        {
            ans = ""Yes"";
        }else{
            ans = ""No"";
        }
        System.out.println(ans);
        
    }
}"
51,"// package atcoder.arc.arc059;

import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;

/**
 * Created by hama_du on 2016/08/13.
 */
public class Main {
    public static void main(String[] args) {
        InputReader in = new InputReader(System.in);
        PrintWriter out = new PrintWriter(System.out);
        
        int n = in.nextInt();
        char[] s = in.nextToken().toCharArray();
        long[][] dp = new long[n+1][n+2];
        dp[0][0] = 1;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= n; j++) {
                dp[i+1][j+1] += dp[i][j] * 2;
                dp[i+1][j+1] %= MOD;

                int tj = Math.max(0,j-1);
                dp[i+1][tj] += dp[i][j];
                dp[i+1][tj] %= MOD;
            }
        }

        out.println(dp[n][s.length] * pow(inv(2), s.length) % MOD);
        out.flush();
    }

    static final int MOD = 1000000007;

    static long pow(long a, long x) {
        long res = 1;
        while (x > 0) {
            if (x % 2 != 0) {
            res = (res * a) % MOD;
            }
            a = (a * a) % MOD;
            x /= 2;
        }
        return res;
    }

    static long inv(long a) {
        return pow(a, MOD - 2) % MOD;
    }

    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        private int[] nextInts(int n) {
            int[] ret = new int[n];
            for (int i = 0; i < n; i++) {
                ret[i] = nextInt();
            }
            return ret;
        }


        private int[][] nextIntTable(int n, int m) {
            int[][] ret = new int[n][m];
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    ret[i][j] = nextInt();
                }
            }
            return ret;
        }

        private long[] nextLongs(int n) {
            long[] ret = new long[n];
            for (int i = 0; i < n; i++) {
                ret[i] = nextLong();
            }
            return ret;
        }

        private long[][] nextLongTable(int n, int m) {
            long[][] ret = new long[n][m];
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    ret[i][j] = nextLong();
                }
            }
            return ret;
        }

        private double[] nextDoubles(int n) {
            double[] ret = new double[n];
            for (int i = 0; i < n; i++) {
                ret[i] = nextDouble();
            }
            return ret;
        }

        private int next() {
            if (numChars == -1)
                throw new InputMismatchException();
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0)
                    return -1;
            }
            return buf[curChar++];
        }

        public char nextChar() {
            int c = next();
            while (isSpaceChar(c))
                c = next();
            if ('a' <= c && c <= 'z') {
                return (char) c;
            }
            if ('A' <= c && c <= 'Z') {
                return (char) c;
            }
            throw new InputMismatchException();
        }

        public String nextToken() {
            int c = next();
            while (isSpaceChar(c))
                c = next();
            StringBuilder res = new StringBuilder();
            do {
                res.append((char) c);
                c = next();
            } while (!isSpaceChar(c));
            return res.toString();
        }

        public int nextInt() {
            int c = next();
            while (isSpaceChar(c))
                c = next();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = next();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c-'0';
                c = next();
            } while (!isSpaceChar(c));
            return res*sgn;
        }

        public long nextLong() {
            int c = next();
            while (isSpaceChar(c))
                c = next();
            long sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = next();
            }
            long res = 0;
            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c-'0';
                c = next();
            } while (!isSpaceChar(c));
            return res*sgn;
        }

        public double nextDouble() {
            return Double.valueOf(nextToken());
        }

        public boolean isSpaceChar(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);
        }
    }

    static void debug(Object... o) {
        System.err.println(Arrays.deepToString(o));
    }
}
"
52,"import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int sx = sc.nextInt();
		int sy = sc.nextInt();
		int tx = sc.nextInt();
		int ty = sc.nextInt();

		int sumx = tx-sx;
		int sumy = ty-sy;

		String res="""";

		for(int i=0;i<sumy;i++) {
			res += ""U"";
		}
		for(int i=0;i<sumx;i++) {
			res += ""R"";
		}
		for(int i=0;i<sumy;i++) {
			res += ""D"";
		}
		for(int i=0;i<sumx+1;i++) {
			res += ""L"";
		}
		for(int i=0;i<sumy+1;i++) {
			res += ""U"";
		}
		for(int i=0;i<sumx+1;i++) {
			res += ""R"";
		}
		res += ""DR"";
		for(int i=0;i<sumy+1;i++) {
			res += ""D"";
		}
		for(int i=0;i<sumx+1;i++) {
			res += ""L"";
		}
		res += ""U"";

		System.out.println(res);

	}

}
"
53,"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Scanner;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Eric
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        Scanner in = new Scanner(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        ACantWaitForHoliday solver = new ACantWaitForHoliday();
        solver.solve(1, in, out);
        out.close();
    }

    static class ACantWaitForHoliday {
        public void solve(int testNumber, Scanner in, PrintWriter out) {
            String s[] = new String[]{""SUN"", ""MON"", ""TUE"", ""WED"", ""THU"", ""FRI"", ""SAT""};
            String inp = in.next();
            for (int i = 0; i < s.length; i++)
                if (inp.equals(s[i])) {
                    out.println(7 - i);
                }
        }

    }
}

"
54,"import java.awt.geom.*;
import java.io.*;
import java.util.*;


public class Main {
	//1610 start
	int INF = 1 << 24;
	
	class State implements Comparable<State>{
		int now, dis, cost;

		public State(int now, int dis, int cost) {
			this.now = now;
			this.dis = dis;
			this.cost = cost;
		}


		public int compareTo(State o) {
			if(this.dis < o.dis) return -1;
			if(this.dis > o.dis) return 1;
			return 0;
		}


		@Override
		public String toString() {
			return ""State [now="" + now + "", dis="" + dis + "", cost="" + cost
					+ ""]"";
		}
		
	}
	
	private void doit(){
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			int m = sc.nextInt();
			if((n|m) == 0)break;
			int [][] dis = new int[n][n];
			int [][] cost = new int[n][n];
			for(int i = 0; i < n; i++){
				Arrays.fill(dis[i], INF);
				Arrays.fill(cost[i], INF);
			}
			for(int i = 0; i < m; i++){
				int from = sc.nextInt()-1;
				int to = sc.nextInt()-1;
				int d = sc.nextInt();
				int c = sc.nextInt();
				dis[from][to] = d;
				dis[to][from] = d;
				cost[from][to] = c;
				cost[to][from] = c;
			}
			PriorityQueue<State> open = new PriorityQueue<Main.State>();
			open.add(new State(0, 0, 0));
			int [] close = new int[n];
			int [] cos = new int[n];
			Arrays.fill(close, INF);
			Arrays.fill(cos, INF);
			close[0] = 0;
			cos[0] = 0;
			int ans = 0;
			while(! open.isEmpty()){
				State now = open.poll();
				for(int i = 0; i < n; i++){
					if(dis[now.now][i] == INF ) continue;
					int nextdis = now.dis + dis[now.now][i];
					if(close[i] > nextdis){
						open.add(new State(i, nextdis, cost[now.now][i]));
						close[i] = nextdis;
						cos[i] = cost[now.now][i];
					}
					else if(close[i] == nextdis){
						if(cos[i] > cost[now.now][i]){
							open.add(new State(i, nextdis, cost[now.now][i]));
							close[i] = nextdis;
							cos[i] = cost[now.now][i];
						}
					}
				}
			}
			for(int i = 0; i < n; i++){
				ans += cos[i];
			}
			System.out.println(ans);
		}
	}

	public static void main(String [] args){
		new Main().doit();
	}
}"
55,"import java.util.Scanner;

class ITP1_7_A {
	public static void main(String[] args){
    	int r,c;
    	int total= 0;
    	Scanner sc = new Scanner(System.in);
    	r = sc.nextInt();
        c = sc.nextInt();
        int [][] a = new int [r+1][c+1];

    	for(int i = 0; i < r; i++){
			for(int j = 0; j < c+1; j++){
				if(j != c){
					a[i][j] = sc.nextInt();
					a[r][j] += a[i][j];
	    			System.out.print(a[i][j]+"" "");
	    			total += a[i][j];
				}
				else{
					a[i][j] = total;
					System.out.println(a[i][j]);
					a[r][j] += a[i][j];
				}
			}
			total = 0;
    	}
    	sc.close();

    	for(int i = 0; i < c+1; i++){
    		System.out.print(a[r][i]+"" "");
    	}
    }
}"
56,"
import java.io.*;
import java.util.*;

public class Main {
	static void solve() {
		int n = ni();
		String s[] = new String[n];
		for(int i=0;i<n;i++) s[i] = ns();
		int sum[][] = new int[n][2];
		int min[][] = new int[n][2];
		for(int i=0;i<n;i++) {
			char t[] = s[i].toCharArray();
			min[i][1] = i;
			sum[i][1] = i;
			for(int j=0;j<t.length;j++) {
				if(t[j]== '(')sum[i][0]++;
				else sum[i][0]--;
				min[i][0] = min(min[i][0], sum[i][0]);
			}
		}
		Arrays.sort(min,(m1,m2)->m2[0]-m1[0]);//minが大きい順にソート
		boolean used[] = new boolean[n];
		long ans = 0;
		for(int i=0;i<n;i++) {
			if(min[i][0] >= 0) {
				int idx = min[i][1];
				if(sum[idx][0] >= 0) {
					used[idx] = true;
					ans += sum[idx][0];
				}
			}
		}
		for(int i=0;i<n;i++) { 
			int idx = min[i][1];
			if(used[idx] || sum[idx][0] < 0) continue;
			if(ans + min[i][0] < 0) {
				out.println(""No"");
				return;
			}
			used[idx] = true;
			ans += sum[idx][0];
		}
		Arrays.sort(min,(m1,m2)->{
			if(m1[0]==m2[0]) {
				return sum[m2[1]][0] - sum[m1[2]][0];
			}
			return m1[0] - m2[0];
		});	
		for(int i=0;i<n;i++) {
			int idx = min[i][1];
			if(used[idx])continue;
			if(ans + min[i][0] < 0) {
				out.println(""No"");
				return;
			}
			used[idx] = true;
			ans += sum[idx][0];
		}
		if(ans == 0) {
			out.println(""Yes"");
		}
		else {
			out.println(""No"");
		}
	}

	//constant
	static final long mod = (long) 1e9 + 7;
	static final int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };
	static final int[] dx8 = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy8 = { -1, 0, 1, -1, 1, -1, 0, 1 };
	static final int inf = Integer.MAX_VALUE / 2;
	static final long linf = Long.MAX_VALUE / 3;
	static final double dinf = Double.MAX_VALUE / 3;
	static final double eps = 1e-10;
	static final double pi = Math.PI;
	static StringBuilder sb = new StringBuilder();
	static InputStream is;
	static PrintWriter out;
	static String INPUT = """";

	//libraries
	static void reverse(int ar[]) {
		int len = ar.length;
		for (int i = 0; i < len / 2; i++) {
			int t = ar[i];
			ar[i] = ar[len - 1 - i];
			ar[len - 1 - i] = t;
		}
	}

	static void reverse(long ar[]) {
		int len = ar.length;
		for (int i = 0; i < len / 2; i++) {
			long t = ar[i];
			ar[i] = ar[len - 1 - i];
			ar[len - 1 - i] = t;
		}
	}

	static void reverse(double ar[]) {
		int len = ar.length;
		for (int i = 0; i < len / 2; i++) {
			double t = ar[i];
			ar[i] = ar[len - 1 - i];
			ar[len - 1 - i] = t;
		}
	}

	static void reverse(char ar[]) {
		int len = ar.length;
		for (int i = 0; i < len / 2; i++) {
			char t = ar[i];
			ar[i] = ar[len - 1 - i];
			ar[len - 1 - i] = t;
		}
	}

	static String getReverse(String s) {
		char c[] = s.toCharArray();
		reverse(c);
		s = String.valueOf(c);
		return s;
	}

	static <T> void reverse(List<T> ls) {
		int sz = ls.size();
		for (int i = 0; i < sz / 2; i++) {
			T t = ls.get(i);
			ls.set(i, ls.get(sz - 1 - i));
			ls.set(sz - 1 - i, t);
		}
	}

	static <T> void reverse(T[] ar) {
		int len = ar.length;
		for (int i = 0; i < len / 2; i++) {
			T t = ar[i];
			ar[i] = ar[len - 1 - i];
			ar[len - 1 - i] = t;
		}
	}

	static void sbnl() {//StringBuilderに改行文字をappendする
		sb.append(""\n"");
	}

	static int lowerBound(int[] a, int x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] < x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int upperBound(int[] a, int x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] <= x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int rlowerBound(int[] a, int x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] > x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int rupperBound(int[] a, int x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] >= x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int lowerBound(long[] a, long x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] < x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int upperBound(long[] a, long x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] <= x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int rlowerBound(long[] a, long x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] > x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int rupperBound(long[] a, long x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] >= x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int lowerBound(double[] a, double x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] < x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int upperBound(double[] a, double x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] <= x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int rlowerBound(double[] a, double x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] > x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int rupperBound(double[] a, double x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] >= x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int lowerBound(char[] a, char x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] < x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int upperBound(char[] a, char x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] <= x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int rlowerBound(char[] a, char x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] > x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int rupperBound(char[] a, char x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] >= x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static <T> int lowerBound(List<T> ls, T x) throws RuntimeException {
		if (ls.size() == 0)
			return -1;
		if (ls.get(0) instanceof Integer) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) >= 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Long) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) >= 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Double) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) >= 0 ? 1 : -1);
		} else {
			System.err.println(
					String.format(""%s:数値でないリストを二分探索しています。"", Thread.currentThread().getStackTrace()[1].getMethodName()));
			throw new RuntimeException();
		}
	}

	static <T> int upperBound(List<T> ls, T x) throws RuntimeException {
		if (ls.size() == 0)
			return -1;
		if (ls.get(0) instanceof Integer) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) > 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Long) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) > 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Double) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) > 0 ? 1 : -1);
		} else {
			System.err.println(
					String.format(""%s:数値でないリストを二分探索しています。"", Thread.currentThread().getStackTrace()[1].getMethodName()));
			throw new RuntimeException();
		}
	}

	static <T> int rupperBound(List<T> ls, T x) throws RuntimeException {
		if (ls.size() == 0)
			return -1;
		if (ls.get(0) instanceof Integer) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) < 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Long) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) < 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Double) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) < 0 ? 1 : -1);
		} else {
			System.err.println(
					String.format(""%s:数値でないリストを二分探索しています。"", Thread.currentThread().getStackTrace()[1].getMethodName()));
			throw new RuntimeException();
		}
	}

	static <T> int rlowerBound(List<T> ls, T x) {
		if (ls.size() == 0)
			return -1;
		if (ls.get(0) instanceof Integer) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) <= 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Long) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) <= 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Double) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) <= 0 ? 1 : -1);
		} else {
			System.err.println(
					String.format(""%s:数値でないリストを二分探索しています。"", Thread.currentThread().getStackTrace()[1].getMethodName()));
			throw new RuntimeException();
		}
	}

	static int[] concat(int x, int arr[]) {
		int ret[] = new int[arr.length + 1];
		System.arraycopy(arr, 0, ret, 1, ret.length - 1);
		ret[0] = x;
		return ret;
	}

	static int[] concat(int arr[], int x) {
		int ret[] = new int[arr.length + 1];
		System.arraycopy(arr, 0, ret, 0, ret.length - 1);
		ret[ret.length - 1] = x;
		return ret;
	}

	static long[] concat(long x, long arr[]) {
		long ret[] = new long[arr.length + 1];
		System.arraycopy(arr, 0, ret, 1, ret.length - 1);
		ret[0] = x;
		return ret;
	}

	static long[] concat(long arr[], long x) {
		long ret[] = new long[arr.length + 1];
		System.arraycopy(arr, 0, ret, 0, ret.length - 1);
		ret[ret.length - 1] = x;
		return ret;
	}

	static int max(int x, int y) {
		return Math.max(x, y);
	}

	static int min(int x, int y) {
		return Math.min(x, y);
	}

	static int max(int x, int y, int z) {
		x = Math.max(x, y);
		x = Math.max(x, z);
		return x;
	}

	static int min(int x, int y, int z) {
		x = Math.min(x, y);
		x = Math.min(x, z);
		return x;
	}

	static long max(long x, long y) {
		return Math.max(x, y);
	}

	static long min(long x, long y) {
		return Math.min(x, y);
	}

	static long max(long x, long y, long z) {
		x = Math.max(x, y);
		x = Math.max(x, z);
		return x;
	}

	static long min(long x, long y, long z) {
		x = Math.min(x, y);
		x = Math.min(x, z);
		return x;
	}

	static double max(double x, double y) {
		return Math.max(x, y);
	}

	static double min(double x, double y) {
		return Math.min(x, y);
	}

	static double max(double x, double y, double z) {
		x = Math.max(x, y);
		x = Math.max(x, z);
		return x;
	}

	static double min(double x, double y, double z) {
		x = Math.min(x, y);
		x = Math.min(x, z);
		return x;
	}

	static void sort(int[] ar) {
		Arrays.sort(ar);
	}

	static void sort(long[] ar) {
		Arrays.sort(ar);
	}

	static void sort(double[] ar) {
		Arrays.sort(ar);
	}

	static void sort(char[] ar) {
		Arrays.sort(ar);
	}

	static void rsort(int[] ar) {
		Arrays.sort(ar);
		int len = ar.length;
		for (int i = 0; i < len / 2; i++) {
			int tmp = ar[i];
			ar[i] = ar[len - 1 - i];
			ar[len - 1 - i] = tmp;
		}
	}

	static void rsort(long[] ar) {
		Arrays.sort(ar);
		int len = ar.length;
		for (int i = 0; i < len / 2; i++) {
			long tmp = ar[i];
			ar[i] = ar[len - 1 - i];
			ar[len - 1 - i] = tmp;
		}
	}

	static void rsort(double[] ar) {
		Arrays.sort(ar);
		int len = ar.length;
		for (int i = 0; i < len / 2; i++) {
			double tmp = ar[i];
			ar[i] = ar[len - 1 - i];
			ar[len - 1 - i] = tmp;
		}
	}

	static void rsort(char[] ar) {
		Arrays.sort(ar);
		int len = ar.length;
		for (int i = 0; i < len / 2; i++) {
			char tmp = ar[i];
			ar[i] = ar[len - 1 - i];
			ar[len - 1 - i] = tmp;
		}
	}

	static void fill(int arr[], int x) {
		Arrays.fill(arr, x);
	}

	static void fill(long arr[], long x) {
		Arrays.fill(arr, x);
	}

	static void fill(boolean arr[], boolean x) {
		Arrays.fill(arr, x);
	}

	static void fill(double arr[], double x) {
		Arrays.fill(arr, x);
	}

	static void fill(int arr[][], int x) {
		for (int i = 0; i < arr.length; i++)
			Arrays.fill(arr[i], x);
	}

	static void fill(long arr[][], long x) {
		for (int i = 0; i < arr.length; i++)
			Arrays.fill(arr[i], x);
	}

	static void fill(double arr[][], double x) {
		for (int i = 0; i < arr.length; i++)
			Arrays.fill(arr[i], x);
	}

	static void fill(boolean arr[][], boolean x) {
		for (int i = 0; i < arr.length; i++)
			Arrays.fill(arr[i], x);
	}

	//MOD culc
	static long plus(long x, long y) {
		long res = (x + y) % mod;
		return res < 0 ? res + mod : res;
	}

	static long sub(long x, long y) {
		long res = (x - y) % mod;
		return res < 0 ? res + mod : res;
	}

	static long mul(long x, long y) {
		long res = (x * y) % mod;
		return res < 0 ? res + mod : res;
	}

	static long div(long x, long y) {
		long res = x * pow(y, mod - 2) % mod;
		return res < 0 ? res + mod : res;
	}

	static long pow(long x, long y) {
		if (y < 0)
			return 0;
		if (y == 0)
			return 1;
		if (y % 2 == 1)
			return (x * pow(x, y - 1)) % mod;
		long root = pow(x, y / 2);
		return root * root % mod;
	}

	public static void main(String[] args) throws Exception {
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		solve();
		out.flush();
	}

	//input
	private static byte[] inbuf = new byte[1024];
	static int lenbuf = 0, ptrbuf = 0;

	private static int readByte() {
		if (lenbuf == -1)
			throw new InputMismatchException();
		if (ptrbuf >= lenbuf) {
			ptrbuf = 0;
			try {
				lenbuf = is.read(inbuf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (lenbuf <= 0)
				return -1;
		}
		return inbuf[ptrbuf++];
	}

	private static boolean isSpaceChar(int c) {
		return !(c >= 33 && c <= 126);
	}

	private static int skip() {
		int b;
		while ((b = readByte()) != -1 && isSpaceChar(b))
			;
		return b;
	}

	@SuppressWarnings(""unused"")
	private static double nd() {
		return Double.parseDouble(ns());
	}

	@SuppressWarnings(""unused"")
	private static char nc() {
		return (char) skip();
	}

	private static String ns() {
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while (!(isSpaceChar(b))) {
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}

	private static char[] ns(int n) {
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while (p < n && !(isSpaceChar(b))) {
			buf[p++] = (char) b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}

	@SuppressWarnings(""unused"")
	private static char[][] nm(int n, int m) {
		char[][] map = new char[n][];
		for (int i = 0; i < n; i++)
			map[i] = ns(m);
		return map;
	}

	@SuppressWarnings(""unused"")
	private static int[] na(int n) {
		int[] a = new int[n];
		for (int i = 0; i < n; i++)
			a[i] = ni();
		return a;
	}

	@SuppressWarnings(""unused"")
	private static long[] nla(int n) {
		long[] a = new long[n];
		for (int i = 0; i < n; i++)
			a[i] = nl();
		return a;
	}

	private static int ni() {
		int num = 0, b;
		boolean minus = false;
		while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))
			;
		if (b == '-') {
			minus = true;
			b = readByte();
		}

		while (true) {
			if (b >= '0' && b <= '9') {
				num = num * 10 + (b - '0');
			} else {
				return minus ? -num : num;
			}
			b = readByte();
		}
	}

	@SuppressWarnings(""unused"")
	private static long nl() {
		long num = 0;
		int b;
		boolean minus = false;
		while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))
			;
		if (b == '-') {
			minus = true;
			b = readByte();
		}

		while (true) {
			if (b >= '0' && b <= '9') {
				num = num * 10 + (b - '0');
			} else {
				return minus ? -num : num;
			}
			b = readByte();
		}
	}

}
"
57,"import java.io.PrintStream;
import java.util.Scanner;

public class Main {
	static Scanner sc = new Scanner(System.in);
	static PrintStream so = System.out;
	public static void main(String[] args) {

		String s = sc.next();
		
		String[] a = {""dreameraser"", ""dreamerase"", ""dreamer"", ""dream"", ""eraser"", ""erase""};
		
		outer: while (true) {
			for (String elem: a) {
				if (s.startsWith(elem)) {
					s = new String(s.substring(elem.length()));
					if (s.length() == 0) {
						so.println(""YES"");
						return;
					}
					continue outer;
				}
			}
			
			so.println(""NO"");
			return;
		}
	}
}
"
58,"import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;
 
public class Main {
	static List<Long> a;
	static List<Long> b;
	static List<Long> c;
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int x = sc.nextInt();
		int y = sc.nextInt();
		int z = sc.nextInt();
		int k = sc.nextInt();
		a = new ArrayList<>();
		b = new ArrayList<>();
		c = new ArrayList<>();
		for(int i =0; i < x; i++)
			a.add(Long.parseLong(sc.next()));
		for(int i = 0; i < y; i++)
			b.add(Long.parseLong(sc.next()));
		for(int i = 0; i < z; i++)
			c.add(Long.parseLong(sc.next()));
		
		Collections.sort(a, Collections.reverseOrder());
		Collections.sort(b, Collections.reverseOrder());
		Collections.sort(c, Collections.reverseOrder());
		
		List<Long> ab = new ArrayList<>();
		for(int i = 0; i < x; i++)
			for(int j = 0; j < y; j++)
				ab.add(a.get(i) + b.get(j));
		Collections.sort(ab, Collections.reverseOrder());
		int size = Math.min(k, ab.size());
		List<Long> abc = new ArrayList<>();
		
		for(int i = 0; i < size; i++) 
			for(int j = 0; j < z; j++)
				abc.add(ab.get(i) + c.get(j));
		
		Collections.sort(abc, Collections.reverseOrder());

		for(int i = 0; i < k; i++)
			System.out.println(abc.get(i));
	}
}"
59,"

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

public class Main{
	public static void main(String[] args) {
		new Main().solver();
	}

	void solver() {
		Scanner sc = new Scanner(System.in);
		int V = sc.nextInt();
		int E = sc.nextInt();
		@SuppressWarnings(""unchecked"")
		ArrayList<Integer>[] e = new ArrayList[V];
		for (int i = 0; i < V; i++)
			e[i] = new ArrayList<>();
		for (int i = 0; i < E; i++) {
			int s = sc.nextInt();
			int t = sc.nextInt();
			e[s].add(t);
		}
		int Q = sc.nextInt();
		int[] scc = stronglyConnectedComponents(e);
		for (int i = 0; i < Q; i++) {
			int u = sc.nextInt();
			int v = sc.nextInt();
			if (scc[u]==scc[v]) {
				System.out.println(1);
			} else {
				System.out.println(0);
			}
		}

	}

	int[] dfsnum;
	int[] low;
	ArrayDeque<Integer> S = new ArrayDeque<>();
	ArrayList<Integer> T = new ArrayList<>();
	int N = 0;
	boolean[] used;
	int[] ret;

	int[] stronglyConnectedComponents(ArrayList<Integer> e[]) {
		int n = e.length;
		dfsnum = new int[n];
		low = new int[n];
		used = new boolean[n];
		ret = new int[n];

		for (int i = 0; i < n; i++) {
			if (used[i])
				continue;
			if (dfsnum[i] == 0) {
				dfs(e, i);
			}
		}
		return ret;
	}

	int NOW = 0;

	void dfs(ArrayList<Integer>[] e, int i) {
		S.addFirst(i);
		dfsnum[i] = N;
		N++;
		low[i] = dfsnum[i];
		for (int j : e[i]) {
			if (used[j])
				continue;
			if (!T.contains(j)) {
				T.add(j);
				dfs(e, j);
				low[i] = Math.min(low[i], low[j]);
			} else {
				low[i] = Math.min(dfsnum[j], low[i]);
			}
		}

		if (low[i] == dfsnum[i]) {
			int v;
			do {
				v = S.removeFirst();
				ret[v] = NOW;
				used[v] = true;
			} while (v != i);
			NOW++;
		}
		return;
	}
}"
60,"

/**
 * @Author Mehdi Maick
 * Created on 10/12/2016.
 */

import java.util.*;
import java.io.*;

import static java.lang.Math.*;

public class Main {
    //static HashMap<String, Boolean> memo = new HashMap<>();
    static boolean f(String s) {
        if (s.equals(""eraser"") || s.equals(""dream"") || s.equals(""dreamer"") || s.equals(""erase"")) return true;
        int n = s.length();
        if (n < 5) return false;
        //if (memo.containsKey(s)) return memo.get(s);
        String sub = s.substring(0, 5);
        boolean ans = false;
        if (sub.equals(""dream"")) {
            ans |= f(s.substring(5));
            if (n >= 7 && s.charAt(5) == 'e' && s.charAt(6) == 'r')
                ans |= f(s.substring(7));
        } else if (sub.equals(""erase"")) {
            ans |= f(s.substring(5));
            if (n >= 6 && s.charAt(4) == 'e' && s.charAt(5) == 'r')
                ans |= f(s.substring(6));
        }
        //memo.put(s, ans);
        return ans;
    }

    public static void solve(FastReader fs, PrintWriter pw) {
        String s = fs.next();

        pw.println((f(s) ? ""YES"" : ""NO""));

    }

    public static void main(String[] args) throws Exception {
        FastReader fs = new FastReader(System.in);
        PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));

        solve(fs, pw);

        fs.close();
        pw.close();
    }

    static class FastReader {

        BufferedReader reader;
        StringTokenizer st;

        FastReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream));
            st = null;
        }

        String next() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    String line = reader.readLine();
                    if (line == null) {
                        return null;
                    }
                    st = new StringTokenizer(line);
                } catch (Exception e) {
                    throw new RuntimeException();
                }
            }
            return st.nextToken();
        }

        String nextLine() {
            String s = null;
            try {
                s = reader.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return s;
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        char nextChar() {
            return next().charAt(0);
        }

        int[] nextIntArray(int n) {
            int[] arr = new int[n];
            int i = 0;
            while (i < n) {
                arr[i++] = nextInt();
            }
            return arr;
        }

        long[] nextLongArray(int n) {
            long[] arr = new long[n];
            int i = 0;
            while (i < n) {
                arr[i++] = nextLong();
            }
            return arr;
        }

        int[] nextIntArrayOneBased(int n) {
            int[] arr = new int[n + 1];
            int i = 1;
            while (i <= n) {
                arr[i++] = nextInt();
            }
            return arr;
        }

        long[] nextLongArrayOneBased(int n) {
            long[] arr = new long[n + 1];
            int i = 1;
            while (i <= n) {
                arr[i++] = nextLong();
            }
            return arr;
        }

        void close() {
            try {
                reader.close();
            } catch (IOException e) {
                System.err.println(""There's been an error trying closing the reader "");
                e.printStackTrace();
            }
        }
    }


}"
61,"public class Main{

	public static void main(String[] args) {
		int R = new java.util.Scanner(System.in).nextInt();
		double e = Math.PI * R * 2;
		System.out.println(e);
	}

}
"
62,"import java.util.Arrays;
import java.util.Scanner;

class Main{
	static long mod=1000000007; // 10e9 + 7
	static long pow(long a, long x){
		if(x == 1) return a % mod;
		else if(x % 2 == 0) return pow((a * a) % mod, x / 2) % mod;
		else return (a * pow((a * a) % mod, x / 2)) % mod;
	}
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		int[] A = new int[N];
		int[] B = new int[N];
		for(int i = 0; i < N; i++) A[i] = sc.nextInt();
		if(N % 2 == 0) {
			for(int i = 0; i + 1 < N; i += 2) {
				B[i] = i + 1; B[i + 1] = i + 1;
			}
		}else {
			B[0] = 0;
			for(int i = 1; i + 1 < N; i += 2) {
				B[i] = i + 1; B[i + 1] = i + 1;
			}
		}
		Arrays.sort(A);
		boolean check = true;
		long ans = pow(2, (long)(N / 2));
		for(int i = 0; i < N; i++) if(B[i] != A[i]) check = false;

		System.out.println(check ? ans : 0);

	}
}"
63,"import java.util.Scanner;
import static java.lang.System.out;
public class Main{
   public static void main(String []args){
      Scanner sc = new Scanner(System.in);
      int N = sc.nextInt();
      boolean result = false;
      int ns = N%10;//1
      int nt = (N-ns)/10;
      if(ns == 9){
         result = true;
      }else{
         if(nt==9){
            result = true;
         }
      }
      if(result == true){
         out.println(""Yes"");
      }else{
         out.println(""No"");
      }
   }
"
64,"import java.util.*;

public class Main {
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        char[] s = sc.next().toCharArray();
        char[] t = sc.next().toCharArray();
        int len = lcm(n, m);
        char[] ans = new char[len];
        Arrays.fill(ans, '0');
        int spow = len/n;
        for(int i = 0; i < n; i++){
            ans[spow*i] = s[i];
        }
        int tpow = len/m;
        for(int i = 0; i < m; i++){
            if(ans[tpow*i] != '0' && ans[tpow*i] != t[i]){
                System.out.println(-1);
                return;
            }
        }
        System.out.println(len);
    }
    
    private static int gcd(int a, int b){
        while (b > 0)
        {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
    
    private static int lcm(int a, int b){
        return a * (b / gcd(a, b));
    }
}"
65,"import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class Main {

	@SuppressWarnings(""resource"")
	public static void main(String args[]) {
		Scanner scanner = new Scanner(System.in);
		int n=scanner.nextInt();
		int m=scanner.nextInt();
		String s=scanner.next();
		String t=scanner.next();
		long l=lcm(n,m);
		Map<Long,String>map=new HashMap<>();
		for(long i=0;i<l+1;i++) {
			map.put(i,""NO"");
		}
		for(int i=0;i<n;i++) {
			map.put(i*l/n+1,String.valueOf(s.charAt(i)));
		}
		for(int i=0;i<m;i++) {
			Long ind=(Long) (i*l/m+1);
			String tmp=String.valueOf(t.charAt(i));
			if(map.get(ind).equals(tmp)) {
				continue;
			}else if(map.get(ind).equals(""NO"")) {
				map.put((long) ind,tmp);
			}
			else {
				System.out.println(-1);
				return;
			}
		}
		System.out.println(l);
	}
	
	/*******************************************************************
	最大公約数
	*******************************************************************/

	static long gcd(long a, long b) {
			long temp;
			while ((temp = a % b) != 0) {
				a = b;
				b = temp;
			}
			return b;
		}


	/*******************************************************************
	最小公倍数
	*******************************************************************/

		 static long lcm(long m, long n) {
			return m / gcd(m, n) * n;
		}

}"
66,"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

import java.util.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);

        int H = in.nextInt();
        int W = in.nextInt();
        int[][] A = new int[H][W];
        for (int i=0;i<H;i++) {
            for (int j=0;j<W;j++) {
                A[i][j] = Integer.parseInt(in.next());
            }
        }
        int[][] B = new int[H][W];
        for (int i=0;i<H;i++) {
            for (int j=0;j<W;j++) {
                B[i][j] = Integer.parseInt(in.next());
            }
        }
        int[][] C = new int[H+1][W+1];
        for (int i=0;i<H;i++) {
            for (int j=0;j<W;j++) {
                C[i+1][j+1] = Math.abs(A[i][j]-B[i][j]);
            }
        }
        // System.out.println(Arrays.deepToString(C));

        int AA = 80*160+10000;
        int[][][] dp = new int[H+1][W+1][3*AA+10000];
        dp[0][1][AA]=1;
        dp[1][0][AA]=1;

        // for (int k=0;k<AA;k++) {
        for (int i=0;i<=H;i++) {
            for (int j=0;j<=W;j++) {
                for (int k=0;k<3*AA;k++) {
                    if (i<H && j>0) {
                        if (dp[i][j][k]==1) dp[i+1][j][k+C[i+1][j]]=1;
                        if (k-C[i+1][j]>=0) {
                            if (dp[i][j][k]==1) dp[i+1][j][k-C[i+1][j]]=1;
                        }
                    }
                    if (j<W && i>0) {
                        if (dp[i][j][k]==1) dp[i][j+1][k+C[i][j+1]]=1;
                        if (k-C[i][j+1]>=0) {
                            if (dp[i][j][k]==1) dp[i][j+1][k-C[i][j+1]]=1;
                        }
                    }
                }
            }
        }
        // System.out.println(Arrays.deepToString(dp));

        long ans = 1_000_000_000L;
        for (int k=3*AA;k>=0;k--) {
            if (dp[H][W][k]==1) ans = Math.min(ans, Math.abs(k-AA));
        }
        out.println(ans);


        out.close();
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

    }
}
"
67,"
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.InputMismatchException;
import java.util.StringTokenizer;

public class Main {

	public static void main(String[] args) throws IOException {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskX solver = new TaskX();
		solver.solve(1, in, out);
		out.close();
	}

	static int INF = 1 << 30;
	static int modP = 1000000007;

	static class TaskX {
		public void solve(int testNumber, InputReader in, PrintWriter out) {

			int N = in.nextInt();
			int[] list = new int[N];
			ArrayList<Integer> tmpList = new ArrayList<>();
			for (int i = 0; i < N; i++) {
				int x = in.nextInt();
				list[i] = x;
				tmpList.add(x);
			}

			Collections.sort(tmpList);

			for (int i = 0; i < N; i++) {
				int tar = list[i];
				int index = tmpList.indexOf((Integer)tar);
				tmpList.remove((Integer)tar);
				out.println((tmpList.get((tmpList.size()+1)/2-1)));
				tmpList.add(index, (Integer)tar);
			}
		}
	}

	static class InputReader {
		BufferedReader in;
		StringTokenizer tok;

		public String nextString() {
			while (!tok.hasMoreTokens()) {
				try {
					tok = new StringTokenizer(in.readLine(), "" "");
				} catch (IOException e) {
					throw new InputMismatchException();
				}
			}
			return tok.nextToken();
		}

		public int nextInt() {
			return Integer.parseInt(nextString());
		}

		public long nextLong() {
			return Long.parseLong(nextString());
		}

		public double nextDouble() {
			return Double.parseDouble(nextString());
		}

		public int[] nextIntArray(int n) {
			int[] res = new int[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextInt();
			}
			return res;
		}

		public long[] nextLongArray(int n) {
			long[] res = new long[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextLong();
			}
			return res;
		}

		public InputReader(InputStream inputStream) {
			in = new BufferedReader(new InputStreamReader(inputStream));
			tok = new StringTokenizer("""");
		}

	}

}
"
68,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
	public static void main(String[] args) throws IOException {
		Main mainObj = new Main();
		mainObj.solve();
	}

	public void solve() throws IOException {
		FastScanner fs = new FastScanner();
		int n = fs.nextInt();
		int k = fs.nextInt();
		
		int ans = 1;
		
		for(int i = 0; i < n; i++) {
			if(ans < k) {
				ans *= 2;
			}else {
				ans += k;
			}
		}
		
		System.out.println(ans);
	}

	

	public class FastScanner {

		BufferedReader reader;
		private StringTokenizer st;

		public FastScanner() {
			st = null;
			reader = new BufferedReader(new InputStreamReader(System.in));
		}

		public String next() throws IOException {
			if (st == null || !st.hasMoreElements()) {
				st = new StringTokenizer(reader.readLine());
			}
			return st.nextToken();
		}

		public String nextLine() throws IOException {
			st = null;
			String readLine = null;
			readLine = reader.readLine();
			return readLine;
		}

		public int nextInt() throws NumberFormatException, IOException {
			return Integer.parseInt(next());
		}

		public long nextLong() throws NumberFormatException, IOException {
			return Long.parseLong(next());
		}

		public int[] nextIntArr(int n) throws NumberFormatException, IOException {
			int[] retArr = new int[n];
			for (int i = 0; i < n; i++) {
				retArr[i] = nextInt();
			}
			return retArr;
		}

		public long[] nextLongArr(int n) throws NumberFormatException, IOException {
			long[] retArr = new long[n];
			for (int i = 0; i < n; i++) {
				retArr[i] = nextLong();
			}
			return retArr;
		}

		public void close() throws IOException {
			reader.close();
		}
	}

}
"
69,"import java.util.*;
 
public class Main(){
  public static void main(String[] args){
    Scanner sc = new Scanner(System.in);
    int a = sc.nextInt();
    int b = sc.nextInt();
    if(a * b % 2 == 0){
        System.out.println(""Even"");
    }else{
        System.out.println(""Odd"");
    }    
  }
}"
70,"import java.util.*;

public class Main{
  public static void main(String[]args){
    Scanner sc=new Scanner(System.in);
    
    String s=sc.next();
    ArrayList <String>arr=new ArrayList<>();
    for(int i=0;i<s.length();i++){
      arr.add(String.valueOf(s.charAt(i)));
    }
    Collections.sort(arr);
    int count=0;

    for(int i=0;;i++){
      if(arr.contains(""0"") && arr.contains(""1"")){
        arr.remove(0);
        arr.remove(arr.size()-1);
        count+=2;
      }else{
        break;
      }
    }

    System.out.println(count);


    sc.close();
  }
}"
71,"// -*- coding: utf-8 -*-
//import java.awt.*;
import java.io.*;
import java.math.*;
import java.text.*;
import java.util.*;

public class Main {
  public static void main(String[] args) {
    InputStream inputStream;
    if (args.length > 0 && args[0].equals(""devTesting"")) {
      try {
        inputStream = new FileInputStream(args[1]);
      } catch(FileNotFoundException e) {
        throw new RuntimeException(e);
      }
    } else {
      inputStream = System.in;
    }
    OutputStream outputStream = System.out;
    InputReader in = new InputReader(inputStream);
    PrintWriter out = new PrintWriter(outputStream);
    TaskE solver = new TaskE();
    solver.solve(1, in, out);
    out.close();
  }
  
  static class TaskE {    
    final long ring = 9223372036854775783L;
    int n;
    int[][] c;
    
    void solve(int testNumber, InputReader in, PrintWriter out) {
      n = in.nextInt();
      c = new int[n][4];
      for (int i = 0; i < n; ++i)
        for (int j = 0; j < 4; ++j)
          c[i][j] = in.nextInt();
      int ptr = 0;
      Map<Long, Integer> table = new HashMap<Long, Integer>();
      for (int i = 0; i < n; ++i) {
        long mask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);
        for (int j = 0; j < 4; ++j) {
          if (!table.containsKey(mask))
            table.put(mask, ptr++);
          mask = rotater(mask);
        }
      }
      int[] count = new int[ptr];
      for (int i = 0; i < n; ++i) {
        long mask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);
        for (int j = 0; j < 4; ++j) {
          ++count[table.get(mask)];
          mask = rotater(mask);
        }
      }
      long acc = 0;
      long[] bk3 = new long[4];
      List<Long> list = new ArrayList<Long>();
      for (int i = 0; i < n; ++i) {
        long lmask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);
        long bk1 = lmask;
        for (int j = 0; j < 4; ++j) {
          int idx = table.get(bk1);
          --count[idx];
          bk1 = rotater(bk1);
        }
        for (int j = 0; j < 4; ++j) {
          for (int k = 0; k < n; ++k)
            if (k != i) {
              long rmask = pack(c[k][3], c[k][2], c[k][1], c[k][0]);
              long bk2 = rmask;
              for (int p = 0; p < 4; ++p) {
                int idx = table.get(bk2);
                --count[idx];
                bk2 = rotater(bk2);
              }
              for (int p = 0; p < 4; ++p) {
                long prod = 1;
                long rrmask = rmask;
                long llmask = lmask;
                boolean okay = true;
                Arrays.fill(bk3, -1);
                for (int q = 0; q < 4; ++q) {
                  long mask = pack(extract(llmask, 16, 16), extract(rrmask, 0, 16), extract(rrmask, 16, 16), extract(llmask, 0, 16));
                  if (table.containsKey(mask)) {
                    prod *= count[table.get(mask)];
                    bk3[q] = mask;
                    for (int r = 0; r < 4; ++r) {
                      int idx = table.get(bk3[q]);
                      --count[idx];
                      bk3[q] = rotater(bk3[q]);
                    }
                  } else
                    okay = false;
                  llmask = rotater(llmask);
                  rrmask = rotatel(rrmask);
                }
                if (okay) {
                  acc += prod;
                  if (acc > Long.MAX_VALUE / 48 && acc % 24 == 0) {
                    list.add(acc);
                    acc = 0;
                  }
                }
                for (int q = 0; q < 4; ++q)
                  if (bk3[q] != -1)
                    for (int r = 0; r < 4; ++r) {
                      int idx = table.get(bk3[q]);
                      ++count[idx];
                      bk3[q] = rotater(bk3[q]);
                    }
                rmask = rotater(rmask);
              }
              for (int p = 0; p < 4; ++p) {
                int idx = table.get(bk2);
                ++count[idx];
                bk2 = rotater(bk2);
              }
            }
          lmask = rotater(lmask);
        }
        for (int j = 0; j < 4; ++j) {
          int idx = table.get(bk1);
          ++count[idx];
          bk1 = rotater(bk1);
        }
      }
      long ans = 0;
      for (long i : list)
        ans += i / 24;
      ans += acc / 24;
      out.println(ans);
    }
    
    long pack(long a, long b, long c, long d) {
      return a << 48 | b << 32 | c << 16 | d;
    }
    
    long extract(long a, int offset, int size) {
      return a >>> offset & (1L << size) - 1;
    }
    
    long rotater(long a) {
      return a << 16 | a >>> 48;
    }
    
    long rotatel(long a) {
      return a >>> 16 | a << 48;
    }    
    
  }
      
  static class InputReader {
    public BufferedReader reader;
    public StringTokenizer tokenizer;

    public InputReader(InputStream stream) {
      reader = new BufferedReader(new InputStreamReader(stream));
      tokenizer = null;
    }

    public String next() {
      while (tokenizer == null || !tokenizer.hasMoreTokens()) {
        try {
          tokenizer = new StringTokenizer(reader.readLine());
        } catch (IOException e) {
          throw new RuntimeException(e);
        }
      }
      return tokenizer.nextToken();
    }
    
    public String nextLine() {
      try {
        return reader.readLine();
      } catch(IOException e) {
        throw new RuntimeException(e);
      }
    }

    public int nextInt() {
      return Integer.parseInt(next());
    }

    public long nextLong() {
      return Long.parseLong(next());
    }
    
    public double nextDouble() {
      return Double.parseDouble(next());
    }

    public boolean hasInput() {
      try {
        if (tokenizer != null && tokenizer.hasMoreTokens()) {
          return true;
        }
        reader.mark(1);
        int ch = reader.read();
        if (ch != -1) {
          reader.reset();
          return true;
        }
        return false;
      } catch(IOException e) {
        throw new RuntimeException(e);
      }
    }
    
  }
}"
72,"class Qq{
    public static void main(String args[]){
        for(int i = 1;i < 10;i++){
            for(int j = 1;j < 10;j++){
                int k = i*j;
                System.out.println(i+""*""+j+""=""+k);
            }
        }
    }
}"
73,"import java.util.*;

class Main{
  public static void main(String[] args){
    Scanner sc = new Scanner(System.in);
    String s = sc.next();
    int q = sc.nextInt();
    
    boolean flg = false;
    
    for(int j=0;j<q;j++){
      if(sc.nextInt()==1){
        flg = !flg;
      }else{
        if(sc.nextInt()==1){
          if(flg){
            s = s+sc.next();
          }else{
            s = sc.next()+s;
          }
        }else{
          if(flg){
            s= sc.next()+s;
          }else{
            s = s+sc.next();
          }
        }
      }
    }
    StringBuffer sb = new StringBuffer(s);
    
    if(flg){
      sb = sb.reverse();
    }
      

    System.out.println(sb);
      
    

  }
}"
74,"import java.util.*;

public class Main{
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int A = sc.nextInt();
    int B = sc.nextInt();
    int K = sc.nextInt();

     for(int i = 0; i < K; i++){
    if(A > 0){
      A = A -1;
    }else{
      B = B -1;
    }
  }

    System.out.println(A + B);
}
}
"
75,"import java.util.Scanner;
public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = Integer.parseInt(sc.next());
		int[] p = new int[n];
		for (int i = 0; i < n; i++)
			p[i] = Integer.parseInt(sc.next());
		int max = 0;
		for (int i = 1; i <= n; i++) {
			int j = i;
			boolean b = false;
			for (int k = 0; k < n; k++) {
				if (p[k] == i - 1 && !b) break;
				if (p[k] == j) {
					b = true;
					j++;
				}
			}
			max = Math.max(max, j - i + 1);
		}
		System.out.println(n - max + 1);
	}
}"
76,"import java.util.Scanner;

class Main{
    public static void main(String[] args){
 
        Scanner sc = new Scanner(System.in);
     
        int A = sc.nextInt(); 
        int B = sc.nextInt(); 
        int K = sc.nextInt();
     
        if(2 * K  <= B - A  ){
          for(int i = 0 ; i < K ; i ++ ){
            System.out.println(A + i);
          }
          for(int i = K - 1 ; i >= 0  ; i -- ){
            System.out.println(B - i);
          }
        } else {
          for(int i = 0 ; i < B - A + 1;i ++ ){
            System.out.println(A + i);
          }
        }
      }
}"
77,"import java.util.*;
class A163{
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        int r=sc.nextInt();
        double pi = 3.14;
        double cirf=2*pi*r;
        System.out.println(cirf);

    }
}"
78,"import java.util.*;
public class Main {
public static void main(String[] args){
Scanner sc = new Scanner(System.in);
String ans="""";
String s=sc.next();
    for (int i = 0; i < s.length(); i++) {
        if(i%2==0)ans+=s.charAt(i);
    }
System.out.println(ans);
}
}"
79,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

public class Main {

    public static void main(String[] args) {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        try {
            String s = br.readLine();
            DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(""yyyy/MM/dd"");
            LocalDate date = LocalDate.parse(s, dateTimeFormatter);
            LocalDate date0430 = LocalDate.of(2019, 4, 30);
            if (date.isAfter(date0430)) {
                System.out.println(""TBD"");
            } else {
                System.out.println(""Heisei"");
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}"
80,"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.io.Closeable;
import java.io.IOException;
import java.util.NoSuchElementException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author HBonsai
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        FastScanner in = new FastScanner(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        ShortestPathDijkstra2 solver = new ShortestPathDijkstra2();
        solver.solve(1, in, out);
        out.close();
    }

    static class ShortestPathDijkstra2 {
        public void solve(int testNumber, FastScanner in, PrintWriter out) {
            int V = in.nextInt();
            int E = in.nextInt();
            int r = in.nextInt();
            final int INF = Integer.MAX_VALUE / 3;
            int[][] cost = new int[V][V];
            for (int[] ints : cost) Arrays.fill(ints, INF);
            for (int i = 0; i < E; i++) {
                int u = in.nextInt();
                int v = in.nextInt();
                cost[u][v] = in.nextInt();
            }
            int[] d = new int[V];
            boolean[] used = new boolean[V];
            Arrays.fill(d, INF);
            Arrays.fill(used, false);
            d[r] = 0;
            while (true) {
                int v = -1;
                for (int u = 0; u < V; u++) {
                    if (!used[u] && (v == -1 || d[u] < d[v])) v = u;
                }
                if (v == -1) break;
                used[v] = true;
                for (int u = 0; u < V; u++) {
                    d[u] = Math.min(d[u], d[v] + cost[v][u]);
                }
            }
            for (int i = 0; i < V; i++) {
                if (d[i] == INF) out.println(""INF"");
                else out.println(d[i]);
            }
        }

    }

    static class FastScanner implements Closeable {
        private final InputStream in;
        private final byte[] buffer = new byte[1024];
        private int ptr = 0;
        private int buflen = 0;

        public FastScanner(InputStream in) {
            this.in = in;
        }

        private boolean hasNextByte() {
            if (ptr < buflen) {
                return true;
            } else {
                ptr = 0;
                try {
                    buflen = in.read(buffer);
                } catch (IOException e) {
                    e.printStackTrace();
                }
                if (buflen <= 0) {
                    return false;
                }
            }
            return true;
        }

        private int readByte() {
            if (hasNextByte()) return buffer[ptr++];
            else return -1;
        }

        private static boolean isPrintableChar(int c) {
            return 33 <= c && c <= 126;
        }

        public boolean hasNext() {
            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
            return hasNextByte();
        }

        public long nextLong() {
            if (!hasNext()) throw new NoSuchElementException();
            long n = 0;
            boolean minus = false;
            int b = readByte();
            if (b == '-') {
                minus = true;
                b = readByte();
            }
            if (b < '0' || '9' < b) {
                throw new NumberFormatException();
            }
            while (true) {
                if ('0' <= b && b <= '9') {
                    n *= 10;
                    n += b - '0';
                } else if (b == -1 || !isPrintableChar(b)) {
                    return minus ? -n : n;
                } else {
                    throw new NumberFormatException();
                }
                b = readByte();
            }
        }

        public int nextInt() {
            long nl = nextLong();
            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
            return (int) nl;
        }

        public void close() {
            try {
                in.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

    }
}


"
81,"import java.io.*;
import java.util.*;

public class Main{
	public static void main(String args[]){
		try{
			new Main();
		}catch(IOException err){
			err.printStackTrace();
		}
	}

	public Main() throws IOException{
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
		List<Integer> Ans = new ArrayList<Integer>();
		String line;

		while((line = in.readLine()) != null){
			int[] x = new int[]{1, 1, 1};
			int[] a = new int[3];
			int[] m = new int[3];
			String[] dst = line.split("" "");

			int end = 0;
			for(int i=0; i<3; i++){
				a[i] = Integer.parseInt(dst[2*i]);
				m[i] = Integer.parseInt(dst[2*i+1]);

				if(a[i] != 0 && m[i] != 0){
					end = 1;
				}
			}

			if(end == 0){
				break;
			}

			int count = 0;
			do{
				count++;
				for(int i=0 ;i<3; i++){
					x[i] = mod(a[i] * x[i], m[i]);
				}
			}while(x[0]!=1 || x[1]!=1 || x[2]!=1);

			Ans.add(count);
		}

		for(int i=0; i<Ans.size(); i++){
			System.out.println(Ans.get(i));
		}

	}

	public int mod(int a, int b){
		int x = a / b;
		return a - x * b;
	}
}"
82,"import java.util.*;
public class Main {
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		// 整数の入力
		int S = sc.nextInt();
		
		if(S.equals('ABC')){
        	System.out.println(""ARC"");
        }
        else{
        	System.out.println(""ABC"");
        }
	}
}"
83,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

class Main {
    public static void main(String argv[]) throws IOException {
    	InputStreamReader br = new InputStreamReader(System.in);
    	BufferedReader is = new BufferedReader(br);
    	String aa = is.readLine();
    	String bb = is.readLine();
    	int a = Integer.parseInt(aa);
    	int b = Integer.parseInt(bb);
    	System.out.println((a*b) + "" "" + 2*(a+b));
    }
}"
84,"
import java.util.Scanner;

public class Main {

	static Scanner scanner;

	public static void main(String[] args) {
	    scanner = new Scanner(System.in);

	    int n=gi();
	    int m=gi();
	    
	    int n1=f(n)/f(n-2);
	    int m1=f(m)/f(m-2);

	    System.out.print((n1+m1)/2);

//        if (s.charAt(0)==s.charAt(1) && s.charAt(1)== s.charAt(2)) {
//        	System.out.print(""Yes"");
//        }else {
//        	System.out.print(""No"");
//        }


	}

	public static int f(int n) {
		if (n<=1) {
			return 1;
		} else {
			return n* f(n-1);
		}
	}
	// 文字列として入力を取得
	public static String gs() {
		return scanner.next();
	}

	// intとして入力を取得
	public static int gi() {
		return Integer.parseInt(scanner.next());
	}

	// longとして入力を取得
	public static long gl() {
		return Long.parseLong(scanner.next());
	}

	// doubleとして入力を取得
	public static double gd() {
		return Double.parseDouble(scanner.next());
	}
}"
85,"
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.lang.reflect.Array;
import java.math.BigInteger;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class Main {

    public static void main(String[] args) throws IOException {
        new Main().solve();
    }

    private void solve() throws IOException {
        try {
//            solveA();
//            solveB();
//            solveC();
            solveD();
//            solveE();
//            solveF();
        } finally {
            if (in != null) {
                in.close();
            }
            if (out != null) {
                out.flush();
                out.close();
            }
        }

    }

    // mods
    long MOD = (long) Math.pow(10, 9) + 7;

    private void solveA() {
        int n = nextInt();
        out.println(n / 2 + n % 2);
    }

    private void solveB() {
        int[][] card = IntStream.range(0, 3).mapToObj(i -> new int[]{nextInt(), nextInt(), nextInt()}).toArray(int[][]::new);
        int n = nextInt();
        int[] b = IntStream.range(0, n).map(i -> nextInt()).toArray();
        Arrays.stream(b).forEach(
                x -> {
                    for (int i = 0; i < 3; i++) {
                        for (int j = 0; j < 3; j++) {
                            if (card[i][j] == x)
                                card[i][j] = -1;
                        }
                    }
                }
        );
        boolean isComplete =
                card[0][0] == -1 && card[0][1] == -1 && card[0][2] == -1
                        || card[1][0] == -1 && card[1][1] == -1 && card[1][2] == -1
                        || card[2][0] == -1 && card[2][1] == -1 && card[2][2] == -1
                        || card[0][0] == -1 && card[1][1] == -1 && card[2][2] == -1
                        || card[0][2] == -1 && card[1][1] == -1 && card[2][0] == -1;
        out.println(isComplete ? ""Yes"" : ""No"");
    }

    private void solveC() {
        int n = nextInt();
        int m = nextInt();
        int[][] sc = Stream.generate(() -> new int[]{nextInt(), nextInt()}).limit(m).toArray(int[][]::new);
        Arrays.sort(sc, (x, y) -> Integer.compare(x[0], y[0]) == 0 ? Integer.compare(x[1], y[1]) : Integer.compare(x[0], y[0]));
        int[] res = new int[n];
        for (int[] item : sc) {
            int idx = item[0] - 1;
            if (res[idx] == 0) {
                res[idx] = item[1];
            }
        }
        String wk = Arrays.stream(res).mapToObj(i -> Integer.toString(i)).collect(Collectors.joining(""""));
        if (n == 1 || res[0] != 0)
            out.println(wk);
        else
            out.println(-1);
    }

    private void solveD() {

        int n = nextInt();
        int m = nextInt();
        int k = nextInt();
        int[][] ab = Stream.generate(() -> new int[]{nextInt(), nextInt()}).limit(m).toArray(int[][]::new);
        Map<Integer, Person> friendsMap = new HashMap<Integer, Person>();
        for (int[] abW : ab) {
            friendsMap.putIfAbsent(abW[0], new Person(abW[0]));
            friendsMap.get(abW[0]).friends.add(abW[1]);
            friendsMap.putIfAbsent(abW[1], new Person(abW[1]));
            friendsMap.get(abW[1]).friends.add(abW[0]);
        }
        int[][] cd = Stream.generate(() -> new int[]{nextInt(), nextInt()}).limit(k).toArray(int[][]::new);
        Map<Integer, Person> blockMap = new HashMap<Integer, Person>();
        for (int[] abW : cd) {
            blockMap.putIfAbsent(abW[0], new Person(abW[0]));
            blockMap.get(abW[0]).friends.add(abW[1]);
            blockMap.putIfAbsent(abW[1], new Person(abW[1]));
            blockMap.get(abW[1]).friends.add(abW[0]);
        }
        StringBuilder builder = new StringBuilder();
        for (int i = 1; i <= n; i++) {
            Person fPerson = friendsMap.getOrDefault(i, new Person(i));
            Person bPerson = blockMap.getOrDefault(i, new Person(i));
            int num = 0;
            for (int j = 1; j <= n; j++) {
                if (i == j)
                    continue;
                if (!fPerson.friends.contains(j) && !bPerson.friends.contains(j)
                        && isFriend(friendsMap, i, j)) {
                    num++;
                }
            }
            builder.append(num).append("" "");
        }
        out.println(builder.toString());
    }

    private boolean isFriend(Map<Integer, Person> map, int startPerson, int targetPerson) {

        Set<Integer> visited = new HashSet<Integer>();
        visited.add(startPerson);
        Queue<Person> queue = new ArrayDeque<Person>();
        queue.add(map.getOrDefault(startPerson, new Person(-1)));
        while (queue.size() != 0) {
            int count = queue.size();
            for (int i = 0; i < count; i++) {
                Person inner = queue.poll();
                visited.add(inner.n);
                for (int p : inner.friends) {
                    if (p == targetPerson)
                        return true;
                    if (!visited.contains(p)) {
                        queue.add(map.get(p));
                    }
                }
            }
        }
        return false;
    }

    private static class Person {
        private int n;
        private Set<Integer> friends;

        public Person(int n) {
            this.n = n;
            this.friends = new HashSet<>();
        }

        public void addFriends(int f) {
            friends.add(f);
        }
    }

    private void solveE() {

    }

    private void solveF() {

    }


    long abs(double x) {
        return (long) Math.abs(x);
    }

    long round(double x) {
        return Math.round(x);
    }

    long floor(double x) {
        return (long) Math.floor(x);
    }

    long ceil(double x) {
        return (long) Math.ceil(x);
    }

    double sqrt(double x) {
        return Math.sqrt(x);
    }

    double pow(double x, double y) {
        return Math.pow(x, y);
    }

    long pow(long x, long y) {
        return (long) Math.pow(x, y);
    }

    int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }

    long gcd(long a, long b) {
        return b == 0 ? a : gcd(b, a % b);
    }

    long lcm(long a, long b) {
        return a * b / gcd(a, b);
    }

    int upperToInt(char a) {
        return a - 'A';
    }

    int lowerToInt(char a) {
        return a - 'a';
    }

    int numToInt(char a) {
        return a - '0';
    }

    int charToInt(char a) {
        return a >= 'a' ? lowerToInt(a) : a >= 'A' ? upperToInt(a) : numToInt(a);
    }

    char intToUpper(int a) {
        return (char) (a + 'A');
    }

    char intToLower(int a) {
        return (char) (a + 'a');
    }

    char intToNum(int a) {
        return (char) (a + '0');
    }

    void reverse(String array[]) {
        String reversed[] = new String[array.length];
        for (int i = 0; i < array.length; i++) {
            reversed[array.length - i - 1] = array[i];
        }
        for (int i = 0; i < array.length; i++) {
            array[i] = reversed[i];
        }
    }

    void reverse(int array[]) {
        int reversed[] = new int[array.length];
        for (int i = 0; i < array.length; i++) {
            reversed[array.length - i - 1] = array[i];
        }
        for (int i = 0; i < array.length; i++) {
            array[i] = reversed[i];
        }
    }

    void reverse(long array[]) {
        long reversed[] = new long[array.length];
        for (int i = 0; i < array.length; i++) {
            reversed[array.length - i - 1] = array[i];
        }
        for (int i = 0; i < array.length; i++) {
            array[i] = reversed[i];
        }
    }

    void reverse(double array[]) {
        double reversed[] = new double[array.length];
        for (int i = 0; i < array.length; i++) {
            reversed[array.length - i - 1] = array[i];
        }
        for (int i = 0; i < array.length; i++) {
            array[i] = reversed[i];
        }
    }

    void reverse(boolean array[]) {
        boolean reversed[] = new boolean[array.length];
        for (int i = 0; i < array.length; i++) {
            reversed[array.length - i - 1] = array[i];
        }
        for (int i = 0; i < array.length; i++) {
            array[i] = reversed[i];
        }
    }

    void fill(int array[], int x) {
        Arrays.fill(array, x);
    }

    void fill(long array[], long x) {
        Arrays.fill(array, x);
    }

    void fill(double array[], double x) {
        Arrays.fill(array, x);
    }

    void fill(boolean array[], boolean x) {
        Arrays.fill(array, x);
    }

    void fill(int array[][], int x) {
        for (int a[] : array) {
            fill(a, x);
        }
    }

    void fill(long array[][], long x) {
        for (long a[] : array) {
            fill(a, x);
        }
    }

    void fill(double array[][], double x) {
        for (double a[] : array) {
            fill(a, x);
        }
    }

    void fill(boolean array[][], boolean x) {
        for (boolean a[] : array) {
            fill(a, x);
        }
    }

    void fill(int array[][][], int x) {
        for (int a[][] : array) {
            fill(a, x);
        }
    }

    void fill(long array[][][], long x) {
        for (long a[][] : array) {
            fill(a, x);
        }
    }

    void fill(double array[][][], double x) {
        for (double a[][] : array) {
            fill(a, x);
        }
    }

    void fill(boolean array[][][], boolean x) {
        for (boolean a[][] : array) {
            fill(a, x);
        }
    }

    long INF = (long) 1e18 + 7;

    boolean isINF(long a) {
        return abs(a) > INF / 1000;
    }

    boolean isPlusINF(long a) {
        return a > 0 && isINF(a);
    }

    boolean isMinusINF(long a) {
        return isPlusINF(-a);
    }

    int I_INF = (int) 1e9 + 7;

    boolean isINF(int a) {
        return abs(a) > I_INF / 1000;
    }

    boolean isPlusINF(int a) {
        return a > 0 && isINF(a);
    }

    boolean isMinusINF(int a) {
        return isPlusINF(-a);
    }

    public long mod(long i) {
        return i % MOD + ((i % MOD) < 0 ? MOD : 0);
    }

    long powMod(long x, long y) {
        if (y == 0) {
            return 1;
        } else {
            long tmp = powMod(x, y / 2);
            return mod(mod(tmp * tmp) * (y % 2 == 0 ? 1 : x));
        }
    }

    long[] powsMod(long x, int max) {
        long pow[] = new long[max + 1];
        pow[0] = 1;
        for (int i = 0; i < max; i++) {
            pow[i + 1] = mod(pow[i] * x);
        }
        return pow;
    }

    long inv(long x) {
        return powMod(x, MOD - 2);
    }

    int MAX_FACT = 5_000_100;
    long fact[];
    long invFact[];

    /**
     * Combination簡易版
     * 5 C 2
     * 異なる n個のものから r個を選ぶ組み合わせの総数 nCr を求めます。
     * 5!(5*4*3*2*1)
     * /
     * 2!(2*1) *  (5-2)!(3*2*1)
     *
     * @param n
     * @param r
     * @return
     */
    private long getComb(int n, int r) {
        long tmp = 1;
        for (int i = 1; i <= r; i++) {
            tmp *= n - i + 1;
            tmp = mod(tmp);
            tmp *= inv(i);
            tmp = mod(tmp);
        }
        return tmp;
    }

    /**
     * 階乗計算の事前累積和
     * [1, 1, 2, 3, 4, 5, … FACTORIAL_NUM]
     * mod済
     */
    void prepareFact() {
        fact = new long[MAX_FACT];
        Arrays.fill(fact, 0);
        invFact = new long[MAX_FACT];
        Arrays.fill(invFact, 0);
        fact[0] = 1;
        int maxIndex = (int) min(MAX_FACT, (int) MOD);
        for (int i = 1; i < maxIndex; i++) {
            fact[i] = mod(fact[i - 1] * i);
        }
        invFact[maxIndex - 1] = inv(fact[maxIndex - 1]);
        for (int i = maxIndex - 1; i > 0; i--) {
            invFact[i - 1] = mod(invFact[i] * i);
        }
    }

    /**
     * 順列
     * nPk -> n! / (n-k)!
     *
     * @param n
     * @param r
     * @return
     */
    long permutation(int n, int r) {
        if (n < 0 || r < 0 || n < r) {
            return 0;
        }
        return mod(fact[n] * invFact[n - r]);
    }

    /**
     * 組み合わせ
     * nCk -> n! / k!・(n-k)!
     *
     * @param n
     * @param r
     * @return
     */
    long combination(int n, int r) {
        if (n < 0 || r < 0 || n < r) {
            return 0;
        }
        return mod(permutation(n, r) * invFact[r]);
    }

    /**
     * 重複組合せ nHr （同次積）
     * nHr = (n+r-1)Cr
     * 異なるn個のものから重複を許してr個取る組合せの総数
     * 例：
     * リンゴ，ミカン，牛肉の3種類の果物があります．これらの中から6個の食材を買って帰ります．
     * このとき，何通りの買い方がありますか？ただし，含まれない食材があってもよいものとします
     *
     * @param n
     * @param r
     * @return
     */
    long homogeneousProduct(int n, int r) {
        return combination((n - 1) + r, r);
    }

    /**
     * 多項係数
     * 文字aをp個,bをq個,cをr個, dをs個 あわせてn個を1列に並べるときの並べ方
     * n! / p!・q!・r!・s!
     *
     * @param n
     * @param strNum
     * @param mod
     * @return
     */

    /**
     * フェルマーの小定理を用いて逆元を求める。
     * ある数xのmod p（pは素数）の逆数x'はx' = x^(p-2)
     * 繰り返し二乗法を用いて計算する。
     * http://satanic0258.hatenablog.com/entry/2016/04/29/004730
     * {@link BigInteger#modInverse(BigInteger)}とどちらが速いか？
     *
     * @param x
     * @return
     */
    private long modInverse(long x, long mod) {
        long res = 1L;
        long k = mod - 2L;
        long y = x;
        while (k != 0) {
            if (k % 2 != 0) {
                res = (res * y) % mod;
            }
            y = (y * y) % mod;
            k /= 2;
        }
        return res;
    }


    private final PrintWriter out = new PrintWriter(System.out);
    private final InputStream in = System.in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        } else {
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }

    private int readByte() {
        if (hasNextByte())
            return buffer[ptr++];
        else
            return -1;
    }

    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }

    private void skipUnprintable() {
        while (hasNextByte() && !isPrintableChar(buffer[ptr]))
            ptr++;
    }

    public boolean hasNext() {
        skipUnprintable();
        return hasNextByte();
    }

    public int nextInt() {
        return Integer.parseInt(next());
    }

    public String next() {
        if (!hasNext())
            throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while (isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    public long nextLong() {
        if (!hasNext())
            throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            } else if (b == -1 || !isPrintableChar(b)) {
                return minus ? -n : n;
            } else {
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }

    public long min(long... v) {
        long min = Long.MAX_VALUE;
        for (long i : v) min = Math.min(min, i);
        return min;
    }

    public long max(long... v) {
        long max = Long.MIN_VALUE;
        for (long i : v) max = Math.max(max, i);
        return max;
    }
}

class Combination {
    static final int MOD = (int) (Math.pow(10, 9) + 7);
    long[] fact;
    long[] invFact;
    long[] inv;

    public Combination(int n) {
        fact = new long[n + 1];
        invFact = new long[n + 1];
        inv = new long[n + 1];
        fact[0] = 1;
        fact[1] = 1;
        invFact[0] = 1;
        invFact[1] = 1;
        inv[1] = 1;
        for (int i = 2; i < n + 1; i++) {
            fact[i] = fact[i - 1] * i % MOD;
            inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;
            invFact[i] = invFact[i - 1] * inv[i] % MOD;
        }
    }

    public long combination(int n, int k) {
        if (n < k || n < 0 || k < 0) {
            return 0;
        }
        return fact[n] * (invFact[k] * invFact[n - k] % MOD) % MOD;
    }
}"
86,"import java.awt.Point;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.StringTokenizer;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.PriorityQueue;
import java.util.TreeMap;
public class Main
{
    static class Scanner
    {
        BufferedReader br;
        StringTokenizer tk=new StringTokenizer("""");
        public Scanner(InputStream is) 
        {
            br=new BufferedReader(new InputStreamReader(is));
        }
        public int nextInt() throws IOException
        {
            if(tk.hasMoreTokens())
                return Integer.parseInt(tk.nextToken());
            tk=new StringTokenizer(br.readLine());
            return nextInt();
        }
        public long nextLong() throws IOException
        {
            if(tk.hasMoreTokens())
                return Long.parseLong(tk.nextToken());
            tk=new StringTokenizer(br.readLine());
            return nextLong();
        }
        public String next() throws IOException
        {
            if(tk.hasMoreTokens())
                return (tk.nextToken());
            tk=new StringTokenizer(br.readLine());
            return next();
        }
        public String nextLine() throws IOException
        {
            tk=new StringTokenizer("""");
            return br.readLine();
        }
        public double nextDouble() throws IOException
        {
            if(tk.hasMoreTokens())
                return Double.parseDouble(tk.nextToken());
            tk=new StringTokenizer(br.readLine());
            return nextDouble();
        }
        public char nextChar() throws IOException
        {
            if(tk.hasMoreTokens())
                return (tk.nextToken().charAt(0));
            tk=new StringTokenizer(br.readLine());
            return nextChar();
        }
        public int[] nextIntArray(int n) throws IOException
        {
            int a[]=new int[n];
            for(int i=0;i<n;i++)
                a[i]=nextInt();
            return a;
        }
        public long[] nextLongArray(int n) throws IOException
        {
            long a[]=new long[n];
            for(int i=0;i<n;i++)
                a[i]=nextLong();
            return a;
        }
        public int[] nextIntArrayOneBased(int n) throws IOException
        {
            int a[]=new int[n+1];
            for(int i=1;i<=n;i++)
                a[i]=nextInt();
            return a;
        }
        public long[] nextLongArrayOneBased(int n) throws IOException
        {
            long a[]=new long[n+1];
            for(int i=1;i<=n;i++)
                a[i]=nextLong();
            return a;
        }
    
    
    }
    public static void main(String args[]) throws IOException
    {
        new Thread(null, new Runnable() {
            public void run() {
                try
                {
                    solve();
                }
                catch(Exception e)
                {
                    e.printStackTrace();
                }
            }
        }, ""1"", 1 << 26).start();
        
    }
    static class Pair{
        long x;
        int y;
        Pair(long a,int b){
            x=a;y=b;
        }
    }
    static ArrayList<Point> g[];
    static int d[];
    static boolean vis[];
    static HashMap<Integer, HashMap<Integer, Integer>> gg;
    static int tt=0;
    static int ensure(int u, int c){
        if(!gg.containsKey(u)){
            gg.put(u, new HashMap<>());
        }
        if(!gg.get(u).containsKey(c)){
            gg.get(u).put(c,tt);
            d[tt]=Integer.MAX_VALUE;
            g[tt]=new ArrayList<>();
            return tt++;
        }
        return gg.get(u).get(c);
    }
    static void addEdge(int u,int v,int c){
        
        int u0=ensure(u,0);
        int v0=ensure(v,0);
        int uc=ensure(u,c);
        int vc=ensure(v,c);
        addEdgeInternal(u0, uc, 1);
        addEdgeInternal(v0, vc, 1);
        addEdgeInternal(uc, vc, 0);
    }
    static void addEdgeInternal(int u, int v, int wt){
        g[u].add(new Point(v,wt));
        g[v].add(new Point(u, wt));
    }
    static void solve() throws IOException
    {
        Scanner in=new Scanner(System.in);
        PrintWriter out=new PrintWriter(System.out);
        int n=in.nextInt();
        int m=in.nextInt();
        gg=new HashMap<>();
        g=new ArrayList[10000000];
        d=new int[10000000];
        vis=new boolean[10000000];
        for(int i=0;i<m;i++){
            int u=in.nextInt();
            int v=in.nextInt();
            int c=in.nextInt();
            addEdge(u, v, c);
        }
        int o0=ensure(1,0);
        int n0=ensure(n,0);
        
        d[o0]=0;
        PriorityQueue<Point> pq=new PriorityQueue<>((a,b)->Integer.compare(a.y, b.y));
        pq.add(new Point(o0,0));
        while(!pq.isEmpty()){
            Point nd=pq.poll();
            if(vis[nd.x])
                continue;
            vis[nd.x]=true;
            for(Point edg:g[nd.x]){
                int nextWeight=nd.y+edg.y;
                if(nextWeight<d[edg.x]){
                    d[edg.x]=nextWeight;
                    
                    pq.add(new Point(edg.x, nextWeight));
                }
            }
        }
        out.println((d[n0]==Integer.MAX_VALUE)?-1:(d[n0]/2));
        out.close();
        
    }
}
"
87,"import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ
		Scanner scn = new Scanner(System.in);

		String N = scn.next();

        int s = 0;
//        while(num != 0){
//            s += num % 10;
//            num /= 10;
//        }

        for (int i = 0; i < N.length(); i++) {
        	s += Integer.parseInt(N.substring(i, i+1));
        }

//        System.out.println(s);
//        if (s > 8) {
    		System.out.println(s % 9 == 0 ? ""Yes"" : ""No"");
//		} else {
//			if (s == 0) {
//				System.out.println(""Yes"");
//			} else {
//				System.out.println(""No"");
//			}
//        }


	}
}
"
88,"import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.InputMismatchException;
import java.util.Scanner;

public class Main implements Runnable {
	static InputStream is;
	static PrintWriter out;
	static String INPUT = """";

	public static void main(String[] args) {
		new Thread(null, new Main(), """", Runtime.getRuntime().maxMemory()).start();
	}

	final long MOD = 1_000_000_000 + 7;
	final int N = 100000;
	long[] fac = new long[2 * N + 1];
	long[] invfac = new long[2 * N + 1];
	long[] inv = new long[2 * N + 1];
	{
		fac[0] = 1;
		invfac[0] = 1;
		inv[1] = 1;
		for (int i = 1; i < fac.length; ++i)
			fac[i] = fac[i - 1] * i % MOD;
		for (int i = 2; i < inv.length; ++i) {
			inv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;
		}
		for (int i = 1; i < invfac.length; ++i) {
			invfac[i] = invfac[i - 1] * inv[i] % MOD;
		}
	}

	long c(int n, int k) {
		return fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;
	}

	class DJSet {
		int[] upper;
		int[] e_sz;
		int n;

		public DJSet(int n_) {
			n = n_;
			upper = new int[n];
			e_sz = new int[n];
			Arrays.fill(upper, -1);
		}

		int root(int x) {
			return upper[x] < 0 ? x : (upper[x] = root(upper[x]));
		}

		boolean equiv(int x, int y) {
			return root(x) == root(y);
		}

		void setUnion(int x, int y) {
			x = root(x);
			y = root(y);
			if (x == y) {
				++e_sz[x];
				return;
			}
			if (upper[x] < upper[y]) {
				x ^= y;
				y ^= x;
				x ^= y;
			}
			upper[y] += upper[x];
			upper[x] = y;
			e_sz[y] += e_sz[x] + 1;
			e_sz[x] = -1;
		}

		int sz(int x) {
			return -upper[root(x)];
		}
	}

	void scc(ArrayList<Integer>[] g) {
		int n = g.length;
		col = new int[n];
		int[] ord = new int[n];
		int[] low = new int[n];
		col_sz = new int[n];
		Arrays.fill(col, -1);
		Arrays.fill(ord, -1);
		ArrayDeque<Integer> pend = new ArrayDeque<>();
		order = 0;
		color = 0;
		for (int i = 0; i < n; ++i) {
			if (col[i] == -1)
				scc_dfs(i, -1, g, ord, low, pend);
		}
		col_sz = Arrays.copyOf(col_sz, color);
	}

	void scc_dfs(int cur, int par, ArrayList<Integer>[] g, int[] ord, int[] low, ArrayDeque<Integer> pend) {
		pend.addLast(cur);
		ord[cur] = order++;
		low[cur] = ord[cur];
		for (int dst : g[cur]) {
			if (dst == par || col[dst] != -1)
				continue;
			if (ord[dst] != -1) {
				low[cur] = Math.min(low[cur], low[dst]);
			} else {
				scc_dfs(dst, cur, g, ord, low, pend);
				low[cur] = Math.min(low[cur], low[dst]);
			}
		}
		if (ord[cur] == low[cur]) {
			int v = -1;
			while (v != cur) {
				v = pend.pollLast();
				col[v] = color;
				col_sz[color]++;
			}
			++color;
		}
	}

	int[] col;
	int[] col_sz;
	int color;
	int order;

	long[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {
		long pat = 1;
		int sz = 0;
		vis[cur] = true;
		for (int dst : g[cur]) {
			long[] q = dfs2(dst, g, vis);
			sz += q[1];
			pat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;
		}
		sz += 1;
		return new long[] { pat, sz };
	}

	void dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {
		boolean update = false;
		for (int v : g[cur]) {
			if (v == par)
				continue;
			if (backward[v].size() == 0) {
				if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {
					if (update)
						continue;
					else
						update = true;
				}
				forward[v].add(cur);
				backward[cur].add(v);
				dfs1(g, v, cur, forward, backward);
			} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {
				forward[v].add(cur);
				backward[cur].add(v);
				update = true;
			}
		}
	}

	long f(ArrayList<Integer>[] g, ArrayList<Integer> v) {

		int n = g.length;
		ArrayList<Integer>[] g2 = new ArrayList[n];
		for (int i = 0; i < g2.length; ++i)
			g2[i] = new ArrayList<>();

		scc(g);

		long ret = 0;

		ArrayList<Integer>[] forward = new ArrayList[n];
		ArrayList<Integer>[] backward = new ArrayList[n];
		for (int i = 0; i < n; ++i) {
			forward[i] = new ArrayList<>();
			backward[i] = new ArrayList<>();
		}

		for (int i = 0; i < n; ++i) {
			if (col_sz[col[i]] > 1) {
				dfs1(g, i, -1, forward, backward);
				break;
			}
		}

		int[] frm = new int[n];
		for (int t = 0; t < 2; ++t) {
			for (int i = 0; i < g2.length; ++i)
				g2[i].clear();
			Arrays.fill(frm, -1);
			for (int i = 0; i < n; ++i) {
				for (int b : backward[i]) {
					for (int f : forward[i]) {
						if (v.get(b) < v.get(f)) {
							g2[i].add(b);
							frm[b] = i;
						}
					}
				}
			}
			int sz = 0;
			long ans = 1;
			boolean[] vis = new boolean[n];
			for (int i = 0; i < n; ++i) {
				if (vis[i])
					continue;
				int j = i;
				while (frm[j] != -1) {
					j = frm[j];
				}
				long[] q = dfs2(j, g2, vis);
				sz += q[1];
				ans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;
			}
			ret = ret + ans;
			if (ret >= MOD)
				ret -= MOD;
			if (t == 0) {
				ArrayList<Integer>[] nf = new ArrayList[n];
				ArrayList<Integer>[] nb = new ArrayList[n];
				for (int i = 0; i < n; ++i) {
					nf[i] = new ArrayList<>();
					nb[i] = new ArrayList<>();
				}
				for (int i = 0; i < n; ++i) {
					for (int u : forward[i]) {
						if (col_sz[col[i]] == 1) {
							nf[i].add(u);
							nb[u].add(i);
						} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {
							nf[u].add(i);
							nb[i].add(u);
						}
					}
				}
				backward = nb;
				forward = nf;
			}
		}
		return ret;

	}

	long solve(int n, int[] x, int[] y) {
		DJSet ds = new DJSet(2 * n);
		ArrayList<Integer>[] vv = new ArrayList[2 * n];
		ArrayList<Integer>[][] gg = new ArrayList[2 * n][];
		for (int i = 0; i < 2 * n; ++i) {
			vv[i] = new ArrayList<>();
		}
		for (int i = 0; i < 2 * n; ++i) {
			ds.setUnion(x[i], y[i] + n);
		}

		int[] id = new int[2 * n];
		for (int i = 0; i < 2 * n; ++i) {
			vv[ds.root(i)].add(i);
		}
		for (int i = 0; i < 2 * n; ++i) {
			Collections.sort(vv[i]);
			for (int v : vv[i])
				id[v] = Collections.binarySearch(vv[i], v);
			gg[i] = new ArrayList[vv[i].size()];
			for (int j = 0; j < gg[i].length; ++j)
				gg[i][j] = new ArrayList<>();
		}
		for (int i = 0; i < 2 * n; ++i) {
			int r = ds.root(x[i]);
			int u = id[x[i]];
			int v = id[y[i] + n];
			gg[r][u].add(v);
			gg[r][v].add(u);
		}
		long ans = 1;
		int tot = 0;
		for (int i = 0; i < gg.length; ++i) {
			if (gg[i].length == 0)
				continue;
			if (ds.sz(i) != ds.e_sz[ds.root(i)]) {
				return 0;
			}
			tot += gg[i].length;
			ans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;
		}
		return ans;
	}

	public void run() {
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		// long t = System.currentTimeMillis();
		int n = ni();
		int[] x = new int[2 * n];
		int[] y = new int[2 * n];
		for (int i = 0; i < 2 * n; ++i) {
			x[i] = ni();
			y[i] = ni();
			--x[i];
			--y[i];
		}
		out.println(solve(n, x, y));
		out.flush();
		// System.err.println(System.currentTimeMillis() - t);
	}

	static void tr(Object... objects) {
		System.out.println(Arrays.deepToString(objects));
	}

	private static boolean eof() {
		if (lenbuf == -1)
			return true;
		int lptr = ptrbuf;
		while (lptr < lenbuf)
			if (!isSpaceChar(inbuf[lptr++]))
				return false;

		try {
			is.mark(1000);
			while (true) {
				int b = is.read();
				if (b == -1) {
					is.reset();
					return true;
				} else if (!isSpaceChar(b)) {
					is.reset();
					return false;
				}
			}
		} catch (IOException e) {
			return true;
		}
	}

	private static byte[] inbuf = new byte[1024];
	static int lenbuf = 0, ptrbuf = 0;

	private static int readByte() {
		if (lenbuf == -1)
			throw new InputMismatchException();
		if (ptrbuf >= lenbuf) {
			ptrbuf = 0;
			try {
				lenbuf = is.read(inbuf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (lenbuf <= 0)
				return -1;
		}
		return inbuf[ptrbuf++];
	}

	private static boolean isSpaceChar(int c) {
		return !(c >= 33 && c <= 126);
	}

	// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=
	// 126); }
	private static int skip() {
		int b;
		while ((b = readByte()) != -1 && isSpaceChar(b))
			;
		return b;
	}

	private static double nd() {
		return Double.parseDouble(ns());
	}

	private static char nc() {
		return (char) skip();
	}

	private static String ns() {
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while (!(isSpaceChar(b))) {
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}

	private static char[] ns(int n) {
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while (p < n && !(isSpaceChar(b))) {
			buf[p++] = (char) b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}

	private static char[][] nm(int n, int m) {
		char[][] map = new char[n][];
		for (int i = 0; i < n; i++)
			map[i] = ns(m);
		return map;
	}

	private static int[] na(int n) {
		int[] a = new int[n];
		for (int i = 0; i < n; i++)
			a[i] = ni();
		return a;
	}

	private static int ni() {
		int num = 0, b;
		boolean minus = false;
		while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))
			;
		if (b == '-') {
			minus = true;
			b = readByte();
		}

		while (true) {
			if (b >= '0' && b <= '9') {
				num = num * 10 + (b - '0');
			} else {
				return minus ? -num : num;
			}
			b = readByte();
		}
	}

	private static long nl() {
		long num = 0;
		int b;
		boolean minus = false;
		while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))
			;
		if (b == '-') {
			minus = true;
			b = readByte();
		}

		while (true) {
			if (b >= '0' && b <= '9') {
				num = num * 10 + (b - '0');
			} else {
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
}"
89,"import java.io.*;
import java.util.*;


public class Main {

	private static Scanner sc;
	private static Printer pr;

	private static void solve() {
		int n = sc.nextInt();

		int[] d = new int[n];
		for (int i = 0; i < n; i++) {
			d[i] = sc.nextInt();
		}

		if (n + 1 > 24) {
			pr.println(0);
			return;
		}

		int[] t1 = new int[n + 1];
		int[] t2 = new int[n + 1];
		t1[0] = 0;
		t2[0] = 24;
		for (int i = 0; i < n; i++) {
			t1[i + 1] = d[i];
			t2[i + 1] = 24 - d[i];
		}

		int ans = 0;
		out:
		for (int i = 0; i < 0x1 << n + 1; i++) {
			boolean[] used = new boolean[25];
			int[] t = new int[n + 1];
			for (int j = 0; j <= n; j++) {
				if ((i & 0x1 << j) == 0) {
					t[j] = t1[j];
				} else {
					t[j] = t2[j];
				}
				if (used[t[j]]) {
					continue out;
				} else {
					used[t[j]] = true;
				}
			}

			int min = Integer.MAX_VALUE;
			for (int ii = 0; ii <= n; ii++) {
				for (int jj = ii + 1; jj <= n; jj++) {
					min = Math.min(min, d(t[ii], t[jj]));
				}
			}

			ans = Math.max(ans, min);
		}

		pr.println(ans);
	}

	private static int d(int t1, int t2) {
		if (t1 > t2) {
			int tmp = t2;
			t2 = t1;
			t1 = tmp;
		}

		return Math.min(t2 - t1, 24 - (t2 - t1));
	}

	// ---------------------------------------------------
	public static void main(String[] args) {
		sc = new Scanner(System.in);
		pr = new Printer(System.out);

		solve();

		pr.close();
		sc.close();
	}

	@SuppressWarnings(""unused"")
	private static class Scanner {
		BufferedReader br;

		Scanner (InputStream in) {
			br = new BufferedReader(new InputStreamReader(in));
		}

		private boolean isPrintable(int ch) {
			return ch >= '!' && ch <= '~';
		}

		private boolean isCRLF(int ch) {
			return ch == '\n' || ch == '\r' || ch == -1;
		}

		private int nextPrintable() {
			try {
				int ch;
				while (!isPrintable(ch = br.read())) {
					if (ch == -1) {
						throw new NoSuchElementException();
					}
				}

				return ch;
			} catch (IOException e) {
				throw new NoSuchElementException();
			}
		}

		String next() {
			try {
				int ch = nextPrintable();
				StringBuilder sb = new StringBuilder();
				do {
					sb.appendCodePoint(ch);
				} while (isPrintable(ch = br.read()));

				return sb.toString();
			} catch (IOException e) {
				throw new NoSuchElementException();
			}
		}

		int nextInt() {
			try {
				// parseInt from Integer.parseInt()
				boolean negative = false;
				int res = 0;
				int limit = -Integer.MAX_VALUE;
				int radix = 10;

				int fc = nextPrintable();
				if (fc < '0') {
					if (fc == '-') {
						negative = true;
						limit = Integer.MIN_VALUE;
					} else if (fc != '+') {
						throw new NumberFormatException();
					}
					fc = br.read();
				}
				int multmin = limit / radix;

				int ch = fc;
				do {
					int digit = ch - '0';
					if (digit < 0 || digit >= radix) {
						throw new NumberFormatException();
					}
					if (res < multmin) {
						throw new NumberFormatException();
					}
					res *= radix;
					if (res < limit + digit) {
						throw new NumberFormatException();
					}
					res -= digit;

				} while (isPrintable(ch = br.read()));

				return negative ? res : -res;
			} catch (IOException e) {
				throw new NoSuchElementException();
			}
		}

		long nextLong() {
			try {
				// parseLong from Long.parseLong()
				boolean negative = false;
				long res = 0;
				long limit = -Long.MAX_VALUE;
				int radix = 10;

				int fc = nextPrintable();
				if (fc < '0') {
					if (fc == '-') {
						negative = true;
						limit = Long.MIN_VALUE;
					} else if (fc != '+') {
						throw new NumberFormatException();
					}
					fc = br.read();
				}
				long multmin = limit / radix;

				int ch = fc;
				do {
					int digit = ch - '0';
					if (digit < 0 || digit >= radix) {
						throw new NumberFormatException();
					}
					if (res < multmin) {
						throw new NumberFormatException();
					}
					res *= radix;
					if (res < limit + digit) {
						throw new NumberFormatException();
					}
					res -= digit;

				} while (isPrintable(ch = br.read()));

				return negative ? res : -res;
			} catch (IOException e) {
				throw new NoSuchElementException();
			}
		}

		float nextFloat() {
			return Float.parseFloat(next());
		}

		double nextDouble() {
			return Double.parseDouble(next());
		}

		String nextLine() {
			try {
				int ch;
				while (isCRLF(ch = br.read())) {
					if (ch == -1) {
						throw new NoSuchElementException();
					}
				}
				StringBuilder sb = new StringBuilder();
				do {
					sb.appendCodePoint(ch);
				} while (!isCRLF(ch = br.read()));

				return sb.toString();
			} catch (IOException e) {
				throw new NoSuchElementException();
			}
		}

		void close() {
			try {
				br.close();
			} catch (IOException e) {
//				throw new NoSuchElementException();
			}
		}
	}

	private static class Printer extends PrintWriter {
		Printer(PrintStream out) {
			super(out);
		}
	}
}
"
90,"import java.util.Scanner;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Collections;

class Main{
    public static void main(String[] args){
	Scanner sc = new Scanner(System.in);
	int N = sc.nextInt();
	int K = sc.nextInt();
	int[] V = new int[N];
	for(int i = 0; i < N; i++){
	    V[i] = sc.nextInt();
	}

       
	// 左右それぞれ何個ずつ取るかをきめる
	// left + right + remove
	int max = 0;
	for(int left = 0; left <= N; left++){
	    for(int right = 0; right <= N; right++){
		if(left + right > Math.min(N, K)) break;
		int remove = K - right - left;

		// 実際に取りましょう
		ArrayList<Integer> score = new ArrayList<Integer>();
		for(int i = 0; i < left; i++) score.add(V[i]);
		for(int i = 0; i < right; i++) score.add(V[N - 1 - i]);
		
		// ソートします
		Collections.sort(score);

		// 負の数を除きながら総和を取る
		int sum = 0;
		int k = 0;
		for(int x : score){
		    if(x < 0 && k < remove){
			k++;
		    }
		    else{
			sum += x;
		    }
		}
		max = Math.max(max, sum);
							 
		
	    }
	}
	System.out.println(max);
    }
}
"
91,"import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		int a = scanner.nextInt();
		int b = scanner.nextInt();
		System.out.println((a-1)*(b-1));
	}
}"
92,"import java.awt.print.Printable;
import java.util.Scanner;
import javax.sound.midi.SysexMessage;
import java.util.Arrays;
  
public class Main{      
    public static void main(String[] args){

        Scanner sc = new Scanner(System.in);

        int count = sc.nextInt();
        String dict[]=new String[1000000];
        for(int i=0;i<count;i++){
            String str = sc.next();
            if(str.equals(""insert""))
                dict[i]=sc.next();
            else{
                if(Arrays.asList(dict).contains(sc.next()))
                    System.out.println(""yes"");
                else
                    System.out.println(""no"");
            }
            
        }
        sc.close();
        
    }   
}
"
93,"// serval
// srrva
// rrrv
// rrr

import java.util.*;

public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    String S = sc.next();
    Map<Character, List<Integer>> map = new HashMap<>();
    for (int i = 0; i < S.length(); i++) {
      char c = S.charAt(i);
      List<Integer> list = map.get(c);
      if (list == null) {
        list = new ArrayList();
        map.put(c, list);
      }
      list.add(i);
    }
    
    int ans = 1000;
    for (List<Integer> list : map.values()) {
      int diffMax = 0;
      int prev = -1;
      for (int idx : list) {
        int diff = prev == -1 ? idx : idx-prev-1;
        diffMax = Math.max(diffMax, diff);
        prev = idx;
      }
      diffMax = Math.max(diffMax, S.length()-list.get(list.length()-1));
      ans = Math.min(ans, diffMax);
    }
    System.out.println(ans);
  }
}"
94,"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.IOException;
import java.util.InputMismatchException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskD solver = new TaskD();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskD {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int n = in.nextInt();
            int m = in.nextInt();

            int[][] d = in.nextIntArrayArray(m, m);
            int[][] c = in.nextIntArrayArray0indexed(n, n);

            long ans = Long.MAX_VALUE;
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < m; j++) {
                    for (int k = 0; k < m; k++) {
                        if (i == j || j == k || k == i) continue;

                        int[] a = {i, j, k};
                        long tmp = 0;
                        for (int l = 0; l < n; l++) {
                            for (int o = 0; o < n; o++) {
                                tmp += d[c[l][o]][a[(l + o) % 3]];
                            }
                        }

                        ans = Math.min(ans, tmp);
                    }
                }
            }

            out.println(ans);
        }

    }

    static class InputReader {
        BufferedReader br;
        StringTokenizer st;

        public InputReader(InputStream inputStream) {
            br = new BufferedReader(new InputStreamReader(inputStream));
            st = new StringTokenizer("""");
        }

        public String nextString() {
            while (!st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(br.readLine(), "" "");
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
            }
            return st.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(nextString());
        }

        public int[] nextIntArray(int n) {
            int[] res = new int[n];
            for (int i = 0; i < n; i++) {
                res[i] = nextInt();
            }
            return res;
        }

        public int[] nextIntArray0indexed(int n) {
            int[] res = new int[n];
            for (int i = 0; i < n; i++) {
                res[i] = nextInt() - 1;
            }
            return res;
        }

        public int[][] nextIntArrayArray(int n, int m) {
            int[][] res = new int[n][m];
            for (int i = 0; i < n; i++) {
                res[i] = nextIntArray(m);
            }
            return res;
        }

        public int[][] nextIntArrayArray0indexed(int n, int m) {
            int[][] res = new int[n][m];
            for (int i = 0; i < n; i++) {
                res[i] = nextIntArray0indexed(m);
            }
            return res;
        }

    }
}

"
95,"import java.util.Scanner;
//なんかよくわからないやつ
public class Main {
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
      //入力のやつ
		int X = sc.nextInt();
      //鉄道運賃
		int Y = sc.nextInt();
      //バス運賃
		System.out.println(X + Y / 2);
      //合計運賃を計算して入力
	}
}"
96,"import java.util.*;
public class Main {
	public static void main(String[] args){
		int a = Integer.getInteger(args[0]) ;
		int b = Integer.getInteger(args[1]) ;
		int x = Integer.getInteger(args[2]) ;
		
		if(x<a){
			System.out.println(""NO"");
		}else{
			if(x>(a+b)){
				System.out.println(""NO"");
			}else{
				System.out.println(""YES"");
			}
		}
	}
}
"
97,"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.util.Random;
import java.util.ArrayList;
import java.io.UncheckedIOException;
import java.util.List;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), """", 1 << 27);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            EAntennasOnTree solver = new EAntennasOnTree();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class EAntennasOnTree {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            Node[] nodes = new Node[n];
            for (int i = 0; i < n; i++) {
                nodes[i] = new Node();
            }
            for (int i = 0; i < n - 1; i++) {
                Node a = nodes[in.readInt()];
                Node b = nodes[in.readInt()];
                a.adj.add(b);
                b.adj.add(a);
            }

            List<Node> leaf = new ArrayList<>(n);
            for (Node node : nodes) {
                if (node.adj.size() == 1) {
                    leaf.add(node);
                }
            }

            int ans = n;
            long time = System.currentTimeMillis();
            RandomWrapper rw = new RandomWrapper();
            while (System.currentTimeMillis() - time < 1500) {
                Node node = leaf.get(rw.nextInt(0, leaf.size() - 1));
                ans = Math.min(ans, dfs(node, null) + 1);
            }
            out.println(ans);
        }

        public int dfs(Node root, Node p) {
            int zero = 0;
            int cnt = 0;
            for (Node node : root.adj) {
                if (node == p) {
                    continue;
                }
                int ans = dfs(node, root);
                if (ans == 0) {
                    zero++;
                } else {
                    cnt += ans;
                }
            }

            if (zero > 0) {
                cnt += zero - 1;
                zero = 1;
            }

            return cnt;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class RandomWrapper {
        private Random random;

        public RandomWrapper() {
            this(new Random());
        }

        public RandomWrapper(Random random) {
            this.random = random;
        }

        public int nextInt(int l, int r) {
            return random.nextInt(r - l + 1) + l;
        }

    }

    static class Node {
        List<Node> adj = new ArrayList<>();

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }
}

"
98,"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Comparator;
import java.util.Scanner;
import java.util.TreeMap;

public class Main {
    private long fac[];
    private long finv[];
    private long inv[];
    private static int MAX_LEN = 1000001;
    private static int MOD = 1000000007;
    public static void main(String[] args) throws Exception {
        Main main = new Main();
        main.COMinit();
        main.solve();
    }

    private long pow(int base, int count, long MOD) {
        if (count == 0) {
            return 1;
        }
        if (count % 2 == 1) {
            long t = ((long) base) * pow(base, count - 1, MOD);
            t %= MOD;
            return t;
        }
        long t = pow(base, count / 2, MOD);
        t %= MOD;
        t *= t;
        t %= MOD;
        return t;
    }
    public void solve() throws Exception {
        Scanner scan = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int K = scan.nextInt();
        String S = scan.next();
        int N = S.length();
        long ans = 0;
        for (int i = 0; i <= K; i++) {
            long t1 = COM(i + N - 1, i);
            t1 %= MOD;
            long t2 = pow(25, i, MOD);
            t2 %= MOD;
            long t3 = pow(26, K - i, MOD);
            long t = t1 * t2;
            t %= MOD;
            t *= t3;
            t %= MOD;
            ans += t;
            ans %= MOD;
        }
        System.out.println(ans);
    }
    void COMinit() {
        this.fac = new long[MAX_LEN];
        this.finv = new long[MAX_LEN];
        this.inv = new long[MAX_LEN];
        this.fac[0] = this.fac[1] = 1;
        this.finv[0] = this.finv[1] = 1;
        this.inv[1] = 1;
        for (int i = 2; i < MAX_LEN; i++) {
            fac[i] = fac[i-1] * i % MOD;
            inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;
            finv[i] = finv[i-1] * inv[i] % MOD;
        }
    }
    long COM(int n, int k) {
        if (n < k) {
            return 0;
        };
        if (n <0 || k < 0) {
            return 0;
        }
        return fac[n] * (finv[k] * finv[n - k]%MOD)%MOD;
    }
}
"
99,"import java.util.*;
import java.io.*;
import static java.util.Arrays.*;
import static java.util.Collections.*;
import static java.lang.Math.*;


import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		// TODO ?????????????????????????????????????????????
        int n,i,j,k,l,m,o;
        Scanner scan=new Scanner(System.in);
        n=scan.nextInt();
        String s,z;
        s=""insert"";
        String a[]=new String [2*n+2];
        String b[]=new String [n+1];
        String c[]=new String [n+1];
        String d[]=new String [n+1];
        j=0;
        k=0;
        o=0;
        for(i=0;i<2*n;i++)
        {
        	a[i]=scan.next();
        }
        for(i=0;i<2*n;i=i+2)
        {
        	d[o]=a[i]+a[i+1];
        	o++;
        }
        for(i=0;i<n;i++)
        {
        	m=0;
        	z=d[i];
        	if(z.startsWith(s))
        	{
        		b[j]=d[i].substring(6);
        		j++;
        	}
        	else
        	{
        		c[k]=d[i].substring(4);
        		for(l=0;l<j;l++)
        		{
        			if(c[k].equals(b[l]))
        			{
        				m=1;
        			}
        		}
        		if(m==1)
        		{
        			System.out.println(""yes"");
        			k++;
        		}
        		else
        		{
        			System.out.println(""no"");
        			k++;
        		}
        	}
        }
       
        
        
	}

}"
100,"import java.util.HashMap;
import java.util.Scanner;

public class Main {

    public static final int MOD = 1000000007;

    public static int cnt = Integer.MAX_VALUE;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int h = Integer.parseInt(sc.next());
        int w = Integer.parseInt(sc.next());
        int m = Integer.parseInt(sc.next());
        var hm = new HashMap<Integer, Integer>();
        var wm = new HashMap<Integer, Integer>();
        var hw = new boolean[h][w];
        for (int i = 0; i < h; i++) {
            hm.put(i, 0);
        }
        for (int i = 0; i < w; i++) {
            wm.put(i, 0);
        }
        for (int i = 0; i < m; i++) {
            int hh = Integer.parseInt(sc.next());
            int ww = Integer.parseInt(sc.next());
            hm.merge(hh - 1, 1, Integer::sum);
            wm.merge(ww - 1, 1, Integer::sum);
            hw[hh - 1][ww - 1] = true;
        }
        int ans = 0;
        for (int i = 0; i < h; i++) {
            for (int j = 0; j < w; j++) {
                int num = hm.get(i) + wm.get(j);
                if (hw[i][j]) {
                    num--;
                }
                ans = Math.max(ans, num);
            }
        }
        System.out.println(ans);
    }
}"
