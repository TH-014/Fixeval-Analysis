case_no,code_token
1,"import java.util.Scanner;

/**
 *
 * @author mustafa
 */
public class Main {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        Scanner sc = new Scanner(System.in);
        
        String s = sc.nextLine();
        
        long sayac = 1;
        
        for (int i = 0; i < s.length() - 1; ++i)
        {
            for (int j = i + 1; j < s.length(); ++j)
            {
                if (s.charAt(i) == s.charAt(j))
                    continue;
                else
                    sayac++;
            }
        }
        
        System.out.println(sayac);
    }
    
}
"
2,"import java.util.*;
import java.io.*;
import static java.lang.Math.*;

public class Main {
    public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(System.in);
		
		// 入力
		String s = sc.next();
		
		// 計算
		String result = ""YES"";
		boolean flg = true;
		while(flg){
		    if(s.length()-5 >= 0){
		        String t = s.substring(s.length()-5, s.length());
		        if(t.equals(""dream"") || t.equals(""erase"")){
		            s = s.substring(0, s.length()-5);
		            continue;
		        }
		    }
		    if(s.length()-6 >= 0){
		        String t = s.substring(s.length()-6, s.length());
		        if(t.equals(""eraser"")){
		            s = s.substring(0, s.length()-6);
		            continue;
		        }
		    }
		    if(s.length()-7 >= 0){
		        String t = s.substring(s.length()-7, s.length());
		        if(t.equals(""dreamer"")){
		            s = s.substring(0, s.length()-7);
		            continue;
		        }
		    }
		    flg = false;
		    if(!s.equals("""")) result = ""NO"";
		}
		
		// 出力
		System.out.println(result);
	}

	public static class Scanner {
		private BufferedReader br; private StringTokenizer tok;
		public Scanner(InputStream is) throws IOException { br = new BufferedReader(new InputStreamReader(is));}
		private void getLine() throws IOException { while(!hasNext()) tok = new StringTokenizer(br.readLine());}
		private boolean hasNext() { return tok != null && tok.hasMoreTokens();}
		public String next() throws IOException { getLine(); return tok.nextToken();}
		public int nextInt() throws IOException { return Integer.parseInt(next());}
		public long nextLong() throws IOException { return Long.parseLong(next());}
		public double nextDouble() throws IOException { return Double.parseDouble(next());}
	}
}
"
3,"import java.util.Scanner;

public class Main{
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);

        String input = ""hooray!"";
        HeapQ prior = new HeapQ();

        while(!(input.equals(""end""))){
            input = in.next();

            if(input.startsWith(""i"")){
                input = in.next();
                prior.givePriority(Integer.parseInt(input));
                prior.heapifyTD();
            }

            else if(input.equals(""extract"")){
                System.out.printf(""%d\n"",prior.extract());
                prior.heapifyBU();
            }

        }
        in.close();

    }
}

class HeapQ {

    private int[] queue;
    private int size;


    HeapQ() {
        this.queue = new int[2000001];
        this.size = 0;
    }

    public void givePriority(int toIns){
        this.queue[size + 1] = toIns;
        this.size++;
    }

    public void heapifyBU() {
        for (int  i = this.size/2; i >= 1; i--) {
            int k = i;
            int v = this.queue[k];
            boolean heap = false;

            while (!heap && ( (2 * k) <= this.size) ) {
                int j = 2 * k;

                if(j < this.size){
                    if(queue[j] < queue[j + 1]){
                        j = j + 1;
                    }
                }
                if(v >= queue[j]){
                    heap = true;
                }
                else{
                    queue[k] = queue[j];
                    k = j;
                }
            }
            queue[k] = v;

        }


    }

    void heapifyTD() {
        for(int i = this.size; i > 1; i /=2){
            int father = queue[i/2];

            if(queue[i] > father ){
                int aux = father;
                queue[i/2] = queue[i];
                queue[i] = aux;
            }
            else{
                break;
            }
        }
    }

    public int extract(){
        int something = this.queue[1];
        queue[1] = queue[this.size];
        this.size--;
        heapifyBU();

        return something;
    }
}
"
4,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.StringTokenizer;

public class Main {

	static class FastReader
	{
		BufferedReader br;
		StringTokenizer st;

		public FastReader()
		{
			br = new BufferedReader(new
					InputStreamReader(System.in));
		}

		String next()
		{
			while (st == null || !st.hasMoreElements())
			{
				try
				{
					st = new StringTokenizer(br.readLine());
				}
				catch (IOException  e)
				{
					e.printStackTrace();
				}
			}
			return st.nextToken();
		}

		int nextInt()
		{
			return Integer.parseInt(next());
		}

		long nextLong()
		{
			return Long.parseLong(next());
		}

		double nextDouble()
		{
			return Double.parseDouble(next());
		}

		String nextLine()
		{
			String str = """";
			try
			{
				str = br.readLine();
			}
			catch (IOException e)
			{
				e.printStackTrace();
			}
			return str;
		}
	}
	public static String str1, str2; 
	public static String[][] memo; 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		FastReader sc = new FastReader();
		str1 = sc.next(); str2 = sc.next(); 
		memo = new String[str1.length()+10][str2.length()+10];
		a = new ArrayList<String>(); 
		System.out.println(rc(str1.length(), str2.length()).length()==0 ? "" "" : rc(str1.length(), str2.length())); 
	}
	public static ArrayList<String> a; 
	public static String rc(int index1, int index2) {
//		System.out.println(index1 +"" ""+index2);
		if (memo[index1][index2]!=null) {
			return memo[index1][index2]; 
		}
		else if (index1==0 || index2==0) {
			return memo[index1][index2]= """"; 
		}
		
		else if (str1.charAt(index1-1)==str2.charAt(index2-1)) {
			return memo[index1][index2] = rc(index1-1, index2-1) + str1.charAt(index1-1); 
		}

		return memo[index1][index2] = rc(index1-1, index2).length()> rc(index1, index2-1).length() ? 
				rc(index1-1, index2) : rc(index1, index2-1)	;

	}

}
"
5,"import java.util.*;
import java.io.IOException;
import java.io.InputStream;

class FastScanner {
    private final InputStream in = System.in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }

    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}
    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}
    public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}

    public String next() {
        if (!hasNext()) throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    public long nextLong() {
        if (!hasNext()) throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while(true){
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }

    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }

    public double nextDouble() { return Double.parseDouble(next());}
}

public class Main {

    static class Edge {
        int from, to;

        public Edge(int from, int to) {
            this.from = from;
            this.to = to;
        }
    }

    static class Pair {
        int h, w;

        public Pair(int h, int w) {
            this.h = h;
            this.w = w;
        }
    }

    static void bfs() {
        visited = new boolean[H][W];
        visited[0][0] = true;
        prev = new Pair[H][W];
        prev[0][0] = new Pair(-1, -1);

        Deque<Pair> que = new ArrayDeque<>();
        que.offer(new Pair(0, 0));

        while (!que.isEmpty()) {
            Pair pair = que.poll();
            int ch = pair.h;
            int cw = pair.w;
            visited[ch][cw] = true;
            if (ch == H-1 && cw == W-1) break;
            for (int dir = 0; dir < 4; ++dir) {
                int nh = ch + dy[dir];
                int nw = cw + dx[dir];

                if (nh < 0 || nh >= H || nw < 0 || nw >= W) continue;
                if (grid[nh][nw] == '#') continue;
                if (visited[nh][nw]) continue;

                prev[nh][nw] = pair;
                que.offer(new Pair(nh, nw));
            }
        }
    }

    static int H;
    static int W;
    static int res = 1;
    static List<List<Edge>> graph;
    static boolean[][] visited;
    static char[][] grid;
    static Pair[][] prev;
    static int[] dx = {-1, 1, 0, 0};
    static int[] dy = {0, 0, -1, 1};

    public static void main(String[] args) {
        FastScanner fs = new FastScanner();
        H = fs.nextInt();
        W = fs.nextInt();
        grid = new char[H][W];
        for (int i = 0; i < H; ++i) grid[i] = fs.next().toCharArray();
        int black = 0;
        for (int i = 0; i < H; ++i) {
            for (int j = 0; j < W; ++j) {
                if (grid[i][j] == '#') ++black;
            }
        }

        bfs();

        if (visited[H-1][W-1]) {
            int h = H - 1;
            int w = W - 1;
            while (true) {
                Pair pair = prev[h][w];
                if (pair.h == -1 && pair.w == -1) break;
                else ++res;
                h = pair.h;
                w = pair.w;
            }
//            System.out.println(res);
            System.out.println((H * W - black - res));
        }
        else
            System.out.println(-1);
    }
}"
6,"import java.util.*;

public class Main {
    public static void main(String[] args) throws Exception {
        // Your code here!
        Scanner sc = new Scanner(System.in);
        String str = sc.next();
        int n = str.length();
        int k = sc.nextInt() - 1;
        
        Set<String> set = new HashSet<String>();
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= n - i; j++) {
                set.add(str.substring(j, j + i));
            }
        }
        
        List<String> list = new ArrayList<String>(set);
        list.sort(Comparator.naturalOrder());
        System.out.println(list.get(k));
    }
}
"
7,"import java.util.Scanner;

public class Main {
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		
        int i;
        double avr=0, ans=0;
        int[] num;
        
		while(true){

        int n = sc.nextInt();
        num=new int[n];
        
		if(n==0){
			System.exit(0);
		}

    	for(i=0;i<num.length;i++){
        num[i] = sc.nextInt();
        avr+=num[i];
    	}
    	avr = avr/num.length;
        for(i=0;i<num.length;i++){
            ans=ans+(num[i]-avr)*(num[i]-avr);
        }
        System.out.printf(Math.sqrt(ans/num.length));
		}
	}
}"
8,"import java.util.*;
public class Main.java {

	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		int a=sc.nextInt();
		System.out.println(a+(a*a)+(a*a*a));
	}

}
"
9,"import java.util.Scanner;
public class Main{
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		// 入力

        System.out.print(s);
		// 判定
		if(s.equals(""ARC"")){
			System.out.print(""ABC"");
  		}else{
			System.out.print(""ARC"");
		}
	}
}
"
10,"
import java.io.*;
import java.util.ArrayList;
import java.util.Arrays;


public class Main  {

    private static long[] sumA;
    private static long[] sumB;


    private static int max = 0;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        String[] temp = br.readLine().split("" "");
        int a = Integer.parseInt(temp[0]);
        int b = Integer.parseInt(temp[1]);
        int time = Integer.parseInt(temp[2]);

        sumA = new long[a+1];
        sumB = new long[b+1];



        temp = br.readLine().split("" "");
        for(int i=1;i<=a;i++){
            sumA[i] = sumA[i-1] + Long.parseLong(temp[i-1]);

        }

        temp = br.readLine().split("" "");
        for(int i=1; i<=b;i++){
            sumB[i] = sumB[i-1] + Long.parseLong(temp[i-1]);
        }


        for(int i=0;i<=a;i++){

            int j = 0;
            if(sumA[i] > time)break;

            while(sumA[i] + sumB[j] <= time){
                j++;
                if(j > b)break;
            }
            j--;
            max = Math.max(max, i+j);

        }
        System.out.println(max);

    }


}

"
11,"
import java.util.LinkedList;
import java.util.Scanner;


class Search {


	int N;
	int M;
	int[][] root;
	LinkedList<Integer> path = new LinkedList<Integer>();

	void set(Scanner scan){

		N=scan.nextInt();
		M=scan.nextInt();

		root = new int[N][N];

		for(int i=0;i<M;i++){
			int a=scan.nextInt()-1;
			int b=scan.nextInt()-1;

			root[a][b]=1;
			root[b][a]=1;

			if(i==0){
				path.offer(a);
				path.offer(b);
			}

		}
	}

	boolean Fcheck(){
		int F = path.peek();
		for(int i=0;i<N;i++){
			if(root[F][i]==1){//先頭と繋がれた場所
				if(!path.contains(i)){
					path.addFirst(i);

					return true;
				}
			}
		}
		//すべて含まれている
		return false;
	}

	boolean Echeck(){
		int E = path.getLast();
		for(int i=0;i<N;i++){
			if(root[E][i]==1){//最後と繋がれた場所
				if(!path.contains(i)){
					path.addLast(i);
					return true;
				}
			}
		}

		//すべて含まれている
		return false;
	}


}


public class Main {

	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ

		Scanner scan = new Scanner(System.in);


		Search search = new Search();
		search.set(scan);
		while(search.Fcheck());
		while(search.Echeck());

		System.out.println(search.path.size());
		for(int i=0;i<search.path.size();i++){
			System.out.print(search.path.get(i)+1+"" "");
		}
		System.out.println("""");







	}

}
"
12,"import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.Closeable;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.BitSet;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Queue;

public class Main {
	static ContestScanner in;static Writer out;
	public static void main(String[] args)
	{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();
	in.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}
	void solve() throws NumberFormatException, IOException{
		final int n = in.nextInt();
		final int m = in.nextInt();
		List<Edge>[] node = new List[n];
		Pair[] vs = new Pair[n];
		for(short i=0; i<n; i++){
			vs[i] = new Pair(0, i);
			node[i] = new ArrayList<>();
		}
		short a, b, s, t;
		int c;
		for(int i=0; i<m; i++){
			a = (short)(in.nextInt()-1);
			b = (short)(in.nextInt()-1);
			c = in.nextInt();
			Edge ea = new Edge(b, c);
			Edge eb = new Edge(a, c);
			ea.rev = eb;
			eb.rev = ea;
			node[a].add(ea);
			node[b].add(eb);
		}
		mst = Prim.getMst(node);
		final long cost = Prim.cost;
		final int q = in.nextInt();
		long[] st = new long[q];
		final long mask = (1L<<30)-1;
		for(int i=0; i<q; i++){
			s = (short)(in.nextInt()-1);
			t = (short)(in.nextInt()-1);
			st[i] = (long)s<<30 | t;
			vs[s].a++;
			vs[t].a++;
		}
		int[][] query = new int[n][];
		for(int i=0; i<n; i++){
			query[i] = new int[vs[i].a];
			vs[i].a = 0;
		}
		for(int i=0; i<q; i++){
			s = (short)(st[i]>>30);
			t = (short)(st[i]&mask);
			query[s][vs[s].a++] = i;
			query[t][vs[t].a++] = i;
		}
		short[] table = new short[n];
		Arrays.sort(vs);
		for(short i=0; i<n; i++){
			table[vs[i].b] = i;
		}
		best = new int[n];
		BitSet used = new BitSet(q);
		for(int i=n-1; i>=0; i--){
			s = vs[i].b;
			if(vs[i].a == 0) continue;
			dfs(s, (short)-1, 0);
			for(int qid: query[s]){
				if(used.get(qid)) continue;
				used.set(qid);
				t = (short)((st[qid]&mask)==s ? st[qid]>>30 : st[qid]&mask);
				vs[table[t]].a--;
				st[qid] = cost-best[t];
			}
		}
		for(int i=0; i<q; i++){
			out.println(st[i]);
		}
	}
	
	int[] best;
	List<Edge>[] mst;
	void dfs(short cur, short par, int max){
		best[cur] = max;
		for(Edge e: mst[cur]){
			if(e.to == par) continue;
			dfs(e.to, cur, Math.max(max, e.c));
		}
	}
}

class Prim{
	static long cost;
	static List<Edge>[] getMst(List<Edge>[] node){
		final int n = node.length;
		Queue<Edge> qu = new PriorityQueue<>();
		List<Edge>[] res = new List[n];
		for(int i=0; i<n; i++) res[i] = new ArrayList<>();
		for(Edge e: node[0]) qu.add(e);
		boolean[] used = new boolean[n];
		used[0] = true;
		cost = 0;
		while(!qu.isEmpty()){
			Edge e = qu.poll();
			if(used[e.to]) continue;
			used[e.to] = true;
			final int from = e.rev.to;
			res[from].add(e);
			res[e.to].add(e.rev);
			cost += e.c;
			for(Edge ne: node[e.to]){
				qu.add(ne);
			}
		}
		return res;
	}
}

class Edge implements Comparable<Edge>{
	short to;
	int c;
	Edge rev;
	Edge(short to, int c){
		this.to = to;
		this.c = c;
	}
	@Override
	public int compareTo(Edge o) {
		return Integer.compare(c, o.c);
	}
}

class Pair implements Comparable<Pair>{
	int a; short b;final int hash;Pair(int a,short b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}
	public boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}
	public int hashCode(){return hash;}
	public int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}
}
class Writer extends PrintWriter{
	public Writer(String filename)throws IOException
	{super(new BufferedWriter(new FileWriter(filename)));}
	public Writer()throws IOException{super(System.out);}
}
class ContestScanner implements Closeable{
	private BufferedReader in;private int c=-2;
	public ContestScanner()throws IOException 
	{in=new BufferedReader(new InputStreamReader(System.in));}
	public ContestScanner(String filename)throws IOException
	{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}
	public String nextToken()throws IOException {
		StringBuilder sb=new StringBuilder();
		while((c=in.read())!=-1&&Character.isWhitespace(c));
		while(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}
		return sb.toString();
	}
	public String readLine()throws IOException{
		StringBuilder sb=new StringBuilder();if(c==-2)c=in.read();
		while(c!=-1&&c!='\n'&&c!='\r'){sb.append((char)c);c=in.read();}
		return sb.toString();
	}
	public long nextLong()throws IOException,NumberFormatException
	{return Long.parseLong(nextToken());}
	public int nextInt()throws NumberFormatException,IOException
	{return(int)nextLong();}
	public double nextDouble()throws NumberFormatException,IOException 
	{return Double.parseDouble(nextToken());}
	public void close() throws IOException {in.close();}
}"
13,"public class Main{
	public static void main(String[] args){
		Scanner sc=new Scanner(System.in);
		System.out.println(0);
		}
		}
"
14,"import java.util.*;
public class Main {
    private static String S;
    private static HashMap<Character, ArrayList<String>> map;
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        S = sc.next();
        map = new HashMap<>();
        ArrayList<String> listD = new ArrayList<>();
        listD.add(""dream"");
        listD.add(""dreamer"");
        ArrayList<String> listE = new ArrayList<>();
        listE.add(""erase"");
        listE.add(""eraser"");
        map.put('d', listD);
        map.put('e', listE);
        while(S.length() >= 5) {
            String tail5 = S.substring(S.length() - 5, S.length());
            if(tail5.equals(""dream"") || tail5.equals(""erase"")) {
                S = S.substring(0, S.length() - 5);
                continue;
            }
            if(S.length() >= 6) {
                String tail6 = S.substring(S.length() - 6, S.length());
                if(tail6.equals(""eraser"")) {
                    S = S.substring(0, S.length() - 6);
                    continue;
                }
            }
            if(S.length() >= 7) {
                String tail6 = S.substring(S.length() - 7, S.length());
                if(tail6.equals(""dreamer"")) {
                    S = S.substring(0, S.length() - 7);
                    continue;
                }
            }
            break;
        }
        if(S.length() == 0) {
            System.out.println(""YES"");
        } else {
            System.out.println(""NO"");
        }
    }
}


"
15,"
import java.util.*;

public class Main {
    long MLT1 = 1009;
    long MLT2 = 1007;
    long MOD1 = 1000000007;
    long MOD2 = 1000000009;
    long PAIR = 261;
//    long MLT1 = 11;
//    long MLT2 = 13L;
//    long MOD1 = 23L;
//    long MOD2 = 31L;
//    long PAIR = 59;

    long[] rh1;
    long[] rh2;
    long[] pow1;
    long[] pow2;
    int n;

    void run() {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        String s = "" "" + sc.next();
        rh1 = new long[n + 1];
        rh2 = new long[n + 1];
        pow1 = new long[n + 1];
        pow2 = new long[n + 1];

        pow1[0] = pow2[0] = 1;

        for (int i = 1; i <= n; i++) {
            rh1[i] = (rh1[i - 1] * MLT1 + (s.charAt(i) - 'a' + 1)) % MOD1;
            rh2[i] = (rh2[i - 1] * MLT2 + (s.charAt(i) - 'a' + 1)) % MOD2;
            pow1[i] = pow1[i - 1] * MLT1 % MOD1;
            pow2[i] = pow2[i - 1] * MLT2 % MOD2;
        }

//        debug(rh1);
//        debug(rh2);

        long ans = 0;
        for (int i = 1; i <= n / 2; i++) {
            TreeMap<Pair, long[]> map = new TreeMap<>();
            for (int j = 0; j <= n - i; j++) {
                long[] g = get(j, j + i);
                Pair p = new Pair(g[0], g[1]);
                long[] set =  map.getOrDefault(p, new long[]{n, 0});
                set[0] = Math.min(set[0], j);
                set[1] = Math.max(set[1], j);
                map.put(p, set);
            }

//            debug(map);

            for (Map.Entry<Pair, long[]> entry : map.entrySet()) {
                if (entry.getValue()[0] != entry.getValue()[1]) {
                    if (entry.getValue()[1] - entry.getValue()[0] >= i) {
                        ans = i;
                    }
                }
            }
        }
        System.out.println(ans);
    }

    long[] get(int l, int r) {
        long t1 = ((rh1[r] - rh1[l] * pow1[r - l]) % MOD1 + MOD1) % MOD1;
        long t2 = ((rh2[r] - rh2[l] * pow2[r - l]) % MOD2 + MOD2) % MOD2;

        return new long[] {t1, t2};
    }

    class Pair implements Comparable<Pair> {
        long s1, s2;
        Pair(long s1, long s2) {
            this.s1 = s1;
            this.s2 = s2;
        }

        @Override
        public int compareTo(Pair o) {
            if (s1 != o.s1) {
                return Long.compare(s1, o.s1);
            }
            return Long.compare(s2, o.s2);
        }

        @Override
        public int hashCode() {
            return Long.hashCode(s1 * PAIR + s2);
        }

        @Override
        public boolean equals(Object obj) {
            if (obj instanceof Pair) {
                Pair o = (Pair) obj;
                return s1 == o.s1 && s2 == o.s2;
            }
            return false;
        }

        @Override
        public String toString() {
            return String.format(""(%d, %d)"", s1, s2);
        }
    }

    void debug(Object... os) {
        System.err.println(Arrays.deepToString(os));
    }

    public static void main(String[] args) {
        new Main().run();
    }

}
"
16,"import java.util.*;

public class Main{
  public static void main(String[] args){
    Scanner sc = new Scanner(System.in);
    double n = sc.nextDouble();
    System.out.println(n%2 == 0 ? 0.5 : (n+1)/(n*2));
  }
}"
17,"import java.util.*;
public class Main {
	public static void main(String[] args) {
    	Scanner sc = new Scanner(System.in);
		String S = sc.next();
		String S1 ="""";
		String S2 ="""";
		String ans="""";
		int cnt1 = 0;
		int cnt2 = 0;
		int i1 = 0;
		int i2 = 0;
		S1=S.substring(0, 2);
		S2=S.substring(2, 4);
		i1 = Integer.parseInt(S1);
		i2 = Integer.parseInt(S2);
		for(int i=1;i<=12;i++){
			if (i1==i) {
				cnt1= cnt1+1;
			}
		}	
		for(int j=1;j<=12;j++){
			if (i2==j) {
				cnt2=cnt2+1;
			}
		}
		if (cnt1==1&&cnt2==1) {
			ans=""AMBIGUOUS"";
			System.out.println(ans);
		}
		if (cnt1==1&&cnt2!=1) {
			ans=""MMYY"";
			System.out.println(ans);
		}
		if (cnt1!=1&&cnt2==1) {
			ans=""YYMM"";
			System.out.println(ans);
		}
		if (cnt1!=1&&cnt2!=1) {
			ans=""NA"";
			System.out.println(ans);
		}
    }
}"
18,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.Arrays;

public class Main {

	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		MyInput in = new MyInput(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskX solver = new TaskX();
		solver.solve(1, in, out);
		out.close();
	}

	static int INF = 1 << 30;
	static long LINF = 1L << 55;
	static int MOD = 1000000007;
	static int[] mh4 = { 0, -1, 1, 0 };
	static int[] mw4 = { -1, 0, 0, 1 };
	static int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };
	static int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };

	static class TaskX {

		public void solve(int testNumber, MyInput in, PrintWriter out) {

			int n = in.nextInt(), m = in.nextInt();

			// i 回目の操作で箱 j に赤いボールが r 個、白いボールが b 個入っている可能性があるかどうか
			boolean[][][][] dp = new boolean[m+1][n][n+1][n+1];
			for (int i = 0; i < n; i++) {
				dp[0][i][i == 0 ? 1 : 0][i != 0 ? 1 : 0] = true;
			}

			for (int i = 0; i < m; i++) {
				int x = in.nextInt()-1, y = in.nextInt()-1;

				// 赤いボールと白いボールがある場合
				boolean done = false;
				for (int r = 1; r <= n; r++) {
					for (int w = 1; w <= n; w++) {
						if (dp[i][x][r][w]) {

							// 赤いボールを渡す場合
							for (int r2 = 0; r2 <= n; r2++) {
								for (int w2 = 0; w2 <= n; w2++) {
									if (dp[i][y][r2][w2]) {
										dp[i+1][y][r2+1][w2] = true;
										dp[i][x][r][w] = false;
										dp[i+1][x][r-1][w] = true;
									}
								}
							}

							// 白いボールを渡す場合
							for (int r2 = 0; r2 <= n; r2++) {
								for (int w2 = 0; w2 <= n; w2++) {
									if (dp[i][y][r2][w2]) {
										dp[i+1][y][r2][w2+1] = true;
										dp[i][x][r][w] = false;
										dp[i+1][x][r][w-1] = true;
									}
								}
							}

							done = true;
						}
					}
				}

				// 赤いボールしかない場合
				if (!done) {
					for (int r = 1; r <= n; r++) {
						if (dp[i][x][r][0]) {

							// 赤いボールを渡す場合
							for (int r2 = 0; r2 <= n; r2++) {
								for (int w2 = 0; w2 <= n; w2++) {
									if (dp[i][y][r2][w2]) {
										dp[i+1][y][r2+1][w2] = true;
										dp[i][x][r][0] = false;
										dp[i+1][x][r-1][0] = true;
									}
								}
							}

							done = true;
						}
					}
				}

				// 白いボールしかない場合
				if (!done) {
					for (int w = 1; w <= n; w++) {
						if (dp[i][x][0][w]) {

							// 白いボールを渡す場合
							for (int r2 = 0; r2 <= n; r2++) {
								for (int w2 = 0; w2 <= n; w2++) {
									if (dp[i][y][r2][w2]) {
										dp[i+1][y][r2][w2+1] = true;
										dp[i][x][0][w] = false;
										dp[i+1][x][0][w-1] = true;
									}
								}
							}
						}
					}
				}

				if (!done) new RuntimeException();

				// 直前の状態のマージ(移動しなかった分)
				for (int j = 0; j < n; j++) {
					if (j == y) continue;
					for (int r = 0; r <= n; r++) {
						for (int w = 0; w <= n; w++) {
							dp[i+1][j][r][w] |= dp[i][j][r][w];
						}
					}
				}
			}

			// m回操作後の最終的な状態で赤いボールが入っている可能性がある箱の数を数える
			int ans = 0;
			for (int i = 0; i < n; i++) {
				boolean ok = false;
				top:
				for (int r = 1; r <= n; r++) {
					for (int w = 0; w <= n; w++) {
						if (dp[m][i][r][w]) {
							ok = true;
							break top;
						}
					}
				}
				if (ok) ans++;
			}
			out.println(ans);
		}
	}

	static class MyInput {
		private final BufferedReader in;
		private static int pos;
		private static int readLen;
		private static final char[] buffer = new char[1024 * 8];
		private static char[] str = new char[500 * 8 * 2];
		private static boolean[] isDigit = new boolean[256];
		private static boolean[] isSpace = new boolean[256];
		private static boolean[] isLineSep = new boolean[256];

		static {
			for (int i = 0; i < 10; i++) {
				isDigit['0' + i] = true;
			}
			isDigit['-'] = true;
			isSpace[' '] = isSpace['\r'] = isSpace['\n'] = isSpace['\t'] = true;
			isLineSep['\r'] = isLineSep['\n'] = true;
		}

		public MyInput(InputStream is) {
			in = new BufferedReader(new InputStreamReader(is));
		}

		public int read() {
			if (pos >= readLen) {
				pos = 0;
				try {
					readLen = in.read(buffer);
				} catch (IOException e) {
					throw new RuntimeException();
				}
				if (readLen <= 0) {
					throw new MyInput.EndOfFileRuntimeException();
				}
			}
			return buffer[pos++];
		}

		public int nextInt() {
			int len = 0;
			str[len++] = nextChar();
			len = reads(len, isSpace);
			int i = 0;
			int ret = 0;
			if (str[0] == '-') {
				i = 1;
			}
			for (; i < len; i++)
				ret = ret * 10 + str[i] - '0';
			if (str[0] == '-') {
				ret = -ret;
			}
			return ret;
		}

		public long nextLong() {
			int len = 0;
			str[len++] = nextChar();
			len = reads(len, isSpace);
			int i = 0;
			long ret = 0;
			if (str[0] == '-') {
				i = 1;
			}
			for (; i < len; i++)
				ret = ret * 10 + str[i] - '0';
			if (str[0] == '-') {
				ret = -ret;
			}
			return ret;
		}

		public char nextChar() {
			while (true) {
				final int c = read();
				if (!isSpace[c]) {
					return (char) c;
				}
			}
		}

		public String nextString() {
			return new String(nextChars());
		}

		public char[] nextChars() {
			int len = 0;
			str[len++] = nextChar();
			len = reads(len, isSpace);
			return Arrays.copyOf(str, len);
		}

		public char[][] next2DChars(int h, int w) {
			char[][] s = new char[h][w];
			for (int i = 0; i < h; i++) {
				s[i] = nextChars();
			}
			return s;
		}

		int reads(int len, boolean[] accept) {
			try {
				while (true) {
					final int c = read();
					if (accept[c]) {
						break;
					}
					if (str.length == len) {
						char[] rep = new char[str.length * 3 / 2];
						System.arraycopy(str, 0, rep, 0, str.length);
						str = rep;
					}
					str[len++] = (char) c;
				}
			} catch (MyInput.EndOfFileRuntimeException e) {
			}
			return len;
		}

		public int[] nextIntArray(final int n) {
			final int[] res = new int[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextInt();
			}
			return res;
		}

		public int[] nextIntArray1Index(final int n) {
			final int[] res = new int[n + 1];
			for (int i = 1; i < n + 1; i++) {
				res[i] = nextInt();
			}
			return res;
		}

		public int[] nextIntArrayDec(final int n) {
			final int[] res = new int[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextInt() - 1;
			}
			return res;
		}

		public long[] nextLongArray(final int n) {
			final long[] res = new long[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextLong();
			}
			return res;
		}

		public long[] nextLongArray1Index(final int n) {
			final long[] res = new long[n + 1];
			for (int i = 1; i < n + 1; i++) {
				res[i] = nextLong();
			}
			return res;
		}

		public long[] nextLongArrayDec(final int n) {
			final long[] res = new long[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextLong() - 1;
			}
			return res;
		}

		public double nextDouble() {
			return Double.parseDouble(nextString());
		}

		public double[] nextDoubleArray(int n) {
			double[] res = new double[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextDouble();
			}
			return res;
		}

		static class EndOfFileRuntimeException extends RuntimeException {
		}

	}

}
"
19,"import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		String S = scan.nextLine();
		
		boolean kai = true;
		
		while (S.length() > 0) {
			
			if (S.endsWith(""dream"")) {
				S =  new String(S.substring(0,S.length() - 5));
			} else if (S.endsWith(""dreamer"")) {
				S = new String(S.substring(0,S.length() - 7));
			} else if (S.endsWith(""erase"")) {
				S = new String(S.substring(0,S.length() - 5));
			} else if (S.endsWith(""eraser"")) {
				S = new String(S.substring(0,S.length() - 6));
			} else {
				kai = false;
				break;
			}
		}
		
		System.gc();
		
		if (kai == true) {
			System.out.println(""YES"");
		} else {
			System.out.println(""NO"");
		}
		 
		 scan.close();

	}
}"
20,"import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

public class Main {

	static PrintWriter out;
	static InputReader ir;
	static boolean debug = false;

	static void solve() {
		char[] a = ir.next().toCharArray();
		int n = a.length;
		int[][][] dp = new int[n + 1][26][2];
		for (int i = 0; i < 26; i++)
			dp[n][i] = new int[] { i, 1 };
		for (int i = n - 1; i >= 0; i--) {
			for (int j = 0; j < 26; j++)
				for (int k = 0; k < 2; k++)
					dp[i][j][k] = dp[i + 1][j][k];
			int cur = a[i] - 'a';
			int mi = 2 * n;
			for (int j = 0; j < 26; j++)
				mi = Math.min(mi, dp[i + 1][j][1]);
			for (int j = 0; j < 26; j++) {
				if (dp[i + 1][j][1] == mi) {
					dp[i][cur] = new int[] { j, dp[i + 1][j][1] + 1 };
					break;
				}
			}
		}
		int mi = 2 * n, cur = -1;
		;
		for (int i = 0; i < 26; i++)
			mi = Math.min(mi, dp[0][i][1]);
		for (int i = 0; i < 26; i++)
			if (dp[0][i][1] == mi) {
				cur = i;
				break;
			}
		tr(dp[0]);
		String ret = Character.toString((char) ('a' + cur));
		for (int i = 0; i < n; i++) {
			if (dp[i][cur][0] == dp[i + 1][cur][0] && dp[i][cur][1] == dp[i + 1][cur][1])
				continue;
			ret += Character.toString((char) ('a' + dp[i][cur][0]));
			cur = dp[i][cur][0];
		}
		out.println(ret);
	}

	public static void main(String[] args) {
		ir = new InputReader(System.in);
		out = new PrintWriter(System.out);
		solve();
		out.flush();
	}

	static class InputReader {

		private InputStream in;
		private byte[] buffer = new byte[1024];
		private int curbuf;
		private int lenbuf;

		public InputReader(InputStream in) {
			this.in = in;
			this.curbuf = this.lenbuf = 0;
		}

		public boolean hasNextByte() {
			if (curbuf >= lenbuf) {
				curbuf = 0;
				try {
					lenbuf = in.read(buffer);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (lenbuf <= 0)
					return false;
			}
			return true;
		}

		private int readByte() {
			if (hasNextByte())
				return buffer[curbuf++];
			else
				return -1;
		}

		private boolean isSpaceChar(int c) {
			return !(c >= 33 && c <= 126);
		}

		private void skip() {
			while (hasNextByte() && isSpaceChar(buffer[curbuf]))
				curbuf++;
		}

		public boolean hasNext() {
			skip();
			return hasNextByte();
		}

		public String next() {
			if (!hasNext())
				throw new NoSuchElementException();
			StringBuilder sb = new StringBuilder();
			int b = readByte();
			while (!isSpaceChar(b)) {
				sb.appendCodePoint(b);
				b = readByte();
			}
			return sb.toString();
		}

		public int nextInt() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			int res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public long nextLong() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			long res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public double nextDouble() {
			return Double.parseDouble(next());
		}

		public int[] nextIntArray(int n) {
			int[] a = new int[n];
			for (int i = 0; i < n; i++)
				a[i] = nextInt();
			return a;
		}

		public long[] nextLongArray(int n) {
			long[] a = new long[n];
			for (int i = 0; i < n; i++)
				a[i] = nextLong();
			return a;
		}

		public char[][] nextCharMap(int n, int m) {
			char[][] map = new char[n][m];
			for (int i = 0; i < n; i++)
				map[i] = next().toCharArray();
			return map;
		}
	}

	static void tr(Object... o) {
		if (debug)
			out.println(Arrays.deepToString(o));
	}
}
"
21,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class HMDivisors {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		int count=0;

		StringTokenizer st1 = new StringTokenizer(br.readLine());
		int a=Integer.parseInt(st1.nextToken());
		int b=Integer.parseInt(st1.nextToken());
		int c=Integer.parseInt(st1.nextToken());
		if(c%a==0){
			count++;
		}
		a++;

		while(a<b){
			if(c%a==0){
				count++;
			}
			a++;
		}

		System.out.println(count);
	}

}

"
22,"package codeFest2017qualC;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.NoSuchElementException;
import java.util.Scanner;

public class Main {
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		FastScanner fs = new FastScanner();
		String s = fs.next();
		sc.close();
		
//		ArrayList<Integer> sa = new ArrayList<Integer>();
//		for(int i=0; i<s.length(); i++){
//			sa.add(s.charAt(i) -97);
//		}
//		
//		int epos = sa.size() -1;
//		int ans = 0;
//		
//		for(int i=0; i<epos; i++){
//			int i1 = sa.get(i);
//			int i2 = sa.get(epos);
//			if(i1 != i2){
//				if(i1 != 23 && i2 != 23){
//					System.out.println(""-1"");
//					return;
//				}else if(i1 == 23){
//					sa.add(epos+1, 23);
//					ans++;
//					epos++;
//				}else if(i2 == 23){
//					sa.add(i, 23);
//					ans++;
//					epos++;
//				}
//			}
//			epos--;
//			if(ans > 100000){
//				System.out.println(""-1"");
//				return;
//			}
//		}
		
		char[] ca = s.toCharArray();
		
		int epos = s.length() -1;
		int ans = 0;
		
		for(int i=0; i<epos; i++){
			int i1 = ca[i] - 97;
			int i2 = ca[epos] - 97;
			if(i1 != i2){
				if(i1 != 23 && i2 != 23){
					System.out.println(""-1"");
					return;
				}else if(i1 == 23){
					ans++;
					epos++;
				}else if(i2 == 23){
					ans++;
					i--;
				}
			}
			epos--;
			if(ans > 100000){
				System.out.println(""-1"");
				return;
			}
		}
		
		System.out.println(ans);
		
//		int[] num = new int[26];
//		for(int i=0; i<s.length(); i++){
//			num[c[i]-97]++;
//		}
//		
//		int knum = 0;
//		int kpos;
//		for(int i=0; i<26; i++){
//			if(c[i] % 2 != 0){
//				knum++;
//				kpos = i;
//			}
//		}
//		
//		if(knum >= 2){
//			System.out.println(""-1"");
//			return;
//		}
//		
//		if(knum == 1){
//			
//		}
	}
}

class FastScanner {
    private final InputStream in = System.in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}
    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}
    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}
    public boolean hasNext() { skipUnprintable(); return hasNextByte();}
    public String next() {
        if (!hasNext()) throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
    public long nextLong() {
        if (!hasNext()) throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while(true){
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
}
"
23,"import java.util.*;
class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        long a = scanner.nextLong();
        long b = scanner.nextLong();
        List<Long> divisor = new ArrayList<>();
        for(long i = 1; i <= Math.min(a,b); i++){
            if(a%i==0 && b%i==0){
                divisor.add(i);
            }
        }
        int s = divisor.size();
        int max = 0;
        for(int i = 0; i < Math.pow(2,s); i++){
            List<Long> one = new ArrayList<>();
            for(int j = 0; j < s; j++){
                if ((1&i>>j) == 1) {
                    long target = divisor.get(j);
                    boolean flag = true;
                    for(int k = 0; k < one.size(); k++){
                        if(gcd(one.get(k), target) != 1){flag = false;}
                    }
                    if(!flag){break;}
                    one.add(target);
                    if(flag && max < one.size()){max = one.size();}
                    
                }
            }
        }
        System.out.println(max);
    }

    public static long gcd(long a, long b){
        if(b == 0){return a;}
        return gcd(b, a%b);
    }
}
"
24,"
import java.util.*;
import static java.lang.Math.*;
import static java.util.Arrays.*;

public class Main {

	int INF = 1 << 28;

	int[][] next = {{1,4},
					{0,2,5},
					{1,3,6},
					{2,7},
					{0,5},
					{1,4,6},
					{2,5,7},
					{3,6}};
	int[] ans = new int[16777216];
	void run() {
		Scanner sc = new Scanner(System.in);
		bfs();
		while(sc.hasNext()) {
			int q = 0;
			int tmp = 1;
			for(int i=0;i<8;i++) {
				q += sc.nextInt() * tmp;
				tmp *= 8;
			}
			System.out.println(ans[q]);
		}
	}
	
	void bfs() {
		boolean[] visited = new boolean[16777216];
		Struct now = new Struct(new int[] {0, 1, 2, 3, 4, 5, 6, 7}, 0);
		LinkedList<Struct> que = new LinkedList<Struct>();
		que.add(now);
		visited[toInt(now.s)] = true;
		for(;!que.isEmpty();) {
			now = que.removeFirst();
			ans[toInt(now.s)] = now.c;
//			System.out.println(toString(now.s));
			int a[] = now.s.clone();
			int zero = 0;
			for(int i=0;i<8;i++) if(a[i] == 0) {
				zero = i; break;
			}
			for(int i=0;i<next[zero].length;i++) {
				int[] b = a.clone();
				int tmp = b[zero];
				b[zero] = b[next[zero][i]];
				b[next[zero][i]] = tmp;
				Struct next_s = new Struct(b, now.c+1);
				int ind = toInt(b);
				if( !visited[ind] ) {
					visited[ind] = true;
					que.addLast(next_s);
				}
			}
		}
	}
	
	int toInt(int[] a) {
		int ret = 0;
		int tmp = 1;
		for(int i=0;i<8;i++) {
			ret += a[i]*tmp;
			tmp *= 8;
		}
		return ret;
	}
	
	public static void main(String[] args) {
		new Main().run();
	}
	
	class Struct {
		int[] s;
		int c;
		int zero;
		Struct(int s[], int c) {
			this.s = s.clone();
			this.c = c;
		}
	}
}"
25,"import java.util.Scanner;
import java.util.Arrays;
import java.util.List;
 
public class Main {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt();
        int count = 0;

        String[] array = new String[n];
        
        String s = scan.nextLine();

        for (int i = 0; i < n; i++) {
            s = scan.nextLine();
            if (Arrays.asList(array).contains(s)) {
                
            }else{count++;}
            array[i] = s;
        }


   


        
        System.out.println(count);
 
        scan.close();
    }
}
"
26,"import java.io.BufferedReader;
import java.io.InputStreamReader;

public class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        double r=Double.parseDouble(reader.readLine());
        Double area=r*r*Math.PI;
        Double circumference=r*2*Math.PI;
        System.out.println(String.format(""%.6f %.6f"", area, circumference));
    }
}"
27,"import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.NoSuchElementException;


public class Main {
	public static void main(String[] args) {
		
		for(int i=0;i<1;i++) {
			
			slover();
			out.flush();
		}
	}
	static FastScanner sc = new FastScanner();
	static PrintWriter out = new PrintWriter(System.out);
	

		



		private static class D{
		
			ArrayList<Integer> X=new ArrayList<Integer>();
			ArrayList<Integer> Y=new ArrayList<Integer>();
			int t=0;
			int index=0;
			D(ArrayList<Integer> X,ArrayList<Integer> Y,int t,int index){
				this.X=X;;
				this.Y=Y;
				this.t=t;
				this.index=index;
			}

		}



	//Set<Long> a=new HashSet<Long>();
	
	
	
	//Integer.toBinaryString(i);
	//Integer.toString(i, 2);
//	//Integer.parseInt(bin, 2);
	//bitset
		//StringBuffer S = new StringBuffer(sc.next());
				//String hoge2 = str.reverse().toString();
				//map.containsKey(A)
				//Map<Integer, Integer> map = new HashMap<Integer, Integer>(N);
				/*for ( キーのデータ型 key : マップの名前.keySet() ) {
					データのデータ型 data = マップの名前.get( key );

					// keyやdataを使った処理;
				}*/
				//int i = Integer.parseInt(s);
				//Queue<String> qq=new ArrayDeque<>(); //add,poll,peek BFSは前から実行される
				//Deque<String> dd=new ArrayDeque<>();//push後ろに入れる,poll(pop)後ろからとる,peek addは先頭に入るからバグ注意
				//stackdfsは後ろから実行される
				//ArrayList<Integer> cc = new ArrayList<>(N);
				//cc.contains(tmp)
				//Arrays.asList(c).contains(""a"")
				//list.set(1,""walk"");//1 1 2 3 5
				//PriorityQueue<Integer> r=new PriorityQueue<Integer>();//add poll
		
		public static class Pair<K, V> extends AbstractMap.SimpleEntry<K, V> implements Comparable<Pair<K, V>> {
			/** serialVersionUID. */
		    private static final long serialVersionUID = 6411527075103472113L;
	 
		    public Pair(final K key, final V value) {
		        super(key, value);
		    }
	 
			@Override
			public int compareTo(Pair<K, V> o) {
	 
				Comparable key = (Comparable)this.getKey();
				Comparable key2 = (Comparable)o.getKey();
	 
				return key.compareTo(key2);
			}
	 
		}
	 
		// 文字列として入力を取得
		
		
		
		
	private static long mod=1000000009;
	private static int INF =999999999;
	private static long LINF=4000000000000000000L;
	
	private static long ncr(long n,long r) {
		long res=1;
		
		for(int i=0;i<r;i++) {
			res*=n-i;
			res/=i+1;
		}
		return res;
	}
	
	private static int slover()   {
		int N=sc.nextInt();
		int A=sc.nextInt()-1,B=sc.nextInt()-1,C=sc.nextInt()-1,D=sc.nextInt()-1;
		String S=sc.next();
		
		if(C>D) {
			//Bの2個前からDの２個後ろまでで...があるか調べればいい
			int x=S.indexOf(""..."",Math.max(B-1, 0));
			//p(x+"" ""+D);
			if(x>=D||x<0) {
				p(""No"");
				return 0;
			}
			int a=S.indexOf(""##"", B);
			int b=S.indexOf(""##"",A);
			if((a<0||a>D)&&(b<0||b>C)) {
				p(""Yes"");
			}else p(""No"");
			
		}else {
			
			//BがDまで行けるか、AがCまで行けるか試せばいい
			//B以降Dまでに##がないか、A以降Cまでに##がないかそれぞれ調べればいい
			int a=S.indexOf(""##"", B);
			int b=S.indexOf(""##"",A);
			if((a<0||a>D)&&(b<0||b>C)) {
				p(""Yes"");
			}else p(""No"");
			
		}
		
		
		
		
		
		
		return 0;
	}
	private static void shape(int Q[]) {
		for(int i=0;i<Q.length;i++) {
			find2(Q,i);
		}
	}
	private static int find2(int Q[],int a) {
		//aの根をbの根にする。
		if(Q[a]==a) {
			return Q[a];
		}else {
			return Q[a]=find2(Q,Q[a]);
		}
		
	}
	private static void union2(int Q[],int a,int b) {
		
		int root1=find2(Q,a);
		int root2=find2(Q,b);
		Q[root1]=Q[root2];
	}
	
	
	private static void set_add(int Q[],int index,int value) {
		if(Q[index]==value) {
			
		}
		else if(Q[index]==INF) {
			Q[index]=value;
			
		}else if(value<Q[index]) {
			set_add(Q,index*2+1,value);
		}else {
			set_add(Q,index*2+2,value);
		}
	}
	
	private static void priority_queue_add(int Queue[],int index,int value) {
		Queue[index]=value;
		
		if(index!=0) {
			if((index-1)/2>=0&&Queue[(index-1)/2]>value) {
				Queue[index]=Queue[(index-1)/2];
				priority_queue_add(Queue,(index-1)/2,value);
				
			}
			if((index-2)/2>=0&&Queue[(index-2)/2]>value) {
				Queue[index]=Queue[(index-2)/2];
				priority_queue_add(Queue,(index-2)/2,value);
				
			}
		}
		
		
	}
private static int priority_queue_getFirst(int[] Queue) {
		int res=Queue[0];
		Queue[0]=Queue[Queue.length-1];
		Queue[Queue.length-1]=INF;
		//System.out.println(Arrays.toString(Queue));
		//大きさのチェック
		Q_shape(Queue,0);
		
		return res;
	}
	private static void Q_shape(int[] Queue,int index) {
			
			
		
			if(index*2+1<Queue.length&&Queue[index*2+1]<Queue[index]) {
				int v=Queue[index];
				Queue[index]=Queue[index*2+1];
				Queue[index*2+1]=v;
				Q_shape(Queue,index*2+1);
				
			}
			if(index*2+2<Queue.length&&Queue[index*2+2]<Queue[index]) {
				int v=Queue[index];
				Queue[index]=Queue[index*2+2];
				Queue[index*2+2]=v;
				Q_shape(Queue,index*2+2);
				
			}
		
		
		
	}
	private static int union_MaxSize(int[] tree) {
		
		union_shape(tree);
		
		int V[]=new int[tree.length+1];
		
		for(int i=0;i<tree.length;i++) {
			V[tree[i]]++;
		}
		int max=0;
		for(int i=0;i<=tree.length;i++) {
			max=Math.max(max, V[i]);
		}
		return max;
	}
	
	public static int find(int[] tree,int idx) {
        if(tree[idx]==idx) return idx;
        else {
        	
        	return tree[idx] = find(tree,tree[idx]);
        }
    }
	public static void union_shape(int[] tree) {
		for(int i=0;i<tree.length;i++) {
			find(tree,i);
		}
	}

    //union idx2 tree to idx1 tree O(a(N))
    public static int[] union(int tree[],int idx1,int idx2) {
        int root1 = find(tree,idx1);
        int root2 = find(tree,idx2);
        tree[root2] = root1;
        return tree;
    }
	private static boolean heihou(long T) {
		if(Math.pow((int)Math.sqrt(T), 2)==T)return true;
		return false;
	}
	private static String zeroume(String S) {
		while(S.length()<6)S='0'+S;
		return S;
	}
	
	//速度が足りないときは、前計算を1回だけにしたり、longをintに変えたりするといい
	private static long modNcR2(int n,int r) {
		long x_b=1;
		
		for(int i=0;i<r;i++) {
			x_b*=(n-i);
			x_b%=mod;
		}
		
		long y=1;
		for(int i=1;i<=r;i++) {
			y*=i;
			y%=mod;
			//nPrにr!%modの逆元を掛ける
		}
		return  (x_b*modPow((int) y,mod-2,mod)%mod);
		
	}
	
	

	
	
	
	private static long modPow(int i,long t,long mod) {
		//iのt乗をO(log t)で返す
		i%=mod;
		t%=mod;
		long a=i;
		long res=1;
		//for(int i=0;i<S.length();i++) {if(S.charAt(N-i)=='1') {res=res*a%mod;}
		//tをStringで受け取りたい時用
		while(t!=0) {
			if((1&t)==1) {
				res=res*a%mod;
			}
			a=a*a%mod;
			t=t>>1;
		}
		return res;
	}
	
	public static long gcd(long num1,long num2) {
        if(num2==0) return num1;
        else return gcd(num2,num1%num2);
    }
	public static long lcm(long num1,long num2) {
		return num1*num2/gcd(num1,num2);
	}
	//O(N^0.5)
	private static boolean isPrime(long t) {
		if(t<2)return false;
		for(int i=2;i*i<=t;i++) {
			if(t%i==0)return false;
		}
		return true;
	}
	private static ArrayList<Long> Divisors(long t) {
		ArrayList<Long> c=new ArrayList<Long>();
		
		for(long i=1;i*i<=t;i++) {
			if(t%i==0) {
				
				if(i*i!=t) {
					c.add(t/i);
				}
				c.add((long)i);
			}
		}
		return c;
	}
	private static ArrayList<Long> Sorted_Divisors(long t) {
		ArrayList<Long> c=new ArrayList<Long>();
		for(long i=2;i*i<=t;i++) {
			
			
			if(t%i==0) {
				p(t+"" ""+i);
				c.add((long)i);
				t/=i;
				i--;
			}
		}
		if(t!=1)c.add(t);
		Collections.sort(c);
		
		return c;
	}
	private static void bubunwa() {
		int N=sc.nextInt();
		int K=sc.nextInt();
		int a[]=sc.nextIntArray(N, false);

		boolean dp[] =new boolean[K+1];

		Arrays.fill(dp, false);
		dp[0]=true;
		for(int i=0;i<N;i++) {
			for(int x=K-a[i];x>=0;x--) {
				if(dp[x])dp[x+a[i]]=true;
			}
		}

		p(dp[K] ? ""Yes"":""No"");
	}
	
	private static String bitToString(int i) {
		return Integer.toBinaryString(i);
	}
/*********************************************************************/
	//target以下までの値のindexを返す
	//target以上が欲しいときは返り値+1すればいい
	//0-indexで個数を求めるときはさらにindex+1する必要あり
	private static int lower_bound(long a[],long target) {
	//p(target+ "" ""+Arrays.toString(a));
	if(a[0]>target)return -1;
	//最後の値がtarget以下であるときは最後のindexを返す。
	//target以上が欲しいときは注意する必要あり
	if(a[a.length-1]<=target) return a.length-1;

	int S=-1;
	int E=a.length;

	while(S<E) {

		int G=(S+E)/2;
		if(G+1==a.length) {
			G--;
		}
		//未満にしたいときは=の場所を変える
		if(a[G]<=target&&a[G+1]>target) {
			return G;

		}else if(a[G]<=target){
			S=G;
		}else if(a[G]>target) {
			E=G;
		}

	}


	return -1;
	}
	static String nextPermutation(String s) {
		ArrayList<Character> list=new ArrayList<Character>();
		for(int i=0;i<s.length();i++) {
			list.add(s.charAt(i));
		}
		int pivotPos=-1;
		char pivot=0;
		for(int i=list.size()-2;i>=0;i--) {
			if(list.get(i)<list.get(i+1)) {
				pivotPos=i;
				pivot=list.get(i);
				break;
			}
		}
		if(pivotPos==-1&&pivot==0) {
			return ""Final"";
		}
		int L=pivotPos+1,R=list.size()-1;



		int minPos=-1;
		char min =Character.MAX_VALUE;

		for(int i=R;i>=L;i--) {
			if(pivot<list.get(i)) {
				if(list.get(i)<min) {
					min=list.get(i);
					minPos=i;
				}
			}
		}

		Collections.swap(list, pivotPos, minPos);
		Collections.sort(list.subList(L, R+1));


		StringBuilder sb=new StringBuilder();
		for(int i=0;i<list.size();i++) {
			sb.append(list.get(i));
		}
		return sb.toString();
	}
private static long[][] com;
private static void nCr() {
	int MAX = 3001;
	com= new long[MAX][MAX];
	for(int i = 0; i < MAX; i++)
	    com[i][0] = 1;
	for(int i = 1; i < MAX; i++) {
	    for(int j = 1; j <= i; j++) {
	        com[i][j] = com[i-1][j-1] + com[i-1][j];
	        com[i][j] %= mod;
	    }
	}
}


	static void p(String ans) {out.println(ans);}
	static void p(int ans) {out.println(ans);}
	static void p() {out.println();}
	static void p(long ans) {out.println(ans);}
	static void p(double ans) {out.println(ans);}
	static void p(boolean ans) {out.println(ans);}
	
	
	static void pn(String ans) {out.print(ans);};
	static void pn(int ans) {out.print(ans);};
	static void pn() {out.print("""");};
	static void pn(long ans) {out.print(ans);};
	static void pn(double ans) {out.print(ans);};

	static class FastScanner {
	    private final InputStream in = System.in;
	    private final byte[] buffer = new byte[1024];
	    private int ptr = 0;
	    private int buflen = 0;

	    private boolean hasNextByte() {
	      if (ptr < buflen) {
	        return true;
	      } else {
	        ptr = 0;
	        try {
	          buflen = in.read(buffer);
	        } catch (IOException e) {
	          e.printStackTrace();
	        }
	        if (buflen <= 0) {
	          return false;
	        }
	      }
	      return true;
	    }

	    private int readByte() {
	      if (hasNextByte()) return buffer[ptr++];
	      else return -1;
	    }

	    private static boolean isPrintableChar(int c) {
	      return 33 <= c && c <= 126;
	    }

	    private void skipUnprintable() {
	      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
	    }

	    public boolean hasNext() {
	      skipUnprintable();
	      return hasNextByte();
	    }

	    public String next() {
	      if (!hasNext()) throw new NoSuchElementException();
	      StringBuilder sb = new StringBuilder();
	      int b = readByte();
	      while (isPrintableChar(b)) {
	        sb.appendCodePoint(b);
	        b = readByte();
	      }
	      return sb.toString();
	    }

	    public long nextLong() {
	      if (!hasNext()) throw new NoSuchElementException();
	      long n = 0;
	      boolean minus = false;
	      int b = readByte();
	      if (b == '-') {
	        minus = true;
	        b = readByte();
	      }
	      if (b < '0' || '9' < b) {
	        throw new NumberFormatException();
	      }
	      while (true) {
	        if ('0' <= b && b <= '9') {
	          n *= 10;
	          n += b - '0';
	        } else if (b == -1 || !isPrintableChar(b)) {
	          return minus ? -n : n;
	        } else {
	          throw new NumberFormatException();
	        }
	        b = readByte();
	      }
	    }

	    public int nextInt() {
	      return (int) nextLong();
	    }

	    public double nextDouble(){
	    	return Double.parseDouble(next());
	    }

	    public int[] nextIntArray(int N, boolean oneBased) {
	      if (oneBased) {
	        int[] array = new int[N + 1];
	        for (int i = 1; i <= N; i++) {
	          array[i] = sc.nextInt();
	        }
	        return array;
	      } else {
	        int[] array = new int[N];
	        for (int i = 0; i < N; i++) {
	          array[i] = sc.nextInt();
	        }
	        return array;
	      }
	    }

	    public long[] nextLongArray(int N, boolean oneBased) {
	      if (oneBased) {
	        long[] array = new long[N + 1];
	        for (int i = 1; i <= N; i++) {
	          array[i] = sc.nextLong();
	        }
	        return array;
	      } else {
	        long[] array = new long[N];
	        for (int i = 0; i < N; i++) {
	          array[i] = sc.nextLong();
	        }
	        return array;
	      }
	    }
	  }
}

"
28,"import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

public class Main {
	
	static final int MINUS_INF = -1001001001;

	public static void main(String[] args) {
		
		Main main = new Main();
		main.exec();
		
	}
	
	public void exec() {
		Scanner sc = new Scanner(System.in);
		String[] firstArr = sc.nextLine().split("" "");
		int n = Integer.parseInt(firstArr[0]);
		int m = Integer.parseInt(firstArr[1]);
		ArrayList<Arbeit> arbeitList = new ArrayList<>();
		for(int i = 0; i < n; i++) {
			String[] arbeitStrArr = sc.nextLine().split("" "");
			arbeitList.add(new Arbeit(Integer.parseInt(arbeitStrArr[1]), Integer.parseInt(arbeitStrArr[0])));
		}
		
		sc.close();
		
		Comparator<Arbeit> salaryComparator = Comparator.comparing(Arbeit::getSalary).reversed();
		Comparator<Arbeit> transferDateComparator = Comparator.comparing(Arbeit::getTransferDate).reversed();
		
		arbeitList.sort(transferDateComparator);
		arbeitList.sort(salaryComparator);
		
		int[] emptyScheList = makeSegmentTree(m+1);
//		System.out.println(Arrays.toString(emptyScheList));
		
		int sumOfSalary = 0;
		
		for(Arbeit arbeit : arbeitList) {
			
			int transferDate = arbeit.getTransferDate();
			int choice = m - transferDate;
			
			int arbeitDay = getMax(emptyScheList, 0,choice+1, 0, 0, m+1);
//			System.out.println(arbeitDay);
//			System.out.println(Arrays.toString(emptyScheList));
			
			if(arbeitDay >= 0) {
				updateSegTree(emptyScheList, arbeitDay, MINUS_INF);
				sumOfSalary += arbeit.getSalary();
			}
		}
		System.out.println(sumOfSalary);
//		System.out.println(Arrays.toString(emptyScheList));
	}

	/**
	 * 0-n-1を葉に持つsegment木を作る
	 * @param intArr
	 * @param n
	 */
	public int[] makeSegmentTree(int n) {
		int[] intArr = new int[2*n-1]; 
		for(int i = n - 1; i >= 0; i--) {
			intArr[intArr.length - (n - i)] = i;
		}
		
		for(int i = n -2; i >= 0; i--) {
			intArr[i] = Math.max(intArr[2*i + 1], intArr[2*i+2]);
		}
		return intArr;
	}
	
	public int getMax(int[] segTree, int a, int b, int k, int l, int r) {
		
		if(r <= a || b <= l) {
			return MINUS_INF;
		}
		
		if(a <= l && r <= b ) {
			return segTree[k];
		}
		
		return Math.max(getMax(segTree, a, b, 2*k+1,l, (r+l)/2) , getMax(segTree, a,b,2*k+2, (l+r)/2, r));
	}
	
	public void updateSegTree(int[] segTree, int pos, int value) {
		pos += (segTree.length + 1)/2 - 1;
		segTree[pos] = value;
		while(pos > 0) {
			pos = (pos - 1) / 2;
			segTree[pos] = Math.max(segTree[pos*2 +1], segTree[pos*2 +2]);
		}
	}
	
	public class Arbeit{
		int salary;
		int transferDate;
		
		public Arbeit(int salary, int transferDate){
			this.salary = salary;
			this.transferDate = transferDate;
		}
		
		public int getSalary() {
			return this.salary;
		}
		public int getTransferDate(){
			return this.transferDate;
		}
	}
}
"
29,"import java.util.Scanner;

public class Main {
	public static void main(String args[]){

		boolean prime[]=new boolean[100000];
		prime[0]=true;
		for(int i=1;i<100000;i++) {
			if(!prime[i]) {
				for(int j=1;j<Math.ceil(100000/(i+1));j++) {
					prime[(i+1)*(j+1)-1]=true;
				}
			}
		}

		Scanner scan=new Scanner(System.in);

		int q=scan.nextInt();

		int l[]=new int[q];
		int r[]=new int[q];

		for(int i=0;i<q;i++) {
			l[i]=scan.nextInt();
			r[i]=scan.nextInt();
		}

		int count[]=new int[q];

		for(int i=0;i<q;i++) {
			for(int j=l[i];j<r[i]+1;j+=2) {
				if((!(prime[j-1]))&&(!(prime[(j+1)/2-1]))) {
					count[i]++;
				}
			}
			System.out.println(count[i]);
		}
	}
}
"
30,"import java.io.BufferedReader;
import java.io.InputStreamReader;

public class Main {


	static int MAXN= 3005;

	static long dp[][][];
	static long as [];
	static long min(long a, long b) {
		return Math.min(a, b);
	}
	static long max(long a, long b) {
		return Math.max(a, b);
	}
	static long calc(int inicio, int fin, int p){
	    if(dp[inicio][fin][p]!=-1){
	        return dp[inicio][fin][p];
	    }
	    if(p==0){
	        return dp[inicio][fin][p]=max(as[inicio]+calc(inicio+1,fin,1),as[fin]+calc(inicio,fin-1,1));
	    }
	    return dp[inicio][fin][p]=min(calc(inicio+1,fin,0),calc(inicio,fin-1,0));
	}

	public static void main(String[] args) throws Exception{
	    int n;
	    long suma =0,X,rta;
	    dp = new long[MAXN][MAXN][2];
	    as  = new long [MAXN];
	    BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
	    n = Integer.parseInt(bf.readLine());
	    String[] data = bf.readLine().split("" "");
	    for(int i =0; i<MAXN; i++){
	        for(int j =0; j<MAXN; j++){
	            dp[i][j][0] = dp[i][j][1]=-1;
	        }
	    }
	    for(int i=0; i<n; i++){
	        as[i] = Long.parseLong(data[i]);
	        suma+=as[i];
	        dp[i][i][0]  = as[i];
	        dp[i][i][1] = 0;
	    }
	    X = calc(0,n-1,0);
	    rta = 2*X-suma;
	    System.out.println(rta);
	}
	
}
"
31,"public class Main {
    public static void main(String[] args) {
    	ACBC146V.A();
    }
}

class ACBC146V {
	static Scanner sc = new Scanner(System.in);
	static void A() {
		String s = sc.next();
		final String[] WEEK = new String[]{""SUN"", ""MON"", ""TUE"", ""WED"", ""THU"", ""FRI"", ""SAT""};
		for (int i = 0; i < WEEK.length; i++) {
			if(WEEK[i].equals(s)) {
				System.out.println(7 - i);
			}
		}
	}
}"
32,"import java.util.Scanner;
class Main {
  public static void main(String args[]){
    Scanner sc = new Scanner(System.in);
    int n , m;
    n = sc.nextInt();
    m = sc.nextInt();
    int[] A = new int[n];
    int i , counter;
    counter = 0;
    for(i=0; i < n ;i++){
      A[i] = sc.nextInt();
      if(A[i] / 4 / m < 0){
        counter++;
      }
    }
    if(counter < m){
      System.out.println(""Yes"");
    }else{
      System.out.println(""No"");
    }
  }
}
"
33,"import java.util.*;

class Main{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();
        String[] word = new String[n];
        boolean jdg = true;
        for(int i = 0;i < n;i++)
            word[i] = sc.next();

        for(int i = 0;i < n;i++){
            for(int j = i+1;i < n;j++){
                if(word[i].equalsIgnoreCase(word[j])){
                    jdg = false;
                    break;
                }
            }
            if(jdg == false)
            break;
        }

        if(jdg == true){
            for(int i = 0;i < n-1;i++){
                if(word[i-1].charAt(word[i].length()-1) != word[i].charAt(0)){
                    jdg = false;
                    break;
                }
            }
        }
        System.out.println(jdg == true?""Yes"" : ""No"");
        
    }
}"
34,"package petal;

import java.io.*;
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int x = sc.nextInt();
		int y= sc.nextInt();
		int z= sc.nextInt();
		while( x>9 || x<1 || y>9 || y<1 || z<1 || z>9)
		{
			x = sc.nextInt();
			y= sc.nextInt();
			z= sc.nextInt();
		}
		String xy= Integer.toString(x) + Integer.toString(y) + Integer.toString(z);
		int yz= Integer.valueOf(xy);
		if(yz%4==0) {
		System.out.print(""YES"");
		}else {
		System.out.print(""NO"");
		}
		sc.close();

	}
}
"
35,"import java.util.BitSet;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class Main{
	public static int w, h;
	public static char[][][] map = new char[50][50][2];
	public static final int[] dx = {1, 0, -1, 0};
	public static final int[] dy = {0, 1, 0, -1};
	public static int[] gx = new int[2];
	public static int[] gy = new int[2];
	public static int[] sx = new int[2];
	public static int[] sy = new int[2];
	public static BitSet used = new BitSet(50*50*50*50);
	public static void main(String[] args){
		Scanner in = new Scanner(System.in);
		while(true){
			w = in.nextInt();
			h = in.nextInt();
			if(w == 0) break;
//			map = new char[2][h][w];
			for(int j=0; j<h; j++){
				for(int i=0; i<2; i++){
					map[i][j] = in.next().toCharArray();
					for(int k=0; k<w; k++){
						if(map[i][j][k] == '%'){
							gx[i] = k;
							gy[i] = j;
						}else if(map[i][j][k] == 'L' || map[i][j][k] == 'R'){
							sx[i] = k;
							sy[i] = j;
						}
					}
				}
			}
			used.clear();
			Queue<Pos> qu = new LinkedList<Pos>();
			qu.add(new Pos(sy[0], sx[0], sy[1], sx[1]));
			used.set(qu.peek().id);
			boolean goal = false;
			while(!qu.isEmpty()){
				Pos p = qu.poll();
				if(goal(p)){
					goal = true;
					break;
				}
				if(oneGoal(p)) continue;
				for(int i=0; i<4; i++){
					Pos np = move(p, i);
					if(used.get(np.id)) continue;
					used.set(np.id);
					qu.add(np);
				}
			}
			System.out.println(goal?""Yes"":""No"");
		}
	}
	
	public static Pos move(Pos p, int dir){
		int nx1 = p.x1+dx[dir];
		int ny1 = p.y1+dy[dir];
		if(out(ny1, nx1) || map[0][ny1][nx1] == '#'){
			nx1 = p.x1;
			ny1 = p.y1;
		}
		int nx2 = p.x2-dx[dir];
		int ny2 = p.y2+dy[dir];
		if(out(ny2, nx2) || map[1][ny2][nx2] == '#'){
			nx2 = p.x2;
			ny2 = p.y2;
		}
		return new Pos(nx1, ny1, nx2, ny2);
	}
	
	public static boolean out(int y, int x){
		return x < 0 || x >= w || y < 0 || y >= h;
	}
	
	public static boolean goal(Pos p){
		return p.x1 == gx[0] && p.y1 == gy[0] && p.x2 == gx[1] && p.y2 == gy[1];
	}
	
	public static boolean oneGoal(Pos p){
		return p.x1 == gx[0] && p.y1 == gy[0] || p.x2 == gx[1] && p.y2 == gy[1];
	}
	
	public static int id(int y1, int x1, int y2, int x2){
		return y1*h*w*w + x1*h*w + y2*w + x2;
	}
}

class Pos{
	int x1, y1, x2, y2;
	int id;
	public Pos(int y1, int x1, int y2, int x2){
		this.x1 = x1;
		this.y1 = y1;
		this.x2 = x2;
		this.y2 = y2;
		id = Main.id(y1, x1, y2, x2);
	}
}"
36,"import java.util.*;
import java.lang.*;

public class Main {
    public static void main(String[] args) {
        //コード
        Scanner scanner = new Scanner(System.in);
        int n = Integer.parseInt(scanner.next());

        // 合計値
        List<Integer> total = new ArrayList<Integer>();


        for (int i =0; i <= n; i++) {
            boolean fizz = i % 3  == 0;
            boolean buzz =  i % 5 == 0;
            if (fizz || buzz)  continue;

            fizz = false;
            buzz = false;
            sum += i;
        }



        System.out.println(sum);
    }
}
"
37,"import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int kaisu = 5;
		int[] num = new int[kaisu];

		for(int i = 0; i < kaisu ; i++) {
			num[i] = scan.nextInt();
		}

		int wp = num[2]+num[4];
		int wm = num[2]-num[4];
		int hp = num[3]+num[4];
		int hm = num[3]-num[4];

		if(num[0] < wp | 0 > wm ) {
			System.out.println(""No"");
		}else if(num[1] < hp | 0 > hm) {
			System.out.println(""No"");
		}else System.out.println(""Yes"");
	}
}"
38,"import java.io.*;
import java.util.*;

/**
 * @author baito
 */

class UnionFindTree
{
    int[] par;
    int[] rank;
    int[] sizes;

    UnionFindTree(int n)
    {
        par = new int[n];
        rank = new int[n];
        sizes = new int[n];
        for (int i = 0; i < n; i++)
        {
            par[i] = i;
            sizes[i] = 1;
        }
    }

    int root(int x)
    {
        if (par[x] == x) return x;
        else return par[x] = root(par[x]);
    }

    void unite(int x, int y)
    {
        int rx = root(x);
        int ry = root(y);

        if (rx == ry) return;
        if (rank[rx] < rank[ry])
        {
            par[rx] = ry;
            sizes[ry] += sizes[rx];
        }
        else
        {
            par[ry] = rx;
            sizes[rx] += sizes[ry];
            if (rank[rx] == rank[ry]) rank[rx]++;
        }
    }

    boolean isSame(int x, int y)
    {
        return root(x) == root(y);
    }

    int size(int x)
    {
        return sizes[root(x)];
    }
}

class P implements Comparable<P>
{
    int v, id;

    P(int a, int b)
    {
        v = a;
        id = b;
    }

    @Override
    public boolean equals(Object o)
    {
        if (this == o) return true;
        if (!(o instanceof P)) return false;
        P p = (P) o;
        return v == p.v && id == p.id;
    }

    @Override
    public int hashCode()
    {
        return Objects.hash(v, id);
    }

    @Override
    public int compareTo(P p)
    {
        return v > p.v ? 1 : -1; //xで昇順にソート
        //return (v == p.v ? id - p.id : v - p.v) * -1; //xで降順にソート
        //return id == p.id ? v - p.v : id - p.id;//yで昇順にソート
        //return (id == p.id ? v - p.v : id - p.id)*-1;//yで降順にソート
    }
}

@SuppressWarnings(""unchecked"")
public class Main
{
    static StringBuilder sb = new StringBuilder();
    static FastScanner sc = new FastScanner(System.in);
    static int INF = 1234567890;
    static long LINF = 123456789123456789L;
    static long MINF = -123456789123456789L;
    static long MOD = 1000000007;
    static int[] y4 = {0, 1, 0, -1};
    static int[] x4 = {1, 0, -1, 0};
    static int[] y8 = {0, 1, 0, -1, -1, 1, 1, -1};
    static int[] x8 = {1, 0, -1, 0, 1, -1, 1, -1};
    static long[] Fa;//factorial
    static boolean[] isPrime;
    static int[] primes;
    static char[][] map;

    static int N, M, K;
    static int[] A;

    public static void main(String[] args)
    {
        //longを忘れるなオーバーフローするぞ
        N = sc.nextInt();
        P[] px = new P[N];
        P[] py = new P[N];
        for (int i = 0; i < N; i++)
        {
            px[i] = new P(sc.nextInt(), i);
            py[i] = new P(sc.nextInt(), i);
        }
        Arrays.sort(px);
        Arrays.sort(py);
        for (int i = 0; i < N - 1; i++)
        {
            addEdge(px[i].id, px[i + 1].id, Math.abs(px[i + 1].v - px[i].v));
            addEdge(py[i].id, py[i + 1].id, Math.abs(py[i + 1].v - py[i].v));
        }
        Collections.sort(edges);


        UnionFindTree uni = new UnionFindTree(N);
        long res = 0;
        for (Edge e : edges)
        {
            int f = e.f;
            int t = e.t;
            if (uni.isSame(f, t)) continue;
            uni.unite(f, t);
            res += e.toCost;
        }
        System.out.println(res);

    }

    static ArrayList<Edge> edges = new ArrayList<>();

    public static void addEdge(int f, int t, long c)
    {
        edges.add(new Edge(f, t, c));
    }


    static class Edge implements Comparable<Edge>
    {
        int f;
        int t;
        long toCost;

        Edge(int f, int to, long cost)
        {
            this.f = f;
            t = to;
            toCost = cost;
        }

        @Override
        public int compareTo(Edge e)
        {
            return toCost > e.toCost ? 1 : -1;
        }

    }

    public static int upper0(int a)
    {
        if (a < 0) return 0;
        return a;
    }

    public static long upper0(long a)
    {
        if (a < 0) return 0;
        return a;
    }

    public static Integer[] toIntegerArray(int[] ar)
    {
        Integer[] res = new Integer[ar.length];
        for (int i = 0; i < ar.length; i++)
        {
            res[i] = ar[i];
        }
        return res;
    }

    //k個の次の組み合わせをビットで返す 大きさに上限はない 110110 -> 111001
    public static int nextCombSizeK(int comb, int k)
    {
        int x = comb & -comb; //最下位の1
        int y = comb + x; //連続した下の1を繰り上がらせる
        return ((comb & ~y) / x >> 1) | y;
    }

    public static int keta(long num)
    {
        int res = 0;
        while (num > 0)
        {
            num /= 10;
            res++;
        }
        return res;
    }

    public static long getHashKey(int a, int b)
    {
        return (long) a << 32 | b;
    }

    public static boolean isOutofIndex(int x, int y)
    {
        if (x < 0 || y < 0) return true;
        if (map[0].length <= x || map.length <= y) return true;
        return false;
    }

    public static void setPrimes()
    {
        int n = 100001;
        isPrime = new boolean[n];
        List<Integer> prs = new ArrayList<>();
        Arrays.fill(isPrime, true);
        isPrime[0] = isPrime[1] = false;
        for (int i = 2; i * i <= n; i++)
        {
            if (!isPrime[i]) continue;
            prs.add(i);
            for (int j = i * 2; j < n; j += i)
            {
                isPrime[j] = false;
            }
        }
        primes = new int[prs.size()];
        for (int i = 0; i < prs.size(); i++)
            primes[i] = prs.get(i);
    }

    public static void revSort(int[] a)
    {
        Arrays.sort(a);
        reverse(a);
    }

    public static void revSort(long[] a)
    {
        Arrays.sort(a);
        reverse(a);
    }

    public static int[][] copy(int[][] ar)
    {
        int[][] nr = new int[ar.length][ar[0].length];
        for (int i = 0; i < ar.length; i++)
            for (int j = 0; j < ar[0].length; j++)
                nr[i][j] = ar[i][j];
        return nr;
    }

    /**
     * <h1>指定した値以上の先頭のインデクスを返す</h1>
     * <p>配列要素が０のときは、０が返る。</p>
     *
     * @return<b>int</b> ： 探索した値以上で、先頭になるインデクス
     * 値が無ければ、挿入できる最小のインデックス
     */
    public static int lowerBound(final int[] arr, final int value)
    {
        int low = 0;
        int high = arr.length;
        int mid;

        while (low < high)
        {
            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (オーバーフロー対策)
            if (arr[mid] < value)
            {
                low = mid + 1;
            }
            else
            {
                high = mid;
            }
        }
        return low;
    }

    /**
     * <h1>指定した値より大きい先頭のインデクスを返す</h1>
     * <p>配列要素が０のときは、０が返る。</p>
     *
     * @return<b>int</b> ： 探索した値より上で、先頭になるインデクス
     * 値が無ければ、挿入できる最小のインデックス
     */
    public static int upperBound(final int[] arr, final int value)
    {
        int low = 0;
        int high = arr.length;
        int mid;
        while (low < high)
        {
            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (オーバーフロー対策)
            if (arr[mid] <= value)
            {
                low = mid + 1;
            }
            else
            {
                high = mid;
            }
        }
        return low;
    }

    /**
     * <h1>指定した値以上の先頭のインデクスを返す</h1>
     * <p>配列要素が０のときは、０が返る。</p>
     *
     * @return<b>int</b> ： 探索した値以上で、先頭になるインデクス
     * 値がなければ挿入できる最小のインデックス
     */
    public static long lowerBound(final long[] arr, final long value)
    {
        int low = 0;
        int high = arr.length;
        int mid;
        while (low < high)
        {
            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (オーバーフロー対策)
            if (arr[mid] < value)
            {
                low = mid + 1;
            }
            else
            {
                high = mid;
            }
        }
        return low;
    }

    /**
     * <h1>指定した値より大きい先頭のインデクスを返す</h1>
     * <p>配列要素が０のときは、０が返る。</p>
     *
     * @return<b>int</b> ： 探索した値より上で、先頭になるインデクス
     * 値がなければ挿入できる最小のインデックス
     */
    public static long upperBound(final long[] arr, final long value)
    {
        int low = 0;
        int high = arr.length;
        int mid;
        while (low < high)
        {
            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (オーバーフロー対策)
            if (arr[mid] <= value)
            {
                low = mid + 1;
            }
            else
            {
                high = mid;
            }
        }
        return low;
    }

    //次の順列に書き換える、最大値ならfalseを返す
    public static boolean nextPermutation(int A[])
    {
        int len = A.length;
        int pos = len - 2;
        for (; pos >= 0; pos--)
        {
            if (A[pos] < A[pos + 1]) break;
        }
        if (pos == -1) return false;

        //posより大きい最小の数を二分探索
        int ok = pos + 1;
        int ng = len;
        while (Math.abs(ng - ok) > 1)
        {
            int mid = (ok + ng) / 2;
            if (A[mid] > A[pos]) ok = mid;
            else ng = mid;

        }

        swap(A, pos, ok);
        reverse(A, pos + 1, len - 1);


        return true;
    }

    //次の順列に書き換える、最小値ならfalseを返す
    public static boolean prevPermutation(int A[])
    {
        int len = A.length;
        int pos = len - 2;
        for (; pos >= 0; pos--)
        {
            if (A[pos] > A[pos + 1]) break;
        }
        if (pos == -1) return false;

        //posより小さい最大の数を二分探索
        int ok = pos + 1;
        int ng = len;
        while (Math.abs(ng - ok) > 1)
        {
            int mid = (ok + ng) / 2;
            if (A[mid] < A[pos]) ok = mid;
            else ng = mid;

        }

        swap(A, pos, ok);
        reverse(A, pos + 1, len - 1);


        return true;
    }

    //↓nCrをmod計算するために必要。　***factorial(N)を呼ぶ必要がある***
    static long ncr(int n, int r)
    {
        if (n < r) return 0;
        else if (r == 0) return 1;

        factorial(n);
        return Fa[n] / (Fa[n - r] * Fa[r]);
    }

    static long ncr2(int a, int b)
    {
        if (b == 0) return 1;
        else if (a < b) return 0;
        long res = 1;
        for (int i = 0; i < b; i++)
        {
            res *= a - i;
            res /= i + 1;
        }
        return res;
    }

    static long ncrdp(int n, int r)
    {
        if (n < r) return 0;
        long[][] dp = new long[n + 1][r + 1];
        for (int ni = 0; ni < n + 1; ni++)
        {
            dp[ni][0] = dp[ni][ni] = 1;
            for (int ri = 1; ri < ni; ri++)
            {
                dp[ni][ri] = dp[ni - 1][ri - 1] + dp[ni - 1][ri];
            }
        }
        return dp[n][r];
    }

    static long modNcr(int n, int r)
    {
        if (n < r) return 0;
        long result = Fa[n];
        result = result * modInv(Fa[n - r]) % MOD;
        result = result * modInv(Fa[r]) % MOD;
        return result;
    }

    public static long modSum(long... lar)
    {
        long res = 0;
        for (long l : lar)
            res = (res + l % MOD) % MOD;
        if (res < 0) res += MOD;
        res %= MOD;
        return res;
    }

    public static long modDiff(long a, long b)
    {
        long res = a % MOD - b % MOD;
        if (res < 0) res += MOD;
        res %= MOD;
        return res;
    }

    public static long modMul(long... lar)
    {
        long res = 1;
        for (long l : lar)
            res = (res * l % MOD) % MOD;
        if (res < 0) res += MOD;
        res %= MOD;
        return res;
    }

    public static long modDiv(long a, long b)
    {
        long x = a % MOD;
        long y = b % MOD;
        long res = (x * modInv(y)) % MOD;
        return res;
    }

    static long modInv(long n)
    {
        return modPow(n, MOD - 2);
    }

    static void factorial(int n)
    {
        Fa = new long[n + 1];
        Fa[0] = Fa[1] = 1;
//        for (int i = 2; i <= n; i++)
//        {
//            Fa[i] = (Fa[i - 1] * i) % MOD;
//        }
        //
        for (int i = 2; i <= 100000; i++)
        {
            Fa[i] = (Fa[i - 1] * i) % MOD;
        }
        for (int i = 100001; i <= n; i++)
        {
            Fa[i] = (Fa[i - 1] * i) % MOD;
        }
    }

    static long modPow(long x, long n)
    {
        long res = 1L;
        while (n > 0)
        {
            if ((n & 1) == 1)
            {
                res = res * x % MOD;
            }
            x = x * x % MOD;
            n >>= 1;
        }
        return res;
    }

    //↑nCrをmod計算するために必要

    static int gcd(int n, int r)
    {
        return r == 0 ? n : gcd(r, n % r);
    }

    static long gcd(long n, long r)
    {
        return r == 0 ? n : gcd(r, n % r);
    }

    static <T> void swap(T[] x, int i, int j)
    {
        T t = x[i];
        x[i] = x[j];
        x[j] = t;
    }

    static void swap(int[] x, int i, int j)
    {
        int t = x[i];
        x[i] = x[j];
        x[j] = t;
    }

    public static void reverse(int[] x)
    {
        int l = 0;
        int r = x.length - 1;
        while (l < r)
        {
            int temp = x[l];
            x[l] = x[r];
            x[r] = temp;
            l++;
            r--;
        }
    }

    public static void reverse(long[] x)
    {
        int l = 0;
        int r = x.length - 1;
        while (l < r)
        {
            long temp = x[l];
            x[l] = x[r];
            x[r] = temp;
            l++;
            r--;
        }
    }

    public static void reverse(char[] x)
    {
        int l = 0;
        int r = x.length - 1;
        while (l < r)
        {
            char temp = x[l];
            x[l] = x[r];
            x[r] = temp;
            l++;
            r--;
        }
    }

    public static void reverse(int[] x, int s, int e)
    {
        int l = s;
        int r = e;
        while (l < r)
        {
            int temp = x[l];
            x[l] = x[r];
            x[r] = temp;
            l++;
            r--;
        }
    }

    static int length(int a)
    {
        int cou = 0;
        while (a != 0)
        {
            a /= 10;
            cou++;
        }
        return cou;
    }

    static int length(long a)
    {
        int cou = 0;
        while (a != 0)
        {
            a /= 10;
            cou++;
        }
        return cou;
    }

    static int cou(boolean[] a)
    {
        int res = 0;
        for (boolean b : a)
        {
            if (b) res++;
        }
        return res;
    }

    static int cou(String s, char c)
    {
        int res = 0;
        for (char ci : s.toCharArray())
        {
            if (ci == c) res++;
        }
        return res;
    }

    static int countC2(char[][] a, char c)
    {
        int co = 0;
        for (int i = 0; i < a.length; i++)
            for (int j = 0; j < a[0].length; j++)
                if (a[i][j] == c) co++;
        return co;
    }

    static int countI(int[] a, int key)
    {
        int co = 0;
        for (int i = 0; i < a.length; i++)
            if (a[i] == key) co++;
        return co;
    }

    static int countI(int[][] a, int key)
    {
        int co = 0;
        for (int i = 0; i < a.length; i++)
            for (int j = 0; j < a[0].length; j++)
                if (a[i][j] == key) co++;
        return co;
    }

    static void fill(int[][] a, int v)
    {
        for (int i = 0; i < a.length; i++)
            for (int j = 0; j < a[0].length; j++)
                a[i][j] = v;
    }


    static void fill(long[][] a, long v)
    {
        for (int i = 0; i < a.length; i++)
            for (int j = 0; j < a[0].length; j++)
                a[i][j] = v;
    }

    static void fill(int[][][] a, int v)
    {
        for (int i = 0; i < a.length; i++)
            for (int j = 0; j < a[0].length; j++)
                for (int k = 0; k < a[0][0].length; k++)
                    a[i][j][k] = v;
    }

    static int max(int... a)
    {
        int res = Integer.MIN_VALUE;
        for (int i : a)
        {
            res = Math.max(res, i);
        }
        return res;
    }

    static long min(long... a)
    {
        long res = Long.MAX_VALUE;
        for (long i : a)
        {
            res = Math.min(res, i);
        }
        return res;
    }

    static int max(int[][] ar)
    {
        int res = Integer.MIN_VALUE;
        for (int i[] : ar)
            res = Math.max(res, max(i));
        return res;
    }

    static int min(int... a)
    {
        int res = Integer.MAX_VALUE;
        for (int i : a)
        {
            res = Math.min(res, i);
        }
        return res;
    }


    static int min(int[][] ar)
    {
        int res = Integer.MAX_VALUE;
        for (int i[] : ar)
            res = Math.min(res, min(i));
        return res;
    }

    static int sum(int[] a)
    {
        int cou = 0;
        for (int i : a)
            cou += i;
        return cou;
    }

    static int abs(int a)
    {
        return Math.abs(a);
    }

    static class FastScanner
    {

        private BufferedReader reader = null;
        private StringTokenizer tokenizer = null;

        public FastScanner(InputStream in)
        {
            reader = new BufferedReader(new InputStreamReader(in));
            tokenizer = null;
        }

        public String next()
        {
            if (tokenizer == null || !tokenizer.hasMoreTokens())
            {
                try
                {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e)
                {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        /*public String nextChar(){
            return (char)next()[0];
        }*/
        public String nextLine()
        {
            if (tokenizer == null || !tokenizer.hasMoreTokens())
            {
                try
                {
                    return reader.readLine();
                } catch (IOException e)
                {
                    throw new RuntimeException(e);
                }
            }

            return tokenizer.nextToken(""\n"");
        }

        public long nextLong()
        {
            return Long.parseLong(next());
        }

        public int nextInt()
        {
            return Integer.parseInt(next());
        }

        public double nextDouble()
        {
            return Double.parseDouble(next());
        }

        public int[] nextIntArray(int n)
        {
            int[] a = new int[n];
            for (int i = 0; i < n; i++)
            {
                a[i] = nextInt();
            }
            return a;
        }

        public int[] nextIntArrayOneIndex(int n)
        {
            int[] a = new int[n + 1];
            for (int i = 1; i < n + 1; i++)
            {
                a[i] = nextInt();
            }
            return a;
        }

        public int[] nextIntArrayDec(int n)
        {
            int[] a = new int[n];
            for (int i = 0; i < n; i++)
            {
                a[i] = nextInt() - 1;
            }
            return a;
        }

        public int[][] nextIntArray2(int h, int w)
        {
            int[][] a = new int[h][w];
            for (int hi = 0; hi < h; hi++)
            {
                for (int wi = 0; wi < w; wi++)
                {
                    a[hi][wi] = nextInt();
                }
            }
            return a;
        }

        public int[][] nextIntArray2Dec(int h, int w)
        {
            int[][] a = new int[h][w];
            for (int hi = 0; hi < h; hi++)
            {
                for (int wi = 0; wi < w; wi++)
                {
                    a[hi][wi] = nextInt() - 1;
                }
            }
            return a;
        }

        //複数の配列を受け取る
        public void nextIntArrays2ar(int[] a, int[] b)
        {
            for (int i = 0; i < a.length; i++)
            {
                a[i] = sc.nextInt();
                b[i] = sc.nextInt();
            }
        }

        public void nextIntArrays2arDec(int[] a, int[] b)
        {
            for (int i = 0; i < a.length; i++)
            {
                a[i] = sc.nextInt() - 1;
                b[i] = sc.nextInt() - 1;
            }
        }

        //複数の配列を受け取る
        public void nextIntArrays3ar(int[] a, int[] b, int[] c)
        {
            for (int i = 0; i < a.length; i++)
            {
                a[i] = sc.nextInt();
                b[i] = sc.nextInt();
                c[i] = sc.nextInt();
            }
        }

        //複数の配列を受け取る
        public void nextIntArrays3arDecLeft2(int[] a, int[] b, int[] c)
        {
            for (int i = 0; i < a.length; i++)
            {
                a[i] = sc.nextInt() - 1;
                b[i] = sc.nextInt() - 1;
                c[i] = sc.nextInt();
            }
        }

        public Integer[] nextIntegerArray(int n)
        {
            Integer[] a = new Integer[n];
            for (int i = 0; i < n; i++)
            {
                a[i] = nextInt();
            }
            return a;
        }

        public char[] nextCharArray(int n)
        {
            char[] a = next().toCharArray();

            return a;
        }

        public char[][] nextCharArray2(int h, int w)
        {
            char[][] a = new char[h][w];
            for (int i = 0; i < h; i++)
            {
                a[i] = next().toCharArray();
            }
            return a;
        }

        //スペースが入っている場合
        public char[][] nextCharArray2s(int h, int w)
        {
            char[][] a = new char[h][w];
            for (int i = 0; i < h; i++)
            {
                a[i] = nextLine().replace("" "", """").toCharArray();
            }
            return a;
        }

        public char[][] nextWrapCharArray2(int h, int w, char c)
        {
            char[][] a = new char[h + 2][w + 2];
            //char c = '*';
            int i;
            for (i = 0; i < w + 2; i++)
                a[0][i] = c;
            for (i = 1; i < h + 1; i++)
            {
                a[i] = (c + next() + c).toCharArray();
            }
            for (i = 0; i < w + 2; i++)
                a[h + 1][i] = c;
            return a;
        }

        //スペースが入ってる時用
        public char[][] nextWrapCharArray2s(int h, int w, char c)
        {
            char[][] a = new char[h + 2][w + 2];
            //char c = '*';
            int i;
            for (i = 0; i < w + 2; i++)
                a[0][i] = c;
            for (i = 1; i < h + 1; i++)
            {
                a[i] = (c + nextLine().replace("" "", """") + c).toCharArray();
            }
            for (i = 0; i < w + 2; i++)
                a[h + 1][i] = c;
            return a;
        }

        public long[] nextLongArray(int n)
        {
            long[] a = new long[n];
            for (int i = 0; i < n; i++)
            {
                a[i] = nextLong();
            }
            return a;
        }

        public long[][] nextLongArray2(int h, int w)
        {
            long[][] a = new long[h][w];
            for (int hi = 0; hi < h; hi++)
            {
                for (int wi = 0; wi < w; wi++)
                {
                    a[hi][wi] = nextLong();
                }
            }
            return a;
        }
    }
}
"
39,"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.util.HashMap;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author shangu
 */
public class Main {
  public static void main(String[] args) {
    InputStream inputStream = System.in;
    OutputStream outputStream = System.out;
    FastReader in = new FastReader(inputStream);
    PrintWriter out = new PrintWriter(outputStream);
    FSumDifference solver = new FSumDifference();
    solver.solve(1, in, out);
    out.close();
  }

  static class FSumDifference {
    public void solve(int testNumber, FastReader in, PrintWriter out) {
      long n = in.nextLong(), x = in.nextLong(), d = in.nextLong();
      HashMap<Long, ArrayList<Seg>> segments = new HashMap<>();
      for (long i = 0; i <= n; i++) {
        long grp = x * i, offet = (long) Math.ceil(grp * 1.0 / d);
        grp = (grp % d + d) % d;
        if (!segments.containsKey(grp)) segments.put(grp, new ArrayList<>());
        ArrayList<Seg> cur = segments.get(grp);
        cur.add(new Seg(offet + i * (i - 1) / 2, -1));
        cur.add(new Seg(offet + (2 * n - 1 - i) * i / 2, 1));
      }
      long ans = 0;
      for (ArrayList<Seg> list : segments.values()) {
        list.sort((a, b) -> (int) (a.v == b.v ? a.t - b.t : a.v - b.v));
        int cnt = 0;
        long begin = 0;
        for (Seg e : list) {
          if (cnt == 0 && e.t == -1) begin = e.v;
          cnt += e.t;
          if (cnt == 0) ans += e.v - begin + 1;
        }
      }
      out.println(ans);
    }

    private class Seg {
      long v;
      int t;

      public Seg(long _v, int _t) {
        v = _v;
        t = _t;
      }

    }

  }

  static class FastReader {
    BufferedReader br;
    StringTokenizer st;

    public FastReader(InputStream stream) {
      br = new BufferedReader(new InputStreamReader(stream), 32768);
      st = null;
    }

    public String next() {
      while (st == null || !st.hasMoreElements()) {
        try {
          st = new StringTokenizer(br.readLine());
        } catch (IOException e) {
          e.printStackTrace();
        }
      }
      return st.nextToken();
    }

    public long nextLong() {
      return Long.parseLong(next());
    }

  }
}

"
40,"
import java.awt.geom.*;
import java.util.*;

public class Main {
	//0445 start
	//0536 cording end, last dataset is not matched
	//0538 stop and ready to go to school 
	
	int INF = 1 << 24;
	final double EPS = 1.0e-08;
	double EPS2 = 1.0e-04;
	int n, s1, s2;
	Point2D s1p, s2p;
	Point2D [] toy;
	
	class Edge{
		int from, to;
		double cost;
		public Edge(int from, int to, double cost) {
			this.from = from;
			this.to = to;
			this.cost = cost;
		}
		@Override
		public String toString() {
			return ""Edge [from="" + from + "", to="" + to + "", cost="" + cost + ""]"";
		}
		
	}
	
	class C implements Comparable<C>{
		int ind;
		Point2D p;
		public C(int ind, Point2D p) {
			this.ind = ind;
			this.p = p;
		}
		@Override
		public int compareTo(C o) {
			if(this.p.getX() < o.p.getX()) return -1;
			else if(this.p.getX() > o.p.getX()) return 1;
			else if(this.p.getY() < o.p.getY()) return -1;
			else if(this.p.getY() > o.p.getY()) return 1;
			else return 0;
		}
	}
	Comparator< Point2D > com = new Comparator< Point2D >() {
		public int compare(Point2D o1, Point2D o2) {
			if(o1.getX() < o2.getX()) return -1;
			else if(o1.getX() > o2.getX()) return 1;
			else if(o1.getY() < o2.getY()) return -1;
			else if(o1.getY() > o2.getY()) return 1;
			else return 0;
		}
	};
	
	class State implements Comparable<State>{
		int now1, now2;
		double cost;
		public State(int now1, int now2, double cost) {
			super();
			this.now1 = now1;
			this.now2 = now2;
			this.cost = cost;
		}
		@Override
		public int compareTo(State o) {
			if(this.cost < o.cost ) return -1;
			if(this.cost > o.cost)	return 1;
			return 0;
		}
		
	}
	
	private void doit(){
		Scanner sc = new Scanner(System.in);
		while(true){
			n = sc.nextInt();
			if(n == 0) break;
			Point2D [] plist = new Point2D[n];
			HashSet<Integer> ylist = new HashSet<Integer>();
			for(int i = 0 ; i < n; i ++){
				int x = sc.nextInt();
				int y = sc.nextInt();
				ylist.add(y);
				plist[i] = new Point2D.Double(x,y);
			}
			s1p = plist[0];
			s2p = plist[n-1];
			
			ArrayList<Line2D> llist = new ArrayList<Line2D>();
			for(int i = 1;i < n; i++){
				Line2D l = new Line2D.Double(plist[i-1], plist[i]);
				llist.add(l);
			}
			ArrayList<Line2D> l2list = new ArrayList<Line2D>();
			for(int y : ylist){
				Point2D p1 = new Point2D.Double(-1,y);
				Point2D p2 = new Point2D.Double(1001, y);
				Line2D ll = new Line2D.Double(p1, p2);
				l2list.add(ll);
			}
			
			ArrayList<ArrayList<Edge>> pass = segmentArrangement(llist, l2list);
			double ans = solve(pass);
			System.out.printf(""%f\n"",ans);
			
		}
		
	}
	
	private double solve(ArrayList<ArrayList<Edge>> pass) {
		double ans = INF;
		int passsize = pass.size();
		PriorityQueue<State> open = new PriorityQueue<State>();
		open.add(new State(s1, s2, 0.0));
		double [][] close = new double[passsize][passsize];
		for(int i = 0 ; i < passsize; i++){
			Arrays.fill(close[i], INF);
		}
		close[s1][s2] = 0.0;
		while(! open.isEmpty()){
			State now = open.poll();
			if(now.now1 == now.now2){
				ans = Math.min(ans, now.cost);
				break;
			}
			
			for(int i = 0 ; i < pass.get(now.now1).size(); i++){
				for(int j = 0; j < pass.get(now.now2).size(); j++){
					int next1 = pass.get(now.now1).get(i).to;
					int next2 = pass.get(now.now2).get(j).to;
					if(next1 == now.now1 && next2 == now.now2)continue;
					if(Math.abs(toy[next1].getY() - toy[next2].getY()) < EPS){
						double value = pass.get(now.now1).get(i).cost+ pass.get(now.now2).get(j).cost;
						double nextcost = now.cost + value;
						if(close[next1][next2] <= nextcost) continue;
						close[next1][next2] = nextcost;
						open.add(new State(next1, next2, nextcost));
					}
				}
			}
		}
		return ans;
	}

	private ArrayList<ArrayList<Edge>> segmentArrangement(ArrayList<Line2D> arg, ArrayList<Line2D> l2) {
		Line2D [] line = arg.toArray(new Line2D[arg.size()]);
		//交点リストを求める
		ArrayList<Point2D> intersectionlist = new ArrayList<Point2D>();
		for(int i = 0; i < line.length; i++){
			intersectionlist.add(line[i].getP1());
			intersectionlist.add(line[i].getP2());
			for(int j = i + 1; j < line.length; j++){
				if(line[i].intersectsLine(line[j])){
					Point2D p = intersectPtSS(line[i], line[j]);
					if(p == null) continue;
					intersectionlist.add(p);
				}
			}
		}
		
		for(int i = 0 ; i < l2.size(); i++){
			for(int j = 0; j < line.length; j++){
				if(l2.get(i).intersectsLine(line[j])){
					Point2D p = intersectPtSS(l2.get(i), line[j]);
					if(p == null) continue;
					intersectionlist.add(p);
				}
			}
		}

		//sortする。重複削除
		Collections.sort(intersectionlist, com);
		for(int i = 1; i < intersectionlist.size(); i++){
			if(issame(intersectionlist.get(i-1), intersectionlist.get(i))){
				intersectionlist.remove(i);
				i--;
			}
		}
		
		

		//交点リストから、線分を通過するもの同士でグラフを生成する。
		int len = intersectionlist.size();
		toy = new Point2D[len];
		for(int i = 0 ; i < len; i++){
			toy[i] = intersectionlist.get(i);
			if(issame(toy[i], s1p)){
				s1 = i;
			}
			if(issame(toy[i], s2p)){
				s2 = i;
			}
		}
		
		//double [][] res = new double[len][len];
		ArrayList<ArrayList<Edge>> res = new ArrayList<ArrayList<Edge>>();
		for(int i = 0; i < len; i++){
			res.add(new ArrayList<Main.Edge>());
			res.get(i).add(new Edge(i, i, 0.0));
		}
		for(int i = 0; i < line.length; i++){
			
			ArrayList<C> list = new ArrayList<C>();
			for(int j = 0; j < len; j++){
				if(line[i].ptSegDist(intersectionlist.get(j)) < 1.0){
					list.add(new C(j, intersectionlist.get(j)));
				}
			}
			Collections.sort(list);
			for(int j = 1; j < list.size(); j++){
				int from = list.get(j-1).ind;
				int to = list.get(j).ind;
				double cost = list.get(j).p.distance(list.get(j-1).p);
				res.get(from).add(new Edge(from, to, cost));
				res.get(to).add(new Edge(to, from, cost));
			}
		}
		return res;
	}
	
	private Point2D intersectPtSS(Line2D l, Line2D m) {
		Point2D lVec = sub(l.getP2(), l.getP1());
		Point2D mVec = sub(m.getP2(), m.getP1());
		Point2D m1l1Vec = sub(m.getP1(), l.getP1());
		double a = cross(m1l1Vec, lVec);
		double b = cross(lVec, mVec);
		if(Math.abs(a) < EPS && Math.abs(b) < EPS){
			//平行な直線同士の場合
			return null;
//			if(l.getP1().distance(m.getP1()) < EPS) return l.getP1();
//			if(l.getP1().distance(m.getP2()) < EPS) return l.getP1();
//			return l.getP2();
		}
		double t = a / b;
		double resx = m.getX1() + t * mVec.getX();
		double resy = m.getY1() + t * mVec.getY();
		return new Point2D.Double(resx, resy);
	}
	
	private boolean issame(Point2D p1, Point2D p2) {
		if(Math.abs(p1.getX() - p2.getX()) < EPS && Math.abs(p1.getY() - p2.getY()) < EPS ){
			return true;
		}
		return false;
	}
	private double cross(Point2D p1, Point2D p2) {
		double res = p1.getX() * p2.getY() - p1.getY() * p2.getX();
		return res;
	}
	private Point2D sub(Point2D p2, Point2D p1) {
		double x = p2.getX() - p1.getX();
		double y = p2.getY() - p1.getY();
		return new Point2D.Double(x, y);
	}

	public static void main(String [] args){
		new Main().doit();
	}
}"
41,"import java.io.*;
public class Main{

	public static void main(String[] args) {
		// TODO Auto-generated method stub
	    int i,j,n=0,hz=0,sc;
    BufferedReader sca=new BufferedReader(new InputStreamReader(System.in));;
    String yomi,sp[]=new String[2];//0:order 1:name
    try{
    n=Integer.parseInt(sca.readLine());
    }catch(Exception e){
	System.out.println(e);
    }
    String dic[] = new String[n];
    for(i=0;i<n;i++){
	try{
	sp=(sca.readLine()).split(""[\\s]+"");
	}catch(Exception e){
	    System.out.println(e);
	}
    	if(sp[0].equals(""insert"")){
	    for(sc=0;sc<n;sc++){
		hz=(myhash(sp[1],n)+sc*(1+myhash(sp[1],n-1)))%n;
		if(dic[hz]==null){
		    dic[hz]=sp[1];
		    break;
	    }
    	}
	}
    	if(sp[0].equals(""find"")){
	    for(sc=0;sc<n;sc++){
		hz=(myhash(sp[1],n)+sc*(1+myhash(sp[1],n-1)))%n;
		if(dic[hz]==null){
		    break;
      		}
		if(dic[hz].equals(sp[1])){
		    break;
		}
	    }
    		if(dic[hz]==null||sc==n){
    			System.out.println(""no"");
    		}else{
    			System.out.println(""yes"");
    		}
    	}
	
    }
	}
    
    public static int myhash(String data,int ti){//A=2,C=3,G=5,T=7;
	int k,h;
        String moji[];
	moji=data.split("""");
	//	System.out.println(moji[0]);
	h=1;
	for(k=0;k<moji.length;k++){
	    if(moji[k].equals(""A"")){
		h*=2;
	    }else if(moji[k].equals(""C"")){
		h*=3;
	    }else if(moji[k].equals(""G"")){
		h*=5;
	    }else if(moji[k].equals(""T"")){
		h*=7;
	    }
	}
	return h%ti;
    }

}

"
42,"import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main{

	public static void main(String[] args) throws NumberFormatException,
			IOException {
		 BufferedReader br = new BufferedReader(new
		 InputStreamReader(System.in));
		//BufferedReader br = new BufferedReader(new FileReader(""sample.txt""));

		int n = Integer.parseInt(br.readLine());
		int[] in = new int[n];
		int max = Integer.MIN_VALUE;
		int mini = 0;
		int maxj=0;
		boolean con=false;
		
		for (int i = 0; i < n; i++)
			in[i] = Integer.parseInt(br.readLine());
		

		for (int i = 0; i < n - 1; i++) {
			if (in[i] > in[mini])
				continue;
			for (int j = i + 1; j < n; j++) 
				if(i!=0&&con&&i<maxj){
					mini=i;
					max=in[maxj]-in[i];
					break;}
				else if(max+in[i]<in[j]){
					max=in[j]-in[i];
					mini=i;
					maxj=j;
					con=false;
				}
			}con=true;
		}
		System.out.println(max);

	}

}"
43,"import java.util.Scanner;

public class AFavoriteSound {
	public static void main(String[] args) {
		// 入力値を取得
		Scanner sc = new Scanner(System.in);
		int a = sc.nextInt();
		int b = sc.nextInt();
		int c = sc.nextInt();
		// 満足度満たすか否か
		int smile = 0;
		smile = b >= a * c ? c : b / a;
		// 出力
		System.out.println(smile);
		// クローズ
		sc.close();
	}

}"
44,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		do {
			int n = Integer.parseInt(br.readLine().trim());
			List<Integer> L = new ArrayList<Integer>();
			for (int i = 2 ; i <= n ; i++) {
				L.add(i);
			}
			List<Integer> P = new ArrayList<Integer>();
			while (!L.isEmpty()) {
				int i = L.get(0);
				P.add(i);
				for (Iterator<Integer> it = L.iterator() ; it.hasNext() ;) {
					Integer I = it.next();
					if (I % i == 0) it.remove();
				}
			}
			System.out.println(""""+P.size());
		} while (br.ready());
	}
}"
45,"import java.util.Scanner;
public class main {
	private int page;
	private int max;
	 boolean flg = true;
	public main(int a,int b){
		page = a;
		max = b;
	}
	public void study(){
		this.page -= this.max;
		if(this.page <=0){
			this.page = 0;
			this.flg = false;
		}
	}
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		int l,a,b,c,d,ans = 0;
		 l = sc.nextInt();
		 a = sc.nextInt();
		 b = sc.nextInt();
		 c = sc.nextInt();
		 d = sc.nextInt();
		main ko = new main(a,c);
		main su = new main(b,d);
		while(ko.flg && su.flg){
			ko.study();
			su.study();
			ans ++;
		}
		System.out.println(l - (ans));
	}

}"
46,"import java.util.Scanner;

public class Main {
 
	public static void main(String[] args) {
		Scanner stdIn = new Scanner(System.in);
		double A = stdIn.nextDouble();
		double B = stdIn.nextDouble();
		long N = stdIn.nextLong();
		
		long max = 0;
		long maxIdx = 0;
		
		for(int i = (int)B - 1; i <= N; i += (int) B) {
			if(max < sub(A, B, i)) {
				max = sub(A, B, i);
			}else {
				maxIdx = i;
				break;
			}
		}
		
		for(int i = (int)maxIdx + 1; i <= N; i ++) {
			max = Math.max(max, sub(A, B, i));
		}
		System.out.println(max);
	}
	
	public static long sub(double A, double B, long x) {
		long ret = (long) (Math.floor(A * x / B) - A * Math.floor(x / B));
		return ret;
	}
}"
47,"import java.util.Scanner;
class Main {
    public static void main(String[] args){
        Scanner scan = new Scanner(System.in);
        int W = scan.nextInt();
        int H = scan.nextInt();
        int x = scan.nextInt();
        int y = scan.nextInt();
        int r = scan.nextInt();
        
        if(((x - r) >= 0 && (x + r) <= W) && ((y - r) >= 0 && (y + r) <= H)){
           System.out.println(""Yes"");
        }else{
           System.out.println(""No"");
        }
    }
}"
48,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        if (s.charAt(2) == s.charAt(3) && s.charAt(4) == s.charAt(5)) {
            System.out.println(""Yes"");
        } else {
            System.out.println(""No"");
        }
    }
}
"
49,"import java.util.*;

public class Main{
  public static void main(String[] args) {
    Scanner sc=new Scanner(System.in);
    int n=sc.nextInt();
    int a=sc.nextInt();//青
    int b=sc.nextInt();//赤

    int total=a+b;

    int am=n%total;

    int ans;

    if (am>a) {
      ans=n/total*a+a;
    }else{
      ans=n/total*a+am;
    }

    System.out.println(ans);
  }
}
"
50,"import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Main {
  public static void main (String[] args) {
    
   int a,b;
   String str;

   @suppressWarning(""resource"")
   Scanner sc = new Scanner (System.in);
   a=sc.nextInt();
   b=sc.nextInt();
   str=sc.next();    

   Pattern p = Pattern.compile(""^[0-9]{""+a+""}-[0-9]{""+b+""}"");
   Matcher m = p.matcher(str);
   if (m.find()) {
	System.out.println(Yes);
   } else {
 	System.out.println(""No"");
   }

  }
}"
51,"import java.util.*;
public class Main{
  public static void main(String[] args){
    Scanner sc = new Scanner(System.in);
    String s = sc.next();
    int cnt = 0;
    for(int i=3;i<=s.length;i++)
      if(s.substring(i-3,i).equals(""ABC""))cnt++;
    System.out.println(cnt);
  }
}
"
52,"import java.util.*;

public class Main {
    private static HashMap<Integer, List<Integer>> graph;
    public static void main(String[] args) throws Exception{
        Scanner scanner = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int V = scanner.nextInt();
        int E = scanner.nextInt();

        graph = new HashMap<>(V);
        for(int i = 0; i < V; ++i){
            graph.put(i, new LinkedList<>());
        }

        for(int i = 0; i < E; ++i){
            int u = scanner.nextInt();
            int v = scanner.nextInt();
            graph.get(u).add(v);
        }

        boolean[] visited = new boolean[V];

        for(int i = 0; i < V; ++i){
            boolean[] recStack = new boolean[V];
            if(!visited[i] && cyclicUtil(i, visited, recStack)){
                System.out.println(""1"");
                return;
            }
        }

        System.out.println(""0"");
        return;
    }

    private static boolean cyclicUtil(int cur, boolean[] visited, boolean[] recStack){
        visited[cur] = true;
        recStack[cur] = true;

        for(Integer adj : graph.get(cur)){
            if(recStack[adj]){
                return true;
            }
            else if(!visited[adj] && cyclicUtil(adj, visited, recStack)){
                return true;
            }
        }

        recStack[cur] = false;
        return false;
    }
}"
53,"import java.util.Arrays;
import java.util.Scanner;


public class Main {
	Scanner sc=new Scanner(System.in);
	static final int upperlimit=(int) Math.pow(2, 15);
	
	
	private void cal(){
		
		boolean[] values=new boolean[1<<15];
		Arrays.fill(values,true);
		values[0]=false;
		values[1]=false;
		
		for(int i=2;i<1<<15;i++)
		    if(values[i])
			for(int j=2;i*j<1<<15;j++)
			    values[i*j]=false;
				
		
		
		while(true){
			int n=sc.nextInt();
			int count=0;
			
			if(n==0)
				break;
			for(int i=0;i<=n/2;i++)
				if(values[i]&&values[n-i])
					count++;
		
		
		System.out.println(count);
		
		}
		
	}
	
	public static void main(String[] argv){
		new Main().cal();
	}
	
	
	
}"
54,"/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package javaapplication3;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Scanner;

/**
 *
 * @author nai
 */
public class Main {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception{
        // TODO code application logic here
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int A = sc.nextInt();
        int B = sc.nextInt();
        int sum = 0;
        
        for(int i = 1 ; i <= N ; i++){
            int n = i;
            int digSum = 0;
            //合計が条件を満たすことを確認
            while(n > 0){
                digSum += n % 10;
                n /= 10;
            }
            if(A <= digSum && digSum <= B){
                sum += i;
            }
        }
        System.err.println(sum);
    }
  }
    

"
55,"import java.util.*;
import static java.lang.Math.*;

public class Main {
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);

		// 入力
		int n = sc.nextInt();
		int m = sc.nextInt();
		int[][] list = new int[n][2];
	    for(int i = 0; i < n; i++){
	        list[i][0] = sc.nextInt();
	        list[i][1] = sc.nextInt();
		}
		
		// 計算
		int sum = 0;
        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Comparator.reverseOrder());		
        for(int i = 1; i < m + 1; i++){
            for(int j = 0; j < n; j++){
                if(list[j][0] == i) pq.add(list[j][1]);
            }
        
            if(pq.size()>0)sum = sum + pq.poll();
        }

		// 出力
        System.out.println(sum);
		
	}
}
"
56,"
import java.math.BigDecimal;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();
        BigDecimal ans = BigDecimal.ONE;

        for (int i = 0; i < n; i++) {
            ans = ans.multiply(sc.nextBigDecimal());
        }

        if (ans.compareTo(BigDecimal.ONE.scaleByPowerOfTen(18)) <= 0) {
            System.out.println(ans);
        } else {
            System.out.println(-1);
        }

        sc.close();
    }
}"
57,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.PriorityQueue;
import java.util.Scanner;
import java.util.StringTokenizer;

public class Main {
	
	public static class Edge{
		int from, to, dist, cost;

		public Edge(int from, int to, int dist, int cost) {
			super();
			this.from = from;
			this.to = to;
			this.dist = dist;
			this.cost = cost;
		}
	}
	
	public static class Node implements Comparable<Node>{
		int node, dist, price;

		public Node(int node, int dist, int price) {
			super();
			this.node = node;
			this.dist = dist;
			this.price = price;
		}

		@Override
		public int compareTo(Node o) {
			if(this.dist == o.dist){
				return this.price - o.price;
			}else{
				return this.dist - o.dist;
			}
		}
	}
	
	public static final int NODE_MAX = 10000;
	public static final int EDGE_MAX = 20000;
	
	public static void main(String[] args) throws IOException {
		Scanner sc = new Scanner(System.in);
		
		HashMap<Integer, LinkedList<Edge>> edges = new HashMap<Integer, LinkedList<Edge>>();
		
		boolean[] is_visited = new boolean[NODE_MAX];
		
		while(true){
			final int N = sc.nextInt();
			final int M = sc.nextInt();
			
			if(N == 0 && M == 0){
				break;
			}
			
			Arrays.fill(is_visited, false);
			for(LinkedList<Edge> list : edges.values()){
				list.clear();
			}
			
			for(int i = 0; i < M; i++){
				final int u = sc.nextInt() - 1;
				final int v = sc.nextInt() - 1;
				final int d = sc.nextInt();
				final int c = sc.nextInt();
				
				Edge edge_1 = new Edge(u, v, d, c);
				if(!edges.containsKey(u)){
					edges.put(u, new LinkedList<Edge>());
				}
				edges.get(u).add(edge_1);
				
				Edge edge_2 = new Edge(v, u, d, c);
				if(!edges.containsKey(v)){
					edges.put(v, new LinkedList<Edge>());
				}
				edges.get(v).add(edge_2);
			}
			
			PriorityQueue<Node> queue = new PriorityQueue<Node>();
			queue.add(new Node(0, 0, 0));
			
			int sum = 0;
			while(!queue.isEmpty()){
				Node node = queue.poll();
				
				if(is_visited[node.node]){
					continue;
				}else{
					is_visited[node.node] = true;
				}
				
				sum += node.price;
				
				for(Edge edge : edges.get(node.node)){
					final int to = edge.to;
					
					if(is_visited[edge.to]){
						continue;
					}
					
					queue.add(new Node(to, node.dist + edge.dist, edge.cost));
				}
			}
			
			System.out.println(sum);
		}
	}
	
public static class Scanner {
		private BufferedReader br;
		private StringTokenizer tok;
		
		public Scanner(InputStream is) throws IOException{
			br = new BufferedReader(new InputStreamReader(is));
			getLine();
		}
		
		private void getLine() throws IOException{
			while(tok == null || !tok.hasMoreTokens()){
				tok = new StringTokenizer(br.readLine());
			}
		}
		
		private boolean hasNext(){
			return tok.hasMoreTokens();
		}
		
		public String next() throws IOException{
			if(hasNext()){
				return tok.nextToken();
			}else{
				getLine();
				return tok.nextToken();
			}
		}
		
		public int nextInt() throws IOException{
			if(hasNext()){
				return Integer.parseInt(tok.nextToken());
			}else{
				getLine();
				return Integer.parseInt(tok.nextToken());
			}
		}
		
		public long nextLong() throws IOException{
			if(hasNext()){
				return Long.parseLong(tok.nextToken());
			}else{
				getLine();
				return Long.parseLong(tok.nextToken());
			}
		}
		
		public double nextDouble() throws IOException{
			if(hasNext()){
				return Double.parseDouble(tok.nextToken());
			}else{
				getLine();
				return Double.parseDouble(tok.nextToken());
			}
		}
	}

}"
58,"import java.util.Scanner;
public class Main {
	public static void main(String args[]){
		int t=0,i,j,count=0;
		int lim;
		int[] x = new int[30];
		Scanner scan = new Scanner(System.in);
		
		while(scan.hasNextInt()){
			lim = scan.nextInt();
			count = 0;
			if(lim >= 2)count++;
			
			for(i=3;i<=lim;i=i+2){
				for(j=2;j<=lim;j++){
					int k = i % j;
					if(j == i){
						count++;
					}
					if(k == 0)break;
				}
			}
		System.out.println(count);
			x[t] = count;
			t++;
		}
		
		for(int s : x){
			System.out.println(s);
		}
	}
}"
59,"import java.io.*;
import java.util.*;

public class Main {
    //static String probName = ""template"";
    static Comparator<int[]> comp = new Comparator<int[]>() {
        public int compare(int[] a, int[] b) {
            for (int i=0; i<a.length; i++) {
                if (a[i] < b[i])       return -1;
                else if (a[i] > b[i])  return 1;
            }
            return 0;
        }
    };
    static final long LARGE_LONG = 1000000000000000000L;
    static final int LARGE_INT = 1000000007;
    static final int[] dx = new int[] {1, -1, 0, 0};
    static final int[] dy = new int[] {0, 0, 1, -1};
    static int m;
    static int n;
    static char[] s;
    static char[] t;
    static int[][][] lcs;
    //lcs[i][j][0] = length of lcs occuring in s before i and in t before j. [1] is pointer for reconstructing

    public static void main(String[] argst) throws IOException {
        FastReader in = new FastReader();
        // FastReader in = new FastReader(probName + "".in"");
        // Scanner in = new Scanner(System.in);

        // PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(probName + "".out"")));
        PrintWriter out = new PrintWriter(System.out);
        s = in.next().toCharArray();
        t = in.next().toCharArray();
        m = s.length;
        n = t.length;
        lcs = new int[m+1][n+1][2];
        int mx = -1;
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                int pla = -1;
                if (s[i-1] == t[j-1]) {
                    pla = lcs[i-1][j-1][0] + 1;
                    lcs[i][j][0] = pla;
                    lcs[i][j][1] = 1;

                }
                else {
                    int plal = lcs[i-1][j][0];
                    int plar = lcs[i][j-1][0];
                    if (plal > plar) {
                        pla = plal;
                        lcs[i][j][0] = plal;
                        lcs[i][j][1] = 2;
                    }
                    else {
                        pla = plar;
                        lcs[i][j][0] = plar;
                        lcs[i][j][1] = 3;
                    }
                }
                if (pla > mx) {
                    mx = pla;
                }
            }
        }
        int si = 0;
        int sj = 0;
    dumb:
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (lcs[i][j][0] == mx) {
                    si = i;
                    sj = j;
                    break dumb;
                }
            }
        }
        //System.out.println(Arrays.deepToString(lcs));
        ArrayList<Character> ll = new ArrayList<Character>();
        int count = 0;
        while (count < mx) {
            if (lcs[si][sj][1] == 1) {
                ll.add(s[si-1]);
                si--;
                sj--;
                count ++;
            }
            else if (lcs[si][sj][1] == 2) {
                si--;
            }
            else if (lcs[si][sj][1] == 3) {
                sj--;
            }
        }
        int plan = ll.size()-1;
        for (int i = plan; i >= 0; i--) {
            out.print(ll.get(i));
        }
        out.println();
        out.close();
    }

    /* FastReader code from  https://www.geeksforgeeks.org/fast-io-in-java-in-competitive-programming/
       nextLine modified, and added next(), and hasNext()
    */
    static class FastReader {
        final private int BUFFER_SIZE = 1 << 16;
        final private int MAX_LINE_SIZE = 1 << 20;
        private DataInputStream din;
        private byte[] buffer, lineBuf;
        private int bufferPointer, bytesRead;

        public FastReader() {
            din = new DataInputStream(System.in);
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }
        public FastReader(String file_name) throws IOException {
            din = new DataInputStream(new FileInputStream(file_name));
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }
        public boolean hasNext() throws IOException {
            byte c;
            while ((c = read()) != -1) {
                if (c > ' ') {
                    bufferPointer--;
                    return true;
                }
            }
            return false;
        }
        public String nextLine() throws IOException {
            if (lineBuf == null)	lineBuf = new byte[MAX_LINE_SIZE];
            int ctr = 0;
            byte c;
            while ((c = read()) != -1) {
                if (c == '\r')        continue;
                if (c == '\n')        break;
                lineBuf[ctr++] = c;
            }
            return new String(lineBuf, 0, ctr);
        }
        public String next() throws IOException {
            if (lineBuf == null)	lineBuf = new byte[MAX_LINE_SIZE];
            int ctr = 0;
            byte c = read();
            while (c <= ' ')  	c = read();
            while (c > ' ') {
                lineBuf[ctr++] = c;
                c = read();
            }
            return new String(lineBuf, 0, ctr);
        }
        public int nextInt() throws IOException {
            int ret = 0;
            byte c = read();
            while (c <= ' ')   c = read();
            boolean neg = (c == '-');
            if (neg)           c = read();
            do {
                ret = ret * 10 + c - '0';
            } while ((c = read()) >= '0' && c <= '9');

            if (neg)           return -ret;
            return ret;
        }
        public long nextLong() throws IOException {
            long ret = 0;
            byte c = read();
            while (c <= ' ')    c = read();
            boolean neg = (c == '-');
            if (neg)            c = read();
            do {
                ret = ret * 10 + c - '0';
            } while ((c = read()) >= '0' && c <= '9');
            if (neg)            return -ret;
            return ret;
        }
        public double nextDouble() throws IOException {
            double ret = 0, div = 1;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)  	c = read();
            do {
                ret = ret * 10 + c - '0';
            }
            while ((c = read()) >= '0' && c <= '9');
            if (c == '.') {
                while ((c = read()) >= '0' && c <= '9') {
                    ret += (c - '0') / (div *= 10);
                }
            }
            if (neg)     return -ret;
            return ret;
        }
        private void fillBuffer() throws IOException {
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
            if (bytesRead == -1)
                buffer[0] = -1;
        }
        private byte read() throws IOException {
            if (bufferPointer == bytesRead)     fillBuffer();
            return buffer[bufferPointer++];
        }
        public void close() throws IOException {
            if (din == null) 	   return;
            din.close();
        }
    }
}

"
60,"import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.NoSuchElementException;

public class Main {

    public static void main(String[] args) {
        PrintWriter out = new PrintWriter(System.out);
        FastScanner sc = new FastScanner();
        StringBuilder sb = new StringBuilder();
        long mod = 1000000007;
        int N = sc.nextInt();
        int K = sc.nextInt();

        long[][] combination = new long[N+2][];

        combination[0] = new long[1];
        combination[0][0] = 1;

        combination[1] = new long[2];
        combination[1][0] = 1;
        combination[1][1] = 1;

        for (int i = 2; i< N+2 ; i++ ){
            combination[i] = new long[i+1];
            combination[i][0] = 1;
            combination[i][i] = 1;
            for (int j=1; j<i; j++) {
                combination[i][j] = (combination[i-1][j-1] + combination[i-1][j]) % mod;
            }
        }

        long A = (N - K + 1) % mod;
        sb.append(A);
        sb.append(""\n"");
        for (int i=2; i<=K; i++) {
            if(N-K+1 < i) {
                sb.append(0);
                sb.append(""\n"");
                continue;
            }
            A = (combination[N-K+1][i] * combination[K-1][i-1]) % mod;
            sb.append(A);
            sb.append(""\n"");
        }
        out.println(sb.toString());
        out.flush();
    }
}

class FastScanner {
    private final InputStream in = System.in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}
    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}
    public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}
    public String next() {
        if (!hasNext()) throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
    public long nextLong() {
        if (!hasNext()) throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while(true){
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() { return Double.parseDouble(next());}
}"
61,"import java.util.*;
import java.io.*;

public class Main{
  final static private int MAX_DATA_COUNT = 10;
  public static void main(String[] args) throws java.io.IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    Integer[] mountainsHeightArr = new Integer[10];
    for (int i=0; i<MAX_DATA_COUNT; i++)
      mountainsHeightArr[i] = Integer.parseInt(br.readLine());
    Arrays.sort(mountainsHeightArr, Collections.reverseOrder());
    for (int i=0; i<3; i++)
      System.out.println(mountainsHeightArr[i]);
  }
}"
62,"import java.util.*;
public class Main {
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
      	
      	int[] a = new int[n];
      	int min = 0;
      	int count = 1;
        for(int i = 0; i < a.length; ++i){
          a[i] = sc.nextInt();
        } 
        min = a[0];
      	for(int i = 0; i <n; i++){
          if(min > a[i]){
            min = a[i];
            count += 1; 
          }
        } 
      system.out.println(count);
        
        }
}
"
63,"import java.util.*;
import static java.lang.Math.*;

public class Main {
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);

		// 入力
		String s = sc.next();// 文字列

		// チェック
		String result = """";

		if(check(s)){
			result = ""YES"";
		}else{
			result = ""NO"";
		}

		// 出力
		System.out.println(result);
	}

	static boolean check(String s){

		// 定数
		String a  = ""dream"";
		String b  = ""dreamer"";
		String c  = ""erase"";
		String d  = ""eraser"";

		if(s.equals(a) || s.equals(b) || s.equals(c) || s.equals(d)){
			return true;
		}
		if(s.startsWith(a)){
			if(check(s.substring(a.length()))){
				return true;
			}
			if(check(s.substring(a.length() + 2))){
				return true;
			}
		}
		if(s.startsWith(c)){
			if(check(s.substring(c.length()))){
				return true;
			}
			if(check(s.substring(c.length() + 1))){
				return true;
			}
		}
		return false;
	}

}


"
64,"import java.util.Scanner;

public class Main{
	public static void main(String args[]){
		Scanner scan = new Scanner(System.in);

		long n = scan.nextLong();
		long power = 1;

		for(int i = 1; i <= n; i++){
			power *= i;
			power %= 1000000007
		}
		System.out.println(power);
	}
}
"
65,"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Map;
import java.util.Scanner;
import java.util.HashMap;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author ZYCSwing
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        Scanner in = new Scanner(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskD solver = new TaskD();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskD {
        Map<Integer, Integer> map;
        int[][] a;
        int[][] dp;

        public void solve(int testNumber, Scanner in, PrintWriter out) {
            map = new HashMap<>();
            int h = in.nextInt(), w = in.nextInt(), d = in.nextInt();
            a = new int[h][w];
            dp = new int[h * w + 1][17];

            for (int i = 0; i < h; ++i)
                for (int j = 0; j < w; ++j) {
                    a[i][j] = in.nextInt();
                    map.put(a[i][j], i * w + j);
                }

            for (int val = 1; val + d <= h * w; ++val) {
                int x = map.get(val) / w;
                int y = map.get(val) % w;
                int xx = map.get(val + d) / w;
                int yy = map.get(val + d) % w;
                dp[val][0] = Math.abs(x - xx) + Math.abs(y - yy);
            }

            for (int i = 1; i < 17; ++i) {
                for (int val = 1; val + (1 << i) * d <= h * w; ++val) {
                    dp[val][i] = dp[val][i - 1] + dp[val + (1 << (i - 1)) * d][i - 1];
                }
            }

            int q = in.nextInt();

            int l, r;
            for (int i = 0; i < q; ++i) {
                l = in.nextInt();
                r = in.nextInt();

                int diff = r - l;
                int step = diff / d;
                int res = 0;
                int cur = l;

                for (int j = 16; j >= 0; --j) {
                    if (((1 << j) & step) != 0) {
                        res += dp[cur][j];
                        cur = cur + (1 << j) * d;
                    }
                }
                out.println(res);
            }
        }

    }
}

"
66,"import java.util.*;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        long N = sc.nextLong();

        List<Integer> factors = primeFactor(N);

        int count =0;
        for (int pow : factors){
            int increase=1;
            while(pow-increase>=0){
                pow -= increase;
                increase++;
                count++;
            }
        }


        System.out.println(count);
    }

    static List<Integer> primeFactor(long N){

        List<Integer> res = new ArrayList<>();

        for (int i = 2; i*i <=N ; i++) {
            int count =0;
            while(N%i==0){
                N /= i;
                count++;
            }
            if(count!=0)
            res.add(count);
        }
        if(N!=1){
            res.add(1);
        }
        return res;
   }


}"
67,"import java.io.*;
import java.util.*;

class Main {

    private static PrintWriter out;

    private static <T> void mprintln(T... ar) {
        for (T i : ar) {
            out.print(i + "" "");
        }
        out.println();
    }

    public static void main(String[] args) throws FileNotFoundException {

        // Input from file
        // File inputFile = new File(""JavaFile.txt"");
        // File outputFile = new File(""JavaOutputFile.txt"");
        // FileReader fileReader = new FileReader(inputFile);
        // Here it ends

        MyScanner sc = new MyScanner();
        // MyScanner sc = new MyScanner(fileReader);

        out = new PrintWriter(new BufferedOutputStream(System.out)); // Output to console
        // out = new PrintWriter(new PrintStream(outputFile)); // Output to file

        getAns(sc);

        out.close();
    }

    /*
     *Don't use builtin function (Math.ceil)
     */

    static final long MOD = (long) (1e9 + 7);

    private static void getAns(MyScanner sc) {
        int n = sc.ni();
        int[] ar = sc.niArr1(n);

        LinkedList<Integer> list = new LinkedList<>();
        for (int i = n; i >= 1; i--){
            int total = 0;
            for (int j = i; j <= n; j += i) total += br[j];
            if (total % 2 != ar[i]){
                br[i] = 1;
                list.addFirst(i);
            }
        }

        out.println(list.size());
        list.forEach(k -> out.print(k + "" ""));
    }

    static class MyScanner {

        BufferedReader br;
        StringTokenizer st;

        MyScanner(FileReader fileReader) {
            br = new BufferedReader(fileReader);
        }

        MyScanner() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        String nn() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        String nextLine() {
            String ans = """";
            try {
                ans = br.readLine();
            } catch (IOException ex) {
                ex.printStackTrace();
            }
            return ans;
        }

        char nc() {
            return nn().charAt(0);
        }

        int ni() {
            return Integer.parseInt(nn());
        }

        long nl() {
            return Long.parseLong(nn());
        }

        double nd() {
            return Double.parseDouble(nn());
        }

        int[] niArr0(int n) {
            int[] ar = new int[n];
            for (int i = 0; i < n; i++) {
                ar[i] = ni();
            }
            return ar;
        }

        int[] niArr1(int n) {
            int[] ar = new int[n + 1];
            for (int i = 1; i <= n; i++) {
                ar[i] = ni();
            }
            return ar;
        }

        long[] nlArr0(int n) {
            long[] ar = new long[n];
            for (int i = 0; i < n; i++) {
                ar[i] = nl();
            }
            return ar;
        }

        long[] nlArr1(int n) {
            long[] ar = new long[n + 1];
            for (int i = 1; i <= n; i++) {
                ar[i] = nl();
            }
            return ar;
        }
    }
}"
68,"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.List;
import java.util.Queue;

public class Main {
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String[] sa = br.readLine().split("" "");
		int n = Integer.parseInt(sa[0]);
		int m = Integer.parseInt(sa[1]);
		List<List<Hen>> list = new ArrayList<>(n);
		for (int i = 0; i < n; i++) {
			list.add(new ArrayList<>());
		}
		for (int i = 0; i < m; i++) {
			sa = br.readLine().split("" "");
			Hen h = new Hen();
			h.u = Integer.parseInt(sa[0]) - 1;
			h.v = Integer.parseInt(sa[1]) - 1;
			h.s = Integer.parseInt(sa[2]);
			list.get(h.u).add(h);
			list.get(h.v).add(h);
		}
		br.close();

		Queue<Integer> que = new ArrayDeque<>();
		long min = 1;
		long max = Integer.MAX_VALUE;
		Long[] x = new Long[n];
		Long[] y = new Long[n];
		x[0] = 0L;
		que.add(0);
		while (!que.isEmpty()) {
			int cur = que.poll();
			for (Hen h : list.get(cur)) {
				int next = h.u;
				if (next == cur) {
					next = h.v;
				}
				if (x[cur] != null) {
					long alt = h.s - x[cur];
					if (y[next] == null) {
						y[next] = alt;
						max = Math.min(max, alt - 1);
						que.add(next);
					} else if (y[next] != alt) {
						System.out.println(0);
						return;
					}
				}
				if (y[cur] != null) {
					long alt = h.s - y[cur];
					if (x[next] == null) {
						x[next] = alt;
						min = Math.max(min, -alt + 1);
						que.add(next);
					} else if (x[next] != alt) {
						System.out.println(0);
						return;
					}
				}
				if (x[next] != null && y[next] != null) {
					long val = y[next] - x[next];
					if (val % 2 != 0) {
						System.out.println(0);
					} else {
						System.out.println(val / 2);
					}
					return;
				}
			}
		}
		System.out.println(Math.max(max - min + 1, 0));
		throw new Exception();
	}

	static class Hen {
		int u, v, s;
	}
}
"
69,"public class Main {
	public static void main(String[] args){
		java.util.Scanner scan = new java.util.Scanner(System.in);
			String str = scan.nextLine();
			scan.useDelimiter(""//n"");
			char[] arr = new char[1200];
			String str2 =""abcdefghijklmnopqrstuvwxyz"";
			char[] arr2 = str2.toCharArray();
			int[] line = new int[26];

			do{
				arr = str.toCharArray();

				for(int i = 0;i <arr.length;i++){
					if(Character.isUpperCase(arr[i])){
						arr[i] = Character.toLowerCase(arr[i]);
					}
					for(int j = 0; j< 26;j++){
						if(arr[i] == arr2[j]){
							line[j]++;
						}
					}
				}
			}while(scan.hasNext());
		for(int i = 0;i < 26;i++){
			System.out.println(arr2[i] + "" : "" +line[i]);
		}
	}

}"
70,"import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ
		Scanner scanner = new Scanner(System.in);
		int sx = scanner.nextInt();
		int sy = scanner.nextInt();
		int tx = scanner.nextInt();
		int ty = scanner.nextInt();

		String result = """";
		// 1回目
		for(int i = 0; i < ty - sy; i++){
			result += ""U"";
		}
		for(int i = 0; i < tx - sx; i++){
			result += ""R"";
		}

		for(int i = 0; i < ty - sy; i++){
			result += ""D"";
		}
		for(int i = 0; i < tx - sx; i++){
			result += ""L"";
		}
		/// 2回目
		result += ""L"";
		for(int i = 0; i < ty - sy; i++){
			result += ""U"";
		}
		result += ""U"";
		for(int i = 0; i < tx - sx; i++){
			result += ""R"";
		}
		result += ""RDR"";

		for(int i = 0; i < ty - sy; i++){
			result += ""D"";
		}
		result += ""D"";
		for(int i = 0; i < tx - sx; i++){
			result += ""L"";
		}
		result += ""LU"";

		System.out.println(result);

	}

}
"
71,"import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

public class Main {

	static PrintWriter out;
	static InputReader ir;

	static void solve() {
		int m=ir.nextInt();
		int n=ir.nextInt();
		char[][] map=ir.nextCharMap(n, m);
		String[][] dp=new String[n][m];
		String ret="""";
		for(int i=0;i<n;i++){
			for(int j=0;j<m;j++){
				if(map[i][j]>='A'&&map[i][j]<='Z')
					continue;
				dp[i][j]=Character.toString(map[i][j]);
				for(int k=0;k<2;k++){
					int nx=i+(k&1);
					int ny=j+((k&1)^1);
					if(nx>=0&&nx<n&&ny>=0&&ny<m&&map[nx][ny]>='A'&&map[nx][ny]<='Z')
						continue;
					dp[i][j]=max(dp[i][j],Character.toString(map[i][j])+dp[nx][ny]);
				}
				ret=max(ret,dp[i][j]);
			}
		}
		out.println(ret);
	}

	static String max(String a,String b){
		if(a.length()>b.length())
			return a;
		if(a.length()<b.length())
			return b;
		for(int i=0;i<a.length();i++){
			if(a.charAt(i)>b.charAt(i))
				return a;
			if(a.charAt(i)<b.charAt(i))
				return b;
		}
		return a;
	}
	
	public static void main(String[] args) throws Exception {
		ir = new InputReader(System.in);
		out = new PrintWriter(System.out);
		solve();
		out.flush();
	}

	static class InputReader {

		private InputStream in;
		private byte[] buffer = new byte[1024];
		private int curbuf;
		private int lenbuf;

		public InputReader(InputStream in) {
			this.in = in;
			this.curbuf = this.lenbuf = 0;
		}

		public boolean hasNextByte() {
			if (curbuf >= lenbuf) {
				curbuf = 0;
				try {
					lenbuf = in.read(buffer);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (lenbuf <= 0)
					return false;
			}
			return true;
		}

		private int readByte() {
			if (hasNextByte())
				return buffer[curbuf++];
			else
				return -1;
		}

		private boolean isSpaceChar(int c) {
			return !(c >= 33 && c <= 126);
		}

		private void skip() {
			while (hasNextByte() && isSpaceChar(buffer[curbuf]))
				curbuf++;
		}

		public boolean hasNext() {
			skip();
			return hasNextByte();
		}

		public String next() {
			if (!hasNext())
				throw new NoSuchElementException();
			StringBuilder sb = new StringBuilder();
			int b = readByte();
			while (!isSpaceChar(b)) {
				sb.appendCodePoint(b);
				b = readByte();
			}
			return sb.toString();
		}

		public int nextInt() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			int res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public long nextLong() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			long res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public double nextDouble() {
			return Double.parseDouble(next());
		}

		public int[] nextIntArray(int n) {
			int[] a = new int[n];
			for (int i = 0; i < n; i++)
				a[i] = nextInt();
			return a;
		}

		public long[] nextLongArray(int n) {
			long[] a = new long[n];
			for (int i = 0; i < n; i++)
				a[i] = nextLong();
			return a;
		}

		public char[][] nextCharMap(int n, int m) {
			char[][] map = new char[n][m];
			for (int i = 0; i < n; i++)
				map[i] = next().toCharArray();
			return map;
		}
	}
}

"
72,"import java.util.Scanner;
  Scanner scan = new Scanner(System.in);
   
  System.out.print(""開始時刻"");
  float a = scan.nextFloat();
  System.out.print(""経過時間"");
  float b = scan.nextFloat();
  scan.close();

  System.out.println(""終了時間は"" + (a + b) + ""時です""); 
"
73,"import java.awt.Point;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.StringTokenizer;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.PriorityQueue;
import java.util.TreeMap;
public class Main
{
    static class Scanner
    {
        BufferedReader br;
        StringTokenizer tk=new StringTokenizer("""");
        public Scanner(InputStream is) 
        {
            br=new BufferedReader(new InputStreamReader(is));
        }
        public int nextInt() throws IOException
        {
            if(tk.hasMoreTokens())
                return Integer.parseInt(tk.nextToken());
            tk=new StringTokenizer(br.readLine());
            return nextInt();
        }
        public long nextLong() throws IOException
        {
            if(tk.hasMoreTokens())
                return Long.parseLong(tk.nextToken());
            tk=new StringTokenizer(br.readLine());
            return nextLong();
        }
        public String next() throws IOException
        {
            if(tk.hasMoreTokens())
                return (tk.nextToken());
            tk=new StringTokenizer(br.readLine());
            return next();
        }
        public String nextLine() throws IOException
        {
            tk=new StringTokenizer("""");
            return br.readLine();
        }
        public double nextDouble() throws IOException
        {
            if(tk.hasMoreTokens())
                return Double.parseDouble(tk.nextToken());
            tk=new StringTokenizer(br.readLine());
            return nextDouble();
        }
        public char nextChar() throws IOException
        {
            if(tk.hasMoreTokens())
                return (tk.nextToken().charAt(0));
            tk=new StringTokenizer(br.readLine());
            return nextChar();
        }
        public int[] nextIntArray(int n) throws IOException
        {
            int a[]=new int[n];
            for(int i=0;i<n;i++)
                a[i]=nextInt();
            return a;
        }
        public long[] nextLongArray(int n) throws IOException
        {
            long a[]=new long[n];
            for(int i=0;i<n;i++)
                a[i]=nextLong();
            return a;
        }
        public int[] nextIntArrayOneBased(int n) throws IOException
        {
            int a[]=new int[n+1];
            for(int i=1;i<=n;i++)
                a[i]=nextInt();
            return a;
        }
        public long[] nextLongArrayOneBased(int n) throws IOException
        {
            long a[]=new long[n+1];
            for(int i=1;i<=n;i++)
                a[i]=nextLong();
            return a;
        }
    
    
    }
    public static void main(String args[]) throws IOException
    {
        new Thread(null, new Runnable() {
            public void run() {
                try
                {
                    solve();
                }
                catch(Exception e)
                {
                    e.printStackTrace();
                }
            }
        }, ""1"", 1 << 26).start();
        
    }
    static class Pair{
        long x;
        int y;
        Pair(long a,int b){
            x=a;y=b;
        }
    }
    static ArrayList<Point> g[];
    static int d[];
    static boolean vis[];
    static HashMap<Integer, HashMap<Integer, Integer>> gg;
    static int tt=0;
    static int ensure(int u, int c){
        if(!gg.containsKey(u)){
            gg.put(u, new HashMap<>());
        }
        if(!gg.get(u).containsKey(c)){
            gg.get(u).put(c,tt);
            d[tt]=Integer.MAX_VALUE;
            g[tt]=new ArrayList<>();
            return tt++;
        }
        return gg.get(u).get(c);
    }
    static void addEdge(int u,int v,int c){
        
        int u0=ensure(u,0);
        int v0=ensure(v,0);
        int uc=ensure(u,c);
        int vc=ensure(v,c);
        addEdgeInternal(u0, uc, 1);
        addEdgeInternal(v0, vc, 1);
        addEdgeInternal(uc, vc, 0);
    }
    static void addEdgeInternal(int u, int v, int wt){
        g[u].add(new Point(v,wt));
        g[v].add(new Point(u, wt));
    }
    static void solve() throws IOException
    {
        Scanner in=new Scanner(System.in);
        PrintWriter out=new PrintWriter(System.out);
        int n=in.nextInt();
        int m=in.nextInt();
        gg=new HashMap<>();
        g=new ArrayList[1000100];
        d=new int[1000100];
        vis=new boolean[1000100];
        for(int i=0;i<m;i++){
            int u=in.nextInt();
            int v=in.nextInt();
            int c=in.nextInt();
            addEdge(u, v, c);
        }
        int o0=ensure(1,0);
        int n0=ensure(n,0);
        
        d[o0]=0;
        PriorityQueue<Point> pq=new PriorityQueue<>((a,b)->Integer.compare(a.y, b.y));
        pq.add(new Point(o0,0));
        while(!pq.isEmpty()){
            Point nd=pq.poll();
            if(vis[nd.x])
                continue;
            vis[nd.x]=true;
            for(Point edg:g[nd.x]){
                int nextWeight=nd.y+edg.y;
                if(nextWeight<d[edg.x]){
                    d[edg.x]=nextWeight;
                    
                    pq.add(new Point(edg.x, nextWeight));
                }
            }
        }
        out.println((d[n0]==Integer.MAX_VALUE)?-1:(d[n0]/2));
        out.close();
        
    }
}
"
74,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;


public class Main {
    public static void main(String[] args) throws IOException{


        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String word = br.readLine();
        String key = br.readLine();
        word = word + word;

        if(bmStringSearch(word,key)){
        	System.out.println(""Yes"");
        }else{
        	System.out.println(""No"");
        }

    }

    private static boolean bmStringSearch(String word, String key){
    	 int[] table = new int[Character.MAX_VALUE];

         for(int i=0;i<table.length;i++){
         	table[i] = key.length();
         }
         for(int i=0;i<key.length();i++){
         	table[key.charAt(i)] = key.length() - i - 1;
         }

         int wordIndex = key.length() - 1;
         int checkWordLength = word.length() + key.length();
         while(wordIndex < checkWordLength){
         	int keyIndex = key.length() -1;

         	while(word.charAt(wordIndex) == key.charAt(keyIndex)){
         		if(keyIndex == 0){
         			return true;
         		}
         		wordIndex--;
         		keyIndex--;
         	}

         	if(table[word.charAt(wordIndex)] > key.length()-keyIndex){
         		wordIndex += table[word.charAt(wordIndex)];
         	}else{
         		wordIndex += key.length() - keyIndex;
         	}
         }

         return false;
    }


}"
75,"import java.io.*;
import java.util.ArrayList;
public class Main{
    public static void main(String[] args) throws IOException{
	BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
	int n = Integer.parseInt(reader.readLine());
	ArrayList<Integer> list = new ArrayList<Integer>();
	String[] input;
	String command;
	for (int i = 0; i < n; i++) {
	    input  = reader.readLine().split("" "");
	    command = input[0];
	    switch (command) {
	    case ""insert"":
		list.add(0, Integer.parseInt(input[1]));
		break;
	    case ""delete"":
		int index = list.indexOf(Integer.parseInt(input[1]));
		if(index != -1){
		    list.remove(index);
		}
		break;
	    case ""deleteFirst"":
		list.remove(0);
		break;
	    case ""deleteLast"":
		list.remove(list.size() - 1);
		break;
	    }
	}
	for (int i = 0; i < list.size() - 1; i++) {
	    System.out.print(list.get(i) + "" "");
	}
	System.out.println(list.get(list.size() - 1));
    }
}"
76,"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.HashMap;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Objects;
import java.util.StringTokenizer;
import java.util.Map;
import java.util.Map.Entry;
import java.io.BufferedReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author AnandOza
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        EBullet solver = new EBullet();
        solver.solve(1, in, out);
        out.close();
    }

    static class EBullet {
        NumberTheory.Mod107 m = new NumberTheory.Mod107();

        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int n = in.nextInt();

            HashMap<Point, Integer> count = new HashMap<>();
            int zero = 0;
            for (int i = 0; i < n; i++) {
                Point p = new Point(in.nextLong(), in.nextLong());
                if (p.equals(Point.zero())) {
                    zero++;
                    continue;
                }
                p = p.reduceAng();
                count.merge(p, 1, Integer::sum);
            }

            long answer = 1;
            for (Map.Entry<Point, Integer> e : count.entrySet()) {
                if (e.getKey().x <= 0 && count.containsKey(new Point(e.getKey().y, -e.getKey().x)))
                    continue;

                Point o = new Point(-e.getKey().y, e.getKey().x);
                answer = m.mult(answer, m.add(m.pow(2, count.getOrDefault(o, 0)), m.pow(2, e.getValue()), -1));
            }

            answer = m.add(answer, zero);
            answer = m.subtract(answer, 1);

            out.println(answer);
        }

    }

    static class NumberTheory {
        public static long gcd(long a, long b) {
            a = Math.abs(a);
            b = Math.abs(b);
            long c;
            while (a != 0) {
                c = a;
                a = b % a;
                b = c;
            }
            return b;
        }

        private static void ASSERT(boolean assertion) {
            if (!assertion)
                throw new AssertionError();
        }

        public abstract static class Modulus<M extends NumberTheory.Modulus<M>> {
            ArrayList<Long> factorial = new ArrayList<>();
            ArrayList<Long> invFactorial = new ArrayList<>();

            public abstract long modulus();

            public Modulus() {
                super();
                factorial.add(1L);
                invFactorial.add(1L);
            }

            public long normalize(long x) {
                x %= modulus();
                if (x < 0)
                    x += modulus();
                return x;
            }

            public long add(long... x) {
                long r = 0;
                for (long i : x)
                    r = add(r, i);
                return r;
            }

            public long add(long a, long b) {
                long v = a + b;
                return v < modulus() ? v : v - modulus();
            }

            public long subtract(long a, long b) {
                long v = a - b;
                return v < 0 ? v + modulus() : v;
            }

            public long mult(long a, long b) {
                return (a * b) % modulus();
            }

            public long pow(long x, int e) {
                if (e < 0) {
                    x = inv(x);
                    e *= -1;
                }
                if (e == 0)
                    return 1;
                if ((e & 1) > 0)
                    return mult(x, pow(x, e - 1));
                return pow(mult(x, x), e / 2);
            }

            public long inv(long value) {
                long g = modulus(), x = 0, y = 1;
                for (long r = value; r != 0; ) {
                    long q = g / r;
                    g %= r;

                    long temp = g;
                    g = r;
                    r = temp;

                    x -= q * y;

                    temp = x;
                    x = y;
                    y = temp;
                }

                ASSERT(g == 1);
                ASSERT(y == modulus() || y == -modulus());

                return normalize(x);
            }

        }

        public static class Mod107 extends NumberTheory.Modulus<NumberTheory.Mod107> {
            public long modulus() {
                return 1_000_000_007L;
            }

        }

    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

    }

    static class Point implements Comparable<Point> {
        public long x;
        public long y;

        public Point(long x, long y) {
            this.x = x;
            this.y = y;
        }

        public static Point zero() {
            return new Point(0, 0);
        }

        public Point reduceAng() {
            long x = this.x;
            long y = this.y;
            if (y < 0) {
                x *= -1;
                y *= -1;
            }
            if (y == 0 && x < 0) {
                x *= -1;
            }
            long g = NumberTheory.gcd(x, y);
            x /= g;
            y /= g;
            return new Point(x, y);
        }

        public String toString() {
            return String.format(""(%d, %d)"", x, y);
        }

        public boolean equals(Object o) {
            if (this == o)
                return true;
            if (o == null || getClass() != o.getClass())
                return false;
            Point point = (Point) o;
            return x == point.x && y == point.y;
        }

        public int hashCode() {
            return Objects.hash(x, y);
        }

        public int compareTo(Point o) {
            int ret = Long.compare(x, o.x);
            if (ret != 0)
                return ret;
            return Long.compare(y, o.y);
        }

    }
}

"
77,"import java.util.Scanner;

public class Main {
 public static void main(String[] args) {
  Scanner sc = new Scanner(System.in);
  int n = sc.nextInt();
  int i;
  for(i = 1;i <= n;i++){
   for(int m=0;Math.pow(10,m) < i;m++){
    i= i/(Math.pow(10,m));
    if (i%3 == 0) {
     System.out.printf("" "" + i);
    }else if(i%10 == 3){
     System.out.printf("" "" + i);
    }else if(i > 10){
     int x = i;
    }
   }
  }
 System.out.println("""");
 }
}"
78,"
import java.util.Scanner;

public class Main {
    static Scanner sc = new Scanner(System.in);


    public static void main(String[] args) {
        long n = sc.nextLong();
        long sum = 0;
        for (int i = 1; i < n; i++) {
            sum += i;
        }
        System.out.println(sum);
    }
}
"
79,"

import java.util.*;
public class Main {
	//1330 start
	//1430 cording end
	//1510 sample matched RE
	//1510 stop
	// restart
	//0206 TLE
	//0228 MLE
	//0230 MLE modified continue to break

	class C{
		int step;
		StringBuilder [] list;
		public C(int step, StringBuilder[] list) {
			this.step = step;
			this.list = list;
		}

	}

	private void doit(){
		Scanner sc =new Scanner(System.in);
		while(true){
			int x = sc.nextInt(), y = sc.nextInt();
			if((x|y) == 0) break;
			char [][] data = new char[y][4];
			for(int i = 0 ; i < y; i++){
				String s = sc.next();
				data[i][0] = s.charAt(0);
				data[i][1] = s.charAt(1);
				s = sc.next();

				data[i][2] = s.charAt(0);
				data[i][3] = s.charAt(1);
			}
			String [] start = new String[x];
			String [] goal = new String[x];
			for(int i = 0; i < 2; i++){
				for(int j = 0; j < x;j++){
					if(i == 0){
						start[j] = sc.next();
						if(start[j].equals(""-"")){
							start[j] = """";
						}
					}
					else{
						goal[j] = sc.next();
						if(goal[j].equals(""-"")){
							goal[j] = """";
						}
					}
				}
			}

			LinkedList<C> open = new LinkedList<C>();
			StringBuilder [] openlist = new StringBuilder[x];
			for(int i = 0; i < x; i++){
				openlist[i] = new StringBuilder(start[i]);
			}
			open.add(new C(0, openlist));
			HashMap<String , Integer> close = new HashMap<String, Integer>();
			close.put(tostr(openlist), 0);
			String goalstr = tostr2(goal);
			int ans = -1;
			while(! open.isEmpty()){
				C now = open.removeFirst();
				//System.out.println(""step = "" + now.step);
				if(tostr(now.list).equals(goalstr)){
					ans = now.step;
					break;
				}
				if(now.step == 3) break;

				for(int i = 0; i < y; i++){
					int num1 = data[i][0] - '0';
					int num2 = data[i][2] - '0';
					char op1 = data[i][1];
					char op2 = data[i][3];

					if(op1 == 'W' && op2 == 'W'){
						//from to
						for(int j = 0; j < now.list[num1].length(); j++){

							String temp = now.list[num1].substring(0, j + 1);
							StringBuilder move = new StringBuilder(temp);
							move.reverse();

							StringBuilder [] work = deepcopy(now.list);
							work[num1].delete(0, j + 1);
							work[num2].insert(0, move.toString());
							String nextstr = tostr(work);
							if(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){
								continue;
							}
							open.add(new C(now.step + 1, work));
							close.put(nextstr, now.step + 1);
						}

						//to from
						for(int j = 0; j < now.list[num2].length(); j++){
							String temp = now.list[num2].substring(0, j + 1 );
							StringBuilder move = new StringBuilder(temp);
							move.reverse();

							StringBuilder [] work = deepcopy(now.list);
							work[num2].delete(0, j + 1);
							work[num1].insert(0, move.toString());
							String nextstr = tostr(work);
							if(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){
								continue;
							}
							open.add(new C(now.step + 1, work));
							close.put(nextstr, now.step + 1);
						}
					}
					else if(op1 == 'W' && op2 == 'E'){
						//from to
						for(int j = 0; j < now.list[num1].length(); j++){
							String temp = now.list[num1].substring(0, j + 1);
							StringBuilder move = new StringBuilder(temp);

							StringBuilder [] work = deepcopy(now.list);
							work[num1].delete(0, j + 1);
							work[num2].append(move.toString());
							String nextstr = tostr(work);
							if(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){
								continue;
							}
							open.add(new C(now.step + 1, work));
							close.put(nextstr, now.step + 1);
						}

						//to from
						for(int j =0; j < now.list[num2].length(); j++){
							int len = now.list[num2].length();
							String temp = now.list[num2].substring(len - j - 1, len);
							StringBuilder move = new StringBuilder(temp);

							StringBuilder [] work = deepcopy(now.list);
							work[num2].delete(len-j - 1, len);
							work[num1].insert(0, move.toString());
							String nextstr = tostr(work);
							if(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){
								continue;
							}
							open.add(new C(now.step + 1, work));
							close.put(nextstr, now.step + 1);
						}
					}
					else if(op1 == 'E' && op2 == 'W'){
						//from to
						for(int j = 0; j < now.list[num1].length(); j++){
							int len = now.list[num1].length();
							String temp = now.list[num1].substring(len - j - 1, len);
							StringBuilder move = new StringBuilder(temp);

							StringBuilder [] work = deepcopy(now.list);
							work[num1].delete(len-j - 1, len);
							work[num2].insert(0,move.toString());
							String nextstr = tostr(work);
							if(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){
								continue;
							}
							open.add(new C(now.step + 1, work));
							close.put(nextstr, now.step + 1);
						}

						//to from
						for(int j = 0; j < now.list[num2].length(); j++){
							String temp = now.list[num2].substring(0, j+1);
							StringBuilder move = new StringBuilder(temp);

							StringBuilder [] work = deepcopy(now.list);
							work[num2].delete(0, j+1);
							work[num1].append(move.toString());
							String nextstr = tostr(work);
							if(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){
								continue;
							}
							open.add(new C(now.step + 1, work));
							close.put(nextstr, now.step + 1);
						}
					}
					else{
						// E, E
						//from to
						for(int j = 0; j < now.list[num1].length(); j++){
							int len = now.list[num1].length();
							String temp = now.list[num1].substring(len - j-1, len);
							StringBuilder move = new StringBuilder(temp);
							move.reverse();

							StringBuilder [] work = deepcopy(now.list);
							work[num1].delete(len-j-1, len);
							work[num2].append(move.toString());
							String nextstr = tostr(work);
							if(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){
								continue;
							}
							open.add(new C(now.step + 1, work));
							close.put(nextstr, now.step + 1);
						}

						//to from
						for(int j = 0; j < now.list[num2].length(); j++){
							int len = now.list[num2].length();
							String temp = now.list[num2].substring(len - j-1, len);
							StringBuilder move = new StringBuilder(temp);
							move.reverse();

							StringBuilder [] work = deepcopy(now.list);
							work[num2].delete(len-j - 1, len);
							work[num1].append(move.toString());
							String nextstr = tostr(work);
							if(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){
								continue;
							}
							open.add(new C(now.step + 1, work));
							close.put(nextstr, now.step + 1);
						}
					} //ifend
				} //end i
			}//end while

			//答えが出ているなら出力
			if(ans!= -1){
				System.out.println(ans);
				continue;
			}

			//両側探索する
			LinkedList<C> open2 = new LinkedList<C>();
			StringBuilder [] openlist2 = new StringBuilder[x];
			for(int i = 0; i < x; i++){
				openlist2[i] = new StringBuilder(goal[i]);
			}
			open2.add(new C(0, openlist2));
			HashMap<String , Integer> close2 = new HashMap<String, Integer>();
			close2.put(tostr(openlist2), 0);
			while(! open2.isEmpty()){
				C now = open2.removeFirst();

				//ゴール判定
				String nowstr = tostr(now.list);
				if(close.containsKey(nowstr)){
					ans = now.step + close.get(nowstr);
					break;
				}

				for(int i = 0; i < y; i++){
					int num1 = data[i][0] - '0';
					int num2 = data[i][2] - '0';
					char op1 = data[i][1];
					char op2 = data[i][3];

					if(op1 == 'W' && op2 == 'W'){
						//from to
						for(int j = 0; j < now.list[num1].length(); j++){

							String temp = now.list[num1].substring(0, j + 1);
							StringBuilder move = new StringBuilder(temp);
							move.reverse();

							StringBuilder [] work = deepcopy(now.list);
							work[num1].delete(0, j + 1);
							work[num2].insert(0, move.toString());
							String nextstr = tostr(work);
							if(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){
								continue;
							}
							open2.add(new C(now.step + 1, work));
							close2.put(nextstr, now.step + 1);
						}

						//to from
						for(int j = 0; j < now.list[num2].length(); j++){
							String temp = now.list[num2].substring(0, j + 1 );
							StringBuilder move = new StringBuilder(temp);
							move.reverse();

							StringBuilder [] work = deepcopy(now.list);
							work[num2].delete(0, j + 1);
							work[num1].insert(0, move.toString());
							String nextstr = tostr(work);
							if(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){
								continue;
							}
							open2.add(new C(now.step + 1, work));
							close2.put(nextstr, now.step + 1);
						}
					}
					else if(op1 == 'W' && op2 == 'E'){
						//from to
						for(int j = 0; j < now.list[num1].length(); j++){
							String temp = now.list[num1].substring(0, j + 1);
							StringBuilder move = new StringBuilder(temp);

							StringBuilder [] work = deepcopy(now.list);
							work[num1].delete(0, j + 1);
							work[num2].append(move.toString());
							String nextstr = tostr(work);
							if(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){
								continue;
							}
							open2.add(new C(now.step + 1, work));
							close2.put(nextstr, now.step + 1);
						}

						//to from
						for(int j =0; j < now.list[num2].length(); j++){
							int len = now.list[num2].length();
							String temp = now.list[num2].substring(len - j - 1, len);
							StringBuilder move = new StringBuilder(temp);

							StringBuilder [] work = deepcopy(now.list);
							work[num2].delete(len-j - 1, len);
							work[num1].insert(0, move.toString());
							String nextstr = tostr(work);
							if(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){
								continue;
							}
							open2.add(new C(now.step + 1, work));
							close2.put(nextstr, now.step + 1);
						}
					}
					else if(op1 == 'E' && op2 == 'W'){
						//from to
						for(int j = 0; j < now.list[num1].length(); j++){
							int len = now.list[num1].length();
							String temp = now.list[num1].substring(len - j - 1, len);
							StringBuilder move = new StringBuilder(temp);

							StringBuilder [] work = deepcopy(now.list);
							work[num1].delete(len-j - 1, len);
							work[num2].insert(0,move.toString());
							String nextstr = tostr(work);
							if(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){
								continue;
							}
							open2.add(new C(now.step + 1, work));
							close2.put(nextstr, now.step + 1);
						}

						//to from
						for(int j = 0; j < now.list[num2].length(); j++){
							String temp = now.list[num2].substring(0, j+1);
							StringBuilder move = new StringBuilder(temp);

							StringBuilder [] work = deepcopy(now.list);
							work[num2].delete(0, j+1);
							work[num1].append(move.toString());
							String nextstr = tostr(work);
							if(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){
								continue;
							}
							open2.add(new C(now.step + 1, work));
							close2.put(nextstr, now.step + 1);
						}
					}
					else{
						// E, E
						//from to
						for(int j = 0; j < now.list[num1].length(); j++){
							int len = now.list[num1].length();
							String temp = now.list[num1].substring(len - j-1, len);
							StringBuilder move = new StringBuilder(temp);
							move.reverse();

							StringBuilder [] work = deepcopy(now.list);
							work[num1].delete(len-j-1, len);
							work[num2].append(move.toString());
							String nextstr = tostr(work);
							if(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){
								continue;
							}
							open2.add(new C(now.step + 1, work));
							close2.put(nextstr, now.step + 1);
						}

						//to from
						for(int j = 0; j < now.list[num2].length(); j++){
							int len = now.list[num2].length();
							String temp = now.list[num2].substring(len - j-1, len);
							StringBuilder move = new StringBuilder(temp);
							move.reverse();

							StringBuilder [] work = deepcopy(now.list);
							work[num2].delete(len-j - 1, len);
							work[num1].append(move.toString());
							String nextstr = tostr(work);
							if(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){
								continue;
							}
							open2.add(new C(now.step + 1, work));
							close2.put(nextstr, now.step + 1);
						}
					} //ifend
				} //end i
			}//end while

			//出力
			System.out.println(ans);
		}
		String a = """";
		for(int i = 0; i < a.length(); i++){
			System.out.println(a.substring(0, i + 1));

		}
	}

	private StringBuilder[] deepcopy(StringBuilder[] list) {
		StringBuilder [] sb = new StringBuilder[list.length];
		for(int i = 0; i < list.length; i++){
			sb[i] = new StringBuilder(list[i].toString());
		}
		return sb;
	}

	private String tostr2(String[] goal) {
		StringBuilder sb = new StringBuilder();
		for(int i = 0; i < goal.length; i++){
			sb.append(goal[i].toString() + ""."");
		}
		return sb.toString();
	}

	private String tostr(StringBuilder[] openlist) {
		StringBuilder sb = new StringBuilder();
		for(int i = 0; i < openlist.length; i++){
			sb.append(openlist[i].toString() + ""."");
		}
		return sb.toString();
	}

	public static void main(String[] args) {
		Main obj = new Main();
		obj.doit();
	}
}"
80,"import java.util.*;
class Main{
	static Scanner s = new Scanner(System.in);
	public static void main(String[] args) {
		StringBuilder str = new StringBuilder(s.next());
		String[] m = {""eraser"",""erase"",""dreamer"",""dream""};
		boolean f;
		do {
			f=false;
			for(String b:m) {
				if(str.toString().endsWith(b)) {
					str.replace(str.length()-b.length(),str.length(),"""");
					f=true;
					break;
				}
			}
		}while(f);
		System.out.println((str.toString().equals(""""))?""YES"":""NO"");
	}
}"
81,"import java.util.*;
import java.io.*;
import java.awt.geom.*;
import java.math.*;

public class Main {

	static final Scanner in = new Scanner(System.in);
	static final PrintWriter out = new PrintWriter(System.out,false);

	static void solve() {
		int h = in.nextInt();
		int w = in.nextInt();
		int n = in.nextInt();
		int ci = -1, cj = -1;
		char[][] table = new char[h][w];
		for (int i=0; i<h; i++) {
			table[i] = in.next().toCharArray();
			for (int j=0; j<w; j++) {
				if (table[i][j] == 'S') {
					ci = i;
					cj = j;
				}
			}
		}

		int ans = 0;

		for (int i=1; i<=n; i++) {
			int[] res = bfs(table,ci,cj,i);
			ci = res[0];
			cj = res[1];
			ans += res[2];
		}

		out.println(ans);
	}

	static int[] bfs(char[][] table, int ci, int cj, int target) {
		int h = table.length;
		int w = table[0].length;

		boolean[][] visited = new boolean[h][w];
		visited[ci][cj] = true;

		int[] di = {0,1,0,-1};
		int[] dj = {1,0,-1,0};

		ArrayDeque<int[]> que = new ArrayDeque<int[]>();
		que.add(new int[]{ci,cj,0});

		while (!que.isEmpty()) {
			int[] cur = que.pollFirst();
			int i = cur[0];
			int j = cur[1];
			int d = cur[2];
			visited[i][j] = true;

			if (table[i][j] - '0' == target) return new int[]{i,j,d};

			for (int k=0; k<4; k++) {
				int ni = i + di[k];
				int nj = j + dj[k];
				if (ni < 0 || nj < 0 || h <= ni || w <= nj || visited[ni][nj] || table[ni][nj] == 'X') continue;
				que.add(new int[]{ni,nj,d+1});
			}
		}

		return null;
	}

	public static void main(String[] args) {
		long start = System.currentTimeMillis();

		solve();
		out.flush();

		long end = System.currentTimeMillis();
		//trace(end-start + ""ms"");
		in.close();
		out.close();
	}

	static void trace(Object... o) { System.out.println(Arrays.deepToString(o));}
}"
82,"import java.util.Scanner;

public class Main {


	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
			int sx  = sc.nextInt();
			int sy  = sc.nextInt();
			int tx  = sc.nextInt();
			int ty  = sc.nextInt();
		sc.close();

		String m = """";

		for(int i = sx ; i < tx ; i++){
			m += ""R"";
		}
		for(int i = sy ; i < ty ; i++){
			m += ""U"";
		}

		for(int i = sx ; i < tx ; i++){
			m += ""L"";
		}
		for(int i = sy ; i < ty ; i++){
			m += ""D"";
		}
		int sx2 = sx-1;
		int sy2 = sy-1;
		int tx2 = tx+1;
		int ty2 = ty+1;

		m+=""D"";

		for(int i = sx; i < tx2 ; i++){
			m+=""R"";
		}
		for(int i = sy2; i < ty ; i++){
			m+=""U"";
		}
		m+=""LU"";
		for(int i = sx2; i < tx ; i++){
			m+=""L"";
		}
		for(int i = sy; i < ty2 ; i++){
			m+=""D"";
		}
		m+=""R"";

		System.out.println(m);
	}
}"
83,"import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args) {
        MyScanner sc = new MyScanner();
        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));
        int n = sc.nextInt();
        String s = sc.next();
        int pop = 0;
        for (int i = 0; i < s.length(); ++i) {
            if (s.charAt(i) == '1') {
                pop++;
            }
        }
        int below = 0; int above = 0;
        for (int i = 0; i < n; i++) {
            if (s.charAt(i) == '1') {
                below = (below + pow(2, n - 1 - i, pop - 1)) % (pop - 1);
                above = (above + pow(2, n - 1 - i, pop + 1)) % (pop + 1);
            }
        }
        for (int i = 0; i < n; i++) {
            if (s.charAt(i) == '1') {
                if (pop == 1) {
                    out.println(0); continue;
                }
                int use = below;
                use = (use - pow(2, n - 1 - i, pop - 1)) % (pop - 1);
                if (use < 0) use += (pop - 1);
                int ans = 1;
                while (use != 0) {
                    use = use % Integer.bitCount(use);
                    ans++;
                }
                out.println(ans);
            } else {
                int use = above;
                use = (use + pow(2, n - 1 - i, pop + 1)) % (pop + 1);
                if (use < 0) use += (pop + 1);
                int ans = 1;
                while (use != 0) {
                    use = use % Integer.bitCount(use);
                    ans++;
                }
                out.println(ans);
            }
        }
        out.close();
    }

    static int pow(long b, int e, int mod) {
        long ans = 1;
        while (e > 0) {
            if (e % 2 == 1)
                ans = ans * b % mod;
            e >>= 1;
            b = b * b % mod;
        }
        return (int) ans;
    }


    //-----------MyScanner class for faster input----------
    public static class MyScanner {
        BufferedReader br;
        StringTokenizer st;

        public MyScanner() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }


    }

}"
84,"import java.util.Scanner;

public class StandardDeviation {
 public static <S> void main(String[] args){
  Scanner input=new Scanner(System.in);
  int n ;
  int[] S;
  S=new int[1000];
  double sum,m,k,a;
  
  while((n = input.nextInt())!=0){
   sum=0.0;
   for (int i=0;i<n;i++){
    S[i]=input.nextInt();
   }
   for (int i=0;i<n;i++){
    sum=sum+S[i];
 
   }
  
   m=(double)sum/n;
   k=0.0;
   double u=0.0;
   
   for (int i=0;i<n;i++){
    k=(S[i]-m)*(S[i]-m);
    u=u+k;
   }
   
   a=u/n;
   System.out.println(Math.sqrt(a));
  
  }
 }
}"
85,"
import java.util.Scanner;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author wnqmw
 */
public class travsales {
    public static void main(String args[]){
        Scanner kb = new Scanner(System.in);
        
        int length = kb.nextInt(), numhouses = kb.nextInt();
        
        int[] houses = new int[numhouses];
        for(int i = 0; i < numhouses; i++){
            houses[i] = kb.nextInt();
        }
        
        int max = houses[0]+(length-houses[numhouses-1]);
        for(int i = 1; i < numhouses; i++){
            if(max < houses[i]-houses[i-1]){
                max = houses[i]-houses[i-1];
            }
        }
        System.out.println(length-max);
    }
}
"
86,"import java.util.*;

public class Main{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        Integer N = sc.nextInt();
        Integer Q = sc.nextInt();
        String S = sc.next();

        Integer[] l = new Integer[Q], r = new Integer[Q];
        for(int i = 0; i < Q; i++){
            l[i] = sc.nextInt();
            r[i] = sc.nextInt();
        }

        for(int i = 0; i < Q; i++){
            Integer count = 0;
            for(int idx = l[i]; idx < r[i]; idx++){
                if(S.charAt(idx-1) == 'A' && S.charAt(idx) == 'C'){
                    count++;
                }
            }
            System.out.println(count);
        }
    }
}"
87,"import java.util.Scanner;
public class Main {
	public static void main(String[] args){
		Scanner scan=new Scanner(System.in);
		int[] stack=new int[100];
		int stackPointer=0;
		String s;
		while(scan.hasNext()){
			s=scan.next();
			if(s.equals(""+"")){
				stack[stackPointer-2]=stack[stackPointer-2]+stack[stackPointer-1];
				stackPointer-=2;
			}else if(s.equals(""-"")){
				stack[stackPointer-2]=stack[stackPointer-2]-stack[stackPointer-1];
				stackPointer-=2;
			}
			else if(s.equals(""*"")){
				stack[stackPointer-2]=stack[stackPointer-2]*stack[stackPointer-1];
				stackPointer-=2;
			}
			else{
				stack[stackPointer++]=Integer.parseInt(s);
			}
		}
		System.out.println(stack[0]);
		scan.close();
	}
}"
88,"import java.util.*;
public class Main {
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		String s = getInputString(sc);
 
        // programming
        int[] l = toIntegerList(s);
        int sum = 0;
        for (int v : l) {
            v += sum;
        }
        output(String.valueOf(sum));
	}

	public static String getInputString(Scanner sc) {
		return sc.next();
	}

	public static int getInputInteger(Scanner sc) {
		return Integer.parseInt(sc.next());
	}

	public static void output(String... params) {
		boolean isInit = true;
		String str = """";
		for (String s : params) {
			if (!isInit) {
				str += "" "";
			}
			str += s;
			isInit = false;
		}
		System.out.println(str);
	}

    public static int[] toIntegerList(String s) {
        String[] ret = new String[s.length()];
        for (int i = 0; i < s.length; i++) {
            ret[i] = Integer.parseInt(String.valueOf(s.charAt(i)));
        }
        return ret;
    }
}"
89,"import java.util.Scanner;

public class XCubic {

	public static void main(String[] args) {
		int ans=0;
		Scanner s = new Scanner(System.in);
		System.out.println(""Enter a number "");
		int x = s.nextInt();
		if(x>=1 && x<=100){
			ans=x*x*x;
			System.out.println(""Answer of  cubic ""+ans);
		}else{
			System.out.println(""Number is invalid"");
		}
		
	

	}

}"
90,"import java.util.Scanner;
import java.util.Arrays;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		int M = sc.nextInt();
		
		long[] A = new long[N];
		long[] B = new long[N];
		long[] C = new long[N];
		
		for(int i = 0; i < N; i++) {
			A[i] = sc.nextInt();
			B[i] = sc.nextInt();
			C[i] = A[i];
		}
		
		Arrays.sort(C);
		
		long sumPlice = 0;
		long sumNum = 0;
		
		loop:
		for(int i = 0; i < N; i++) {
			for(int j = 0; j < N; j++) {
				if(C[i] == A[j]) {
					sumPlice += C[i] * B[j];
					sumNum += B[j];
					if(sumNum >= M) {
						sumPlice = sumPlice - (sumNum - M) * C[i];
						break loop;
					}
					A[j] = -1;
					break;
				}
			}

		}	
		System.out.println(sumPlice);
	}
}
"
91,"import java.io.*;

class AffineCipher {
	String s,c;
	String alph = ""abcdefghijklmnopqrstuvwxyz"";
	int a[] = {1,3,5,7,9,11,15,17,19,21,23,25};

	AffineCipher(String s) {
		this.s = s;
		this.c = s;
	}

	boolean Found(String t) {
		if (t.indexOf(""that"")!=-1||
			t.indexOf(""this"")!=-1) return true;
		else return false;
	}

	String FindString() {
		for (int i=0;i<12;i++) {
			for (int j=0;j<=25;j++) {
				String t = """";
				for (int k=0;k<this.s.length();k++) {
					if (alph.indexOf(this.s.charAt(k))!=-1)
						t = t+alph.charAt((a[i]*alph.indexOf(this.s.charAt(k))+j)%26);
					else t = t+this.s.charAt(k);
				}
				this.s = this.c;
				if (Found(t)) return t;
			}	
			this.s = this.c;
		}
		return ""NotFound"";
	}
}

class Main {
	public static void main(String args[]) {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		try {
			int n = Integer.parseInt(br.readLine());
			for (int i=0;i<n;i++) {
				AffineCipher ac = new AffineCipher(br.readLine());
				System.out.println(ac.FindString());
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}"
92,"import java.util.Scanner;

class Frog1 {


    public static int totalCostIncurred(int[] height) {
        return totalCostHelper(0, height);
    }

    private static int totalCostHelper(int i, int[] height) {
        if(i == height.length - 1) {
            return 0;
        }

        int cost1 = Math.abs(height[i+1]-height[i]) + totalCostHelper(i+1,height);
        int cost2 = i+2 < height.length ? Math.abs(height[i+2]-height[i]) + totalCostHelper(i+2,height): Integer.MAX_VALUE;
        return Math.min(cost1, cost2);
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int numberOfStones = scanner.nextInt();
        int[] height = new int[numberOfStones];

        for(int i=0; i<height.length; i++)
            height[i] = scanner.nextInt();
        System.out.println(totalCostIncurred(height));
    }
}
"
93,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class main {
	public static void main(String[] args) {
		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

		try {
			String line = reader.readLine();
			String[] strAry = line.split(""\\s+"");
			int x = Integer.parseInt(strAry[0]);
			int y = Integer.parseInt(strAry[1]);
			int z = Integer.parseInt(strAry[2]);
			int p;
			int q = 0;

			while(q != 1)
			{
				if(x>y)
				{
					p = y;
					y = x;
					x = p;
				}else if(x>z)
				{
					p = z;
					z = x;
					x = p;
				}else if (y > z)
				{
					p = z;
					z = y;
					y = p;
				}else
				{
					q++;
				}

			}

			System.out.printf(""%d %d %d"",x,y,z);
		} catch (IOException e) {
			System.out.println(e);
		}
	}
}"
94,"import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		int sx = scanner.nextInt(),sy = scanner.nextInt();
		int tx = scanner.nextInt(),ty = scanner.nextInt();
		int x = Math.abs(sx-tx);
		int y = Math.abs(sy-ty);
		String path = """";
		for(int i=0;i<x;i++){
			path += ""R"";
		}
		for(int i=0;i<y;i++){
			path += ""U"";
		}
		for(int i=0;i<x;i++){
			path += ""L"";
		}
		for(int i=0;i<y;i++){
			path += ""D"";
		}
		path = path + ""D"";
		for(int i=0;i<x+1;i++){
			path += ""R"";
		}
		for(int i=0;i<y+1;i++){
			path += ""U"";
		}
		path += ""L"";
		path += ""U"";
		for(int i=0;i<x+1;i++){
			path += ""L"";
		}
		for(int i=0;i<y+1;i++){
			path += ""D"";
		}
		path += ""R"";

		System.out.println(path);
	}

}
"
95,"mport java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
		//外部入力取り込んだ借金をしている期間（週単位）
		int week = Integer.parseInt(in.readLine());
		//借金
		double debt = 100000;
		//利子
		double interest = 1.05;

		//借金の計算
		for (int i = 0; i < week; i++) {
			//一週間ごとに 借金に5% の利子を借金に加える
			debt = debt * interest;
			//借金の 1,000 円未満を切り上げ
			debt = Math.ceil(debt/1000);
			debt = debt * 1000;
		}
		//計算後の借金を整数として外部出力
		System.out.println((int)debt);
	}
}"
96,"import java.util.Scanner;
public class Main {
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		int a,b,d,r;
		double f,a1,b1;
		a=sc.nextInt();
		b=sc.nextInt();
		d=a/b;r=a%b;
		a1=a;b1=b;
		f=a1/b1;
		System.out.print(d+"" ""+r+"" "");
		System.out.printf(""%.5f"",f);
	}
}

"
97,"import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		// TODO ?????????????????????????????????????????????
		Scanner sc = new Scanner(System.in);
		int n= sc.nextInt();
		sc.nextLine();

		DoublyLL ll = new DoublyLL();

		loop:
		for (int i=0; i < n; i++) {
			String command = sc.nextLine();

			switch (command) {
			case ""deleteFirst"":
				ll.deleteFirst();
				continue;
			case ""deleteLast"":
				ll.deleteLast();
				continue;
			}

			int x = Integer.parseInt(command.split("" "")[1]);

			switch (command.split("" "")[0]) {
			case ""insert"":
				ll.insert(x);
				continue;
			case ""delete"":
				ll.delete(x);
				continue;
			}
		}

		int l = ll.length;
		DoublyLL.Element e = ll.first;
		for (int i = 1; i < l; i++) {
			System.out.print(e.key + "" "");
			e = e.next;
		}
		System.out.println(e.key);
	}

//	static class DoublyLL<T> {
//
//	}

	static class DoublyLL {

		class Element {
//			Element previous;

			int key;

			Element next;

			Element(int key, Element next) {
				this.key = key;
				this.next = next;
//				this.previous = previous;
			}

			Element(int key) {
				this(key, null);
			}
		}

		// first element of this list
		Element first = null;

//		Element last = null;

		// the number of elements in this list
		int length = 0;

//		 constructor
//		DoublyLL(int x) {
//			this.first = new Element(x);
//			this.last = this.first;
//			this.first.previous = this.last;
//			this.first.next = this.last;
//			length = 1;
//		}
		// constructor
		DoublyLL() {}

		// insert x
		void insert(int x) {
//			if (length==0) {
////				DoublyLL temp = new DoublyLL(x);
//				this.first = new Element(x);
////				this.first.next = this.first.previous = this.first;
////				this.last = this.first;
//				length++;
//				return;
//			}
			Element newfirst = new Element(x, this.first);
//			this.first.previous = newfirst;
//			this.last.next = newfirst;
			this.first = newfirst;
			length++;
			return;
		}

		// delete x
		void delete(int x) {

//			if (this.first.key == x) {
//				Element newfirst = this.first.next;
//				newfirst.previous = null;
//				this.first = newfirst;
//				return this;
//			}

			if (length==0) return;

			if (length==1)
				if (this.first.key == x) {
//					this.first.previous = this.first.next = null;
					//?????±?????§??????
					this.first = null;
					length--;
					return;
				}


			Element e = this.first;
			Element en = e.next;
			if (e.key == x) {
				this.first = en;
				length--;
				return;
			}

			for (int i = 1; i < length; i++) {
				if (en.key == x) {
//					Element p = e.previous;
//					Element n = e.next;
//					p.next = n;
//					n.previous = p;
//					if (i == 1) this.first = n;
//					else if (i == length) this.last = p;
//					//?????±?????§??????
//					e.next = e.previous = null;
					e.next = en.next;
					length--;
					return;
				} else {
					en = en.next;
					e = e.next;
				}
			}

			return;
		}

		void deleteFirst() {
//			if (length <= 1) {
//				this.first = this.last = null;
//				length = 0;
//				return;
//			}
//			Element n = this.first.next;
//			n.previous = this.last;
//			this.last.next = n;
//			//?????±?????§??????
//			this.first.next = this.first.previous = null;
			this.first = this.first.next;
			length--;
			return;
		}

		void deleteLast() {
//			if (length <= 1) {
//				this.first = this.last = null;
//				length = 0;
//				return;
//			}
//			Element p = this.last.previous;
//			p.next = this.first;
//			this.first.previous = p;
//			//?????±?????§??????
//			this.last.next = this.last.previous = null;
			Element e = this.first;
			for (int i=1; i <= length-2; i++) {
				e = e.next;
			}
			e.next = null;
//			this.last = p;
			length--;
			return;
		}
	}
}"
98,"import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		int L[] = new int[N];

		for (int i = 0; i < N; i++) {
				L[i] = sc.nextInt();
		}

		int answer = 0;
		for (int i = 0; i < N; i++) {
			for (int j = i + 1; j < N; j++) {
				for (int k = j + 1; k < N; k++) {
					if (L[i] < L[j] + L[k] && L[j] < L[k] + L[i]  && L[k] < L[i] + L[j]) answer++;
				}
			}
		}

		System.out.println(answer);

	}
}"
99,"import java.util.*;
public class Main {
    public static void main(String[] args){
    	Scanner sc = new Scanner(System.in);
    	int[] ary = new int[5];
    	ary[0]=sc.nextInt();
    	ary[1]=sc.nextInt();
    	ary[2]=sc.nextInt();
    	ary[3]=sc.nextInt();
    	ary[4]=sc.nextInt();
    	if((ary[2]+ary[4])<=ary[0]&&(ary[3]+ary[4])<=ary[1]&&ary[2]>=ary[4]&&ary[3]>=ary[4]){
    	    System.out.println(""Yes"");
    	}else{
    		System.out.println(""No"");
    	}
    }
}

"
100,"import java.util.*;
import java.awt.*;
import static java.lang.System.*;
import static java.lang.Math.*;
public class Main {
    public static void main(String[] args){
        Scanner sc = new Scanner(in);
        long n=sc.nextLong();
        long m=sc.nextLong();
        String s=sc.next();
        String t=sc.next();
        long lcm=n/gcd(n,m)*m;
        HashMap<Long,Character> mapS=new HashMap<>();
        HashMap<Long,Character> mapT=new HashMap<>();
        for (long i = 0; i < n; i++) {
            mapS.put((long)(i*lcm/n+1),s.charAt((int)i));
        }
        for (long i = 0; i < m; i++) {
            mapT.put(i*lcm/m+1,t.charAt((int)i));
        }
        for (long i = 1; i <= lcm; i++) {
            if(mapS.get(i)!=null&&mapT.get(i)!=null&&mapS.get(i)!=mapT.get(i)){
                out.println(-1);
                exit(0);
            }
        }
        out.println(lcm);
    }
    static long gcd (long a, long b) {
        long temp;
        while((temp = a%b)!=0) {
            a = b;
            b = temp;
        }
        return b;
    }
}"
101,"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), """", 1 << 28);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            BFirstSecond solver = new BFirstSecond();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class BFirstSecond {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            PartialString[] ps = new PartialString[n];
            int[] s = new int[(int) 1e6];
            int[] suf = new int[(int) 1e6];
            Node root = new Node();
            long ans = 0;
            int wpos = 0;
            for (int i = 0; i < n; i++) {
                int len = in.readString(s, wpos);
                ps[i] = new PartialString(s, suf, wpos, wpos + len - 1);
                for (int j = 0; j < len; j++) {
                    s[wpos + j] -= 'a';
                }
                SequenceUtils.reverse(s, wpos, wpos + len - 1);
                suf[wpos + len - 1] = 1 << s[wpos + len - 1];
                for (int j = len - 2; j >= 0; j--) {
                    suf[wpos + j] = suf[wpos + j + 1] | (1 << s[wpos + j]);
                }
                wpos += len;
            }

            Arrays.sort(ps, (a, b) -> Integer.compare(a.length(), b.length()));
            for (PartialString string : ps) {
                int contrib = root.count(string, 0);
                ans += contrib;
                root.add(string, 0);
            }
            out.println(ans);
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

        public int readString(int[] data, int offset) {
            skipBlank();

            int originalOffset = offset;
            while (next > 32) {
                data[offset++] = (char) next;
                next = read();
            }

            return offset - originalOffset;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(long c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(long c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class Node {
        static int charset = 'z' - 'a' + 1;
        Node[] next = new Node[charset];
        int cnt;

        public Node get(int i) {
            if (next[i] == null) {
                next[i] = new Node();
            }
            return next[i];
        }

        public int count(PartialString seq, int i) {
            if (i == seq.length()) {
                return 0;
            }
            int ans = 0;
            int suf = seq.getSuf(i);
            for (int j = 0; j < charset; j++) {
                if (next[j] != null && Bits.get(suf, j) == 1) {
                    ans += next[j].cnt;
                }
            }
            if (next[seq.get(i)] != null) {
                ans += next[seq.get(i)].count(seq, i + 1);
            }
            return ans;
        }

        public void add(PartialString seq, int i) {
            if (i == seq.length()) {
                cnt++;
                return;
            }
            get(seq.get(i)).add(seq, i + 1);
        }

    }

    static class Bits {
        private Bits() {
        }

        public static int get(int x, int i) {
            return (x >>> i) & 1;
        }

    }

    static class PartialString {
        int[] s;
        int[] suf;
        int l;
        int r;

        public PartialString(int[] s, int[] suf, int l, int r) {
            this.s = s;
            this.suf = suf;
            this.l = l;
            this.r = r;
        }

        public int get(int i) {
            return s[l + i];
        }

        public int getSuf(int i) {
            return suf[l + i];
        }

        public int length() {
            return r - l + 1;
        }

    }

    static class SequenceUtils {
        public static void swap(int[] data, int i, int j) {
            int tmp = data[i];
            data[i] = data[j];
            data[j] = tmp;
        }

        public static void reverse(int[] data, int l, int r) {
            while (l < r) {
                swap(data, l, r);
                l++;
                r--;
            }
        }

    }
}

"
102,"import java.util.*;

class Main{
    public Main(){
        Scanner SC = new Scanner(System.in);

        String S = SC.next();
        int L = S.length();
        int[] N = new int[L];
        for(int i=0;i<L;i++){
            N[i] = S.charAt(i) - '0';
        }

        int total = 0;
        int left = 0;
        while(left+3 < L){
            int mod = (N[left]*1000 + N[left+1]*100 + N[left+2]*10 + N[left+3]) % 2019;
            if(mod == 0) total++;
            int i = left+4;
            while(i != L){
                mod = (mod*10 + N[i])%2019;
                if(mod == 0) total++;
                i++;
            }
            left++;
        }
        System.out.println(total);
    }

    public static void main(String args[]){
        Main main = new Main();
    }
}
"
103,"import java.io.*;
import java.util.*;

public class Main {

    static int N;
    static int M;
    static Edge[] E;

    public static void main(String[] args) {
        FastScanner sc = new FastScanner(System.in);
        N = sc.nextInt();
        M = sc.nextInt();
        E = new Edge[M];
        for (int i = 0; i < M; i++) {
            E[i] = new Edge(sc.nextInt()-1, sc.nextInt()-1, sc.nextInt());
        }
        System.out.println(solve());
    }

    static class Route {
        long from;
        long to;
        int cost;

        public Route(long from, long to, int cost) {
            this.from = from;
            this.to = to;
            this.cost = cost;
        }
    }

    static class Edge {
        int p;
        int q;
        int c;

        public Edge(int p, int q, int c) {
            this.p = p;
            this.q = q;
            this.c = c;
        }

        public String toString() {
            return ""Edge("" + p + "","" + q + "","" + c + "")"";
        }
    }

    static class State implements Comparable<State> {
        long key;
        int cost;

        public State(long key, int cost) {
            this.key = key;
            this.cost = cost;
        }

        @Override
        public int compareTo(State o) {
            return Integer.compare(cost, o.cost);
        }
    }

    static int solve() {
        if( M == 0 ) return -1;

        Map<Long, List<Route>> rin = new HashMap<>();
        Map<Integer, Set<Integer>> rin2 = new HashMap<>(); // 駅に乗り入れている会社
        for (Edge e : E) {
            long pc = placeCompanyKey(e.p, e.c);
            long qc = placeCompanyKey(e.q, e.c);
            addRoute(rin, pc, qc, 0);
            addRoute(rin, qc, pc, 0);

            addCompany(rin2, e.p, e.c);
            addCompany(rin2, e.q, e.c);
        }

        PriorityQueue<State> q = new PriorityQueue<>();
        Map<Long, Integer> costs = new HashMap<>(M);
        long start = placeCompanyKey(0, 0);
        q.add( new State(start, 0) );
        costs.put(start, 0);

        while(!q.isEmpty()) {
            State s = q.poll();
            if( s.cost != costs.get(s.key) ) continue;

            // 連結ではない可能性がある
            for (Route r : rin.getOrDefault(s.key, Collections.emptyList())) {
                long next = r.to;
                int nextCost = s.cost + r.cost;
                if (!costs.containsKey(next) || costs.get(next) > nextCost) {
                    costs.put(next, nextCost);
                    q.add(new State(next, nextCost));
                }
            }

            int sp = extractPlace(s.key);
            int sc = extractCompany(s.key);
            if( sc != 0 ) {
                long next = placeCompanyKey(sp, 0);
                int nextCost = s.cost;
                if( !costs.containsKey(next) || costs.get(next) > nextCost ) {
                    costs.put(next, nextCost);
                    q.add( new State(next, nextCost));
                }
            } else {
                for (int company : rin2.getOrDefault(sp, Collections.emptySet())) {
                    // 0 -> company
                    long next = placeCompanyKey(sp, company);
                    int nextCost = s.cost + 1;
                    if( !costs.containsKey(next) || costs.get(next) > nextCost ) {
                        costs.put(next, nextCost);
                        q.add( new State(next, nextCost));
                    }
                }
            }
        }

        long last = placeCompanyKey(N-1, 0);
        return costs.getOrDefault(last, -1);
    }

    static void addCompany(Map<Integer, Set<Integer>> rin2, int p, int c) {
        if( !rin2.containsKey(p) ) {
            rin2.put(p, new HashSet<>());
        }
        rin2.get(p).add(c);
    }

    static void addRoute(Map<Long, List<Route>> rin, long from, long to, int cost) {
        if( !rin.containsKey(from) ) {
            rin.put(from, new ArrayList<>());
        }
        rin.get(from).add( new Route(from, to, cost));
    }

    static int INF = 1_000_000_000;

    static long placeCompanyKey(int p, int company) {
        return (long)p * INF + company;
    }

    static int extractPlace(long key) {
        return (int)(key / INF);
    }

    static int extractCompany(long key) {
        return (int)(key % INF);
    }

    @SuppressWarnings(""unused"")
    static class FastScanner {
        private BufferedReader reader;
        private StringTokenizer tokenizer;

        FastScanner(InputStream in) {
            reader = new BufferedReader(new InputStreamReader(in));
            tokenizer = null;
        }

        String next() {
            if (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        String nextLine() {
            if (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    return reader.readLine();
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken(""\n"");
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        int[] nextIntArray(int n) {
            int[] a = new int[n];
            for (int i = 0; i < n; i++)
                a[i] = nextInt();
            return a;
        }

        long[] nextLongArray(int n) {
            long[] a = new long[n];
            for (int i = 0; i < n; i++)
                a[i] = nextLong();
            return a;
        }
    }
}
"
104,"import java.util.*;

public class Main 
{
	public static void main(String[] args)
	{
		Scanner scan = new Scanner(System.in);
		
		int n = scan.nextInt();
		
		ArrayList<String> paper = new ArrayList<String>();
		
		int count = 0;
		
		for(int i = 0; i < n ; i++)
		{
			String a = scan.next();
			
			if(!paper.contains(a))
			{
				paper.add(a);
				count++;
			}
			else
			{
				paper.remove(a);
				count--;
			}
		}

		System.out.println(count);
		scan.close();
	}
}
"
105,"import java.util.*;

public class Main {

    public static void main(String args[]) {

        // 入力
        Scanner sc = new Scanner(System.in);
        String x = sc.next();
        sc.close();

        // 主処理
        int result = 0;
        while (x.contains(""ST"")) {
            String[] array = x.replace(""TS"", ""T,S"").split("","");
            List<String> list = new ArrayList<>();
            for (String st : array) {
                int countS = st.replaceAll(""[^S]"", """").length();
                int countT = st.replaceAll(""[^T]"", """").length();
                if (countS == 0 || countT == 0) {
                    result += Math.max(countS, countT);
                } else if (countS < countT) {
                    list.add(""T"".repeat(countT - countS));
                } else if (countT < countS) {
                    list.add(""S"".repeat(countS - countT));
                }
            }
            x = String.join("""", list);
        }
        result += x.length();

        // 出力
        System.out.println(result);
    }
}
"
106,"import java.util.Scanner;

class Main{
   public void yatary() {  
     Scanner sc = new Scanner(System.in);
     int x;
     int a = sc.nextInt();
 String op = sc.next();
     int b = sc.nextInt();
       boolean sw = true;
       sc.useDelimiter(""\\s"");
       while(sw = true){
           if (op.equals(""+"")){
               x = a + b;
               System.out.println(x);
           }else if(op.equals(""-"")){
               x = a - b;
               System.out.println(x);
           }else if(op.equals(""*"")){
               x = a * b;
               System.out.println(x);
           }else if(op.equals(""/"")){
               x = a / b;    
               System.out.println(x);
        }
           sw = false;
     }
  }

public static void main(String[] args){ 
    new Main().yatary();   
  }
} "
107,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.math.BigDecimal;
import java.text.DecimalFormat;
import java.util.AbstractMap;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Set;
import java.util.Stack;
import java.util.TreeMap;
import java.util.TreeSet;

import static java.util.Comparator.*;

public class Main {

    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        MyInput in = new MyInput(inputStream);
        PrintWriter out = new PrintWriter(outputStream);

        Solver solver = new Solver(in, out);
        solver.solve();

        out.close();
    }

    // ======================================================================

    static class Solver {
    	MyInput in;
    	PrintWriter out;
        public Solver(MyInput in, PrintWriter out) {
        	this.in = in;
        	this.out = out;
        }
        
        //-----------------------------------------
        //
//        int[][] diff = {{-1, 0}, {1, 0}, {0,-1}, {0,1}};
        int[][] diff = {{1, 0}, {0,1}};
        final int MOD = 1000000007;
        int H, W;
        int[][] D = new int[1010][1010];
        long[][] dp = new long[1010][1010];
        
        long calc(int h, int w) {
        	if(h == H - 1 && w == W - 1)	return 1;
        	if(dp[h][w] > 0)				return dp[h][w];
    		long ans = 0;
    		int hh, ww;
    		for (int i = 0; i < diff.length; i++) {
				hh = h + diff[i][0];
				ww = w + diff[i][1];
				if(hh < 0 || hh >= H || ww < 0 || ww >= W)	continue;
				if(D[hh][ww] == 1)		 					continue;
				ans = (ans + calc(hh, ww)) % MOD;
			}
			return dp[h][w] = ans;
        }
        public void solve() {
        	H = ni();
        	W = ni();
        	String s;
        	for (int i = 0; i < H; i++) {
        		s = ns();
        		for (int j = 0; j < W; j++) {
					D[i][j] = (s.charAt(j) == '#' ? 1 : 0);
				}
        	}
        	long ans = calc(0,0);
//        	for (int i = 0; i < H; i++) {
//        		for (int j = 0; j < W; j++) {
//        			prn(""dp["" + i + ""]["" + j + ""] = "" + dp[i][j]);
//        		}
//       		}
        	prn(ans);
        }
        // -----------------------------------------
        void prn(String s) {
        	out.println(s);
        }
        void prn(int i) {
        	out.println(i);
        }
        void prn(long i) {
        	out.println(i);
        }
        void prr(String s) {
        	out.print(s);
        }
        int ni() {
        	return in.nextInt();
        }
        long nl() {
        	return in.nextLong();
        }
        double nd() {
        	return in.nextDouble();
        }
        String ns() {
        	return in.nextString();
        }
        int[] ndi(int n) {
        	int[] ans = new int[n];
        	for(int i=0; i < n; i++) {
        		ans[i] = ni();
        	}
        	return ans;
        }
        long[] ndl(int n) {
        	long[] ans = new long[n];
        	for(int i=0; i < n; i++) {
        		ans[i] = nl();
        	}
        	return ans;
        }
        double[] ndd(int n) {
        	double[] ans = new double[n];
        	for(int i=0; i < n; i++) {
        		ans[i] = nd();
        	}
        	return ans;
        }
        String[] nds(int n) {
        	String[] ans = new String[n];
        	for(int i=0; i < n; i++) {
        		ans[i] = ns();
        	}
        	return ans;
        }
        int[][] nddi(int n, int m) {
        	int[][] ans = new int[n][m];
        	for(int i=0; i < n; i++) {
            	for(int j=0; j < m; j++) {
            		ans[i][j] = ni();
            	}
        	}
        	return ans;
        }
        long[][] nddl(int n, int m) {
        	long[][] ans = new long[n][m];
        	for(int i=0; i < n; i++) {
            	for(int j=0; j < m; j++) {
            		ans[i][j] = nl();
            	}
        	}
        	return ans;
        }
    }

    static class PP{
    	public int key, val;
    	public PP(int key, int val) {
    		this.key = key;
    		this.val = val;
    	}
		public int getKey() {
			return key;
		}
		public void setKey(int key) {
			this.key = key;
		}
		public int getVal() {
			return val;
		}
		public void setVal(int val) {
			this.val = val;
		}
    }
    static class PPL {
    	public long key, val;
    	public PPL(long key, long val) {
    		this.key = key;
    		this.val = val;
    	}
		public long getKey() {
			return key;
		}
		public void setKey(long key) {
			this.key = key;
		}
		public long getVal() {
			return val;
		}
		public void setVal(long val) {
			this.val = val;
		}
    }
    static class PPDL {
    	public long key;
    	public long[] val;
    	public PPDL(long key, long[] val) {
    		this.key = key;
    		this.val = val;
    	}
		public long getKey() {
			return key;
		}
		public void setKey(long key) {
			this.key = key;
		}
		public long[] getVal() {
			return val;
		}
		public void setVal(long[] val) {
			this.val = val;
		}
		public void dump(PrintWriter out) {
			out.print(""key = "" + key + ""  val "");
			for(int i=0; i < val.length; i++) {
				out.print(""["" + val[i] + ""] "");
			}
			out.println("""");
		}
    }
    // HashMap のキーに使う
    static final class PPKEY{
    	private final int key, val;
    	public PPKEY(int key, int val) {
    		this.key = key;
    		this.val = val;
    	}
		public int getKey() {
			return key;
		}
		public int getVal() {
			return val;
		}
	    @Override
	    public boolean equals(Object obj) {
	        if (obj instanceof PPKEY) {
	        	PPKEY dest = (PPKEY) obj;
	            return this.key == dest.key && this.val == dest.val;
	        } else {
	            return false;
	        }
	    }
	    @Override
	    public int hashCode() {
	        return Objects.hash(key, val);
	    }
    }
    // HashMap のキーに使う
    static final class PPLKEY{
    	private final long key, val;
    	public PPLKEY(long key, long val) {
    		this.key = key;
    		this.val = val;
    	}
		public long getKey() {
			return key;
		}
		public long getVal() {
			return val;
		}
	    @Override
	    public boolean equals(Object obj) {
	        if (obj instanceof PPKEY) {
	        	PPKEY dest = (PPKEY) obj;
	            return this.key == dest.key && this.val == dest.val;
	        } else {
	            return false;
	        }
	    }
	    @Override
	    public int hashCode() {
	        return Objects.hash(key, val);
	    }
    }
    // グラフのリンクリスト
    static class Graph {
        private Map<Integer, List<Integer>> data = new HashMap<Integer, List<Integer>>();
        void add(int key, int value) {
        	List<Integer> list = data.get(key);
        	if(list == null) {
        		list = new ArrayList<Integer>();
        		data.put(key, list);
        	}
        	list.add(value);
        }
        List<Integer> get(int key) {
        	return data.get(key);
        }
        Set<Integer> keySet() {
        	return data.keySet();
        }
        boolean contains(int key, int value) {
        	List<Integer> list = data.get(key);
        	if(list == null)	return false;
        	else 				return list.contains(value);
        }
        void dump(PrintWriter out) {
        	for(int key : data.keySet()) {
        		out.print(key + "" : "");
        		for(int val : data.get(key)) {
        			out.print(val + "" "");
        		}
        		out.println("""");
        	}
        }
    }
    // 重さを持ったグラフのリンクリスト
    static class GraphWith {
        private Map<Integer, List<PP>> data = new HashMap<Integer, List<PP>>();
        void add(int key, PP p) {
        	List<PP> list = data.get(key);
        	if(list == null) {
        		list = new ArrayList<PP>();
        		data.put(key, list);
        	}
        	list.add(p);
        }
        List<PP> get(int key) {
        	return data.get(key);
        }
        // グラフの存在チェック（重さは関係しない）
        boolean contains(int key, int value) {
        	List<PP> list = data.get(key);
        	if(list == null)	return false;
        	boolean ans = false;
        	for(PP p : list) {
        		if(p.getKey() == value) {
        			ans = true;
        			break;
        		}
        	}
        	return ans;
        }
    }
    // グラフのリンクリスト(Long)
    static class GraphLong {
        private Map<Long, List<Long>> G = new HashMap<Long, List<Long>>();
        void add(long key, long value) {
        	List<Long> list = G.get(key);
        	if(list == null) {
        		list = new ArrayList<Long>();
        		G.put(key, list);
        	}
        	list.add(value);
        }
        List<Long> get(long key) {
        	return G.get(key);
        }
    }
    // 重さを持ったグラフのリンクリスト(Long)
    static class GraphLongWith {
        private Map<Long, List<PPL>> G = new HashMap<Long, List<PPL>>();
        void add(long key, PPL p) {
        	List<PPL> list = G.get(key);
        	if(list == null) {
        		list = new ArrayList<PPL>();
        		G.put(key, list);
        	}
        	list.add(p);
        }
        List<PPL> get(long key) {
        	return G.get(key);
        }
    }

    // ======================================================================
    static class Pair<K, V> extends AbstractMap.SimpleEntry<K, V> {
        /** serialVersionUID. */
        private static final long serialVersionUID = 6411527075103472113L;

        public Pair(final K key, final V value) {
            super(key, value);
        }
     }
    static class MyInput {
        private final BufferedReader in;
        private static int pos;
        private static int readLen;
        private static final char[] buffer = new char[1024 * 8];
        private static char[] str = new char[500 * 8 * 2];
        private static boolean[] isDigit = new boolean[256];
        private static boolean[] isSpace = new boolean[256];
        private static boolean[] isLineSep = new boolean[256];

        static {
            for (int i = 0; i < 10; i++) {
                isDigit['0' + i] = true;
            }
            isDigit['-'] = true;
            isSpace[' '] = isSpace['\r'] = isSpace['\n'] = isSpace['\t'] = true;
            isLineSep['\r'] = isLineSep['\n'] = true;
        }

        public MyInput(InputStream is) {
            in = new BufferedReader(new InputStreamReader(is));
        }

        public int read() {
            if (pos >= readLen) {
                pos = 0;
                try {
                    readLen = in.read(buffer);
                } catch (IOException e) {
                    throw new RuntimeException();
                }
                if (readLen <= 0) {
                    throw new MyInput.EndOfFileRuntimeException();
                }
            }
            return buffer[pos++];
        }

        public int nextInt() {
            int len = 0;
            str[len++] = nextChar();
            len = reads(len, isSpace);
            int i = 0;
            int ret = 0;
            if (str[0] == '-') {
                i = 1;
            }
            for (; i < len; i++) ret = ret * 10 + str[i] - '0';
            if (str[0] == '-') {
                ret = -ret;
            }
            return ret;
        }

        public long nextLong() {
            int len = 0;
            str[len++] = nextChar();
            len = reads(len, isSpace);
            int i = 0;
            long ret = 0L;
            if (str[0] == '-') {
                i = 1;
            }
            for (; i < len; i++) ret = ret * 10 + str[i] - '0';
            if (str[0] == '-') {
                ret = -ret;
            }
            return ret;
        }

        public double nextDouble() {
            int len = 0;
            str[len++] = nextChar();
            len = reads(len, isSpace);
            int i = 0;
            double ret = 0;
            if (str[0] == '-') {
                i = 1;
            }
            int cnt = 0;
            for (; i < len; i++) {
            	if(str[i] == '.') {
            		cnt = 10;
            		continue;
            	}
            	if(cnt == 0) {
            		ret = ret * 10 + str[i] - '0';
            	} else {
            		ret = ret + ((double)(str[i] - '0') / cnt);
            		cnt *= 10;
            	}
            }
            if (str[0] == '-') {
                ret = -ret;
            }
            return ret;
        }

       public String nextString() {
        	String ret = new String(nextDChar()).trim();
            return ret;
        }

        public char[] nextDChar() {
            int len = 0;
            len = reads(len, isSpace);
            char[] ret = new char[len + 1];
            for (int i=0; i < len; i++)		ret[i] = str[i];
            ret[len] = 0x00;
            return ret;
        }

        public char nextChar() {
            while (true) {
                final int c = read();
                if (!isSpace[c]) {
                    return (char) c;
                }
            }
        }

        int reads(int len, boolean[] accept) {
            try {
                while (true) {
                    final int c = read();
                    if (accept[c]) {
                        break;
                    }
                    if (str.length == len) {
                        char[] rep = new char[str.length * 3 / 2];
                        System.arraycopy(str, 0, rep, 0, str.length);
                        str = rep;
                    }
                    str[len++] = (char) c;
                }
            } catch (MyInput.EndOfFileRuntimeException e) {
            }
            return len;
        }

        static class EndOfFileRuntimeException extends RuntimeException {
        }
    }
}
"
108,"import java.util.Arrays;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        try (Scanner sc = new Scanner(System.in);) {
            solve(sc);
        }
    }

    public static void solve(Scanner sc) {
        int N = sc.nextInt();
        int K = sc.nextInt();
        int[] list = new int[N];
        for (int i = 0; i < N; i++) {
            list[i] = sc.nextInt();
        }
        Arrays.sort(list);

        System.out.println(Math.min(list[K - 1] - list[0], list[N - 1] - list[N - 1 - K - 1]));
    }
}"
109,"import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int sx = sc.nextInt();
		int sy = sc.nextInt();
		int tx = sc.nextInt();
		int ty = sc.nextInt();

		String s = new String();

		// forth
		for (int ny = sy; ny < ty; ny++) {
			s += ""U"";
		}
		for (int nx = sx; nx < tx; nx++) {
			s += ""R"";
		}

		// back
		for (int ny = ty; ny > sy; ny--) {
			s += ""D"";
		}
		for (int nx = tx; nx > sx; nx--) {
			s += ""L"";
		}

		// forth again
		s += ""L"";
		for (int ny = sy; ny < ty + 1; ny++) {
			s += ""U"";
		}
		for (int nx = sx - 1; nx < tx; nx++) {
			s += ""R"";
		}
		s += ""D"";

		// back again
		s += ""R"";
		for (int ny = ty; ny > sy - 1; ny--) {
			s += ""D"";
		}
		for (int nx = tx + 1; nx > sx; nx--) {
			s += ""L"";
		}
		s += ""U"";

		System.out.println(s);
	}

}
"
110,"import java.util.Scanner;

class Main
{
    public static void main(String[] args)
    {
        Scanner scan = new Scanner(System.in);
        
        int a = scan.nextInt();
        
        int b = scan.nextInt();
        
        int c = scan.nextInt();
        
        if(a<b<c)
        {
            System.out.println(""Yes"");
        }else if{
            System.out.println(""No"");
        }
    }
            


"
111,"import java.util.*;
public class Main {

    public static void main(String[] args) {

        //標準入力
        Scanner sc = new Scanner(System.in);

        //変数
        int d = sc.nextInt();
        int t = sc.nextInt();
        int s = sc.nextInt();

       if (d <= t * s){
            System.out.println(""Yes"");
        }else{
            System.out.println(""No"");
        }
    }
}"
112,"
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		// 整数の入力
		int n = sc.nextInt();
		// スペース区切りの整数の入力
		int[] t = new int[n];
		int[] x = new int[n];
		int[] y = new int[n];

		for (int i = 0; i < n; i++) {
			t[i] = sc.nextInt();
			x[i] = sc.nextInt();
			y[i] = sc.nextInt();
		}

		for (int i = 0; i < n; i++) {
			if (i == 0) {
				if (!can(t[i], 0, 0, x[i], y[i])) {
					System.out.println(""No"");
					return;
				}
			} else {
				if (!can(t[i] - t[i - 1], x[i - 1], y[i - 1], x[i], y[i])) {
					System.out.println(""No"");
					return;
				}
			}
		}
		System.out.println(""Yes"");
	}

	public static boolean can(int t, int sx, int sy, int ex, int ey) {
		if (t == 0) {
			return (sx == ex) && (sy == ey);
		}
		return can(t - 1, sx - 1, sy, ex, ey) || can(t - 1, sx + 1, sy, ex, ey) || can(t - 1, sx, sy - 1, ex, ey)
				|| can(t - 1, sx, sy + 1, ex, ey);
	}
}
"
113,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

    /**
     * @param args
     * @throws IOException
     * @throws NumberFormatException
     */
    public static void main(String[] args) throws NumberFormatException,
            IOException {

        BufferedReader reader = new BufferedReader(new InputStreamReader(
                System.in));

        int len = Integer.parseInt(reader.readLine());
        
        int[] arr = new int[len];

        String line;
        
        for (int i = 0; i < len; i++) {
            line = reader.readLine();
            arr[i] = Integer.parseInt(line);
        }
        
       int resultCount = 0; 
       for (int j = 0; j < arr.length; j++) {
           if(isPrime(arr[j])){
               resultCount ++;
           }
       }
       
       System.out.println(resultCount);

    }

    private static boolean isPrime(int value) {
        int count = 0;
        for (int i = 2; i < value; i++) {
            if(value % i == 0){
                count ++;
            }
        }
        return count == 0;
    }
    
    

}"
114,"import java.util.Scanner;
public class Main {
   public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int num = scan.nextInt();
        double a = (num);
        double b = a/2;
        double x = Math.ceil(b);
        double y = Math.floor(b);
        double z = x * y;
        int c = (int)z;
        System.out.println(c);
        scan.close();
    }
}"
115,"import java.util.*;

public class Main {
	int[][] matrix;
	int n, m;
	
	void print(){
		for(int i=0;i<n;i++){
			for(int j=0;j<n;j++){
				if(j!=0) System.out.print("" "");
				System.out.print(matrix[i][j]);
			}
			System.out.println();
		}
	}
	
	void Rotate(int r, int c, int size, int angle){
		int[][] temp = new int[size][size];
		for(int k=0;k<angle/90;k++){
			for(int i=0;i<size;i++){
				for(int j=0;j<size;j++){
					temp[i][j] = matrix[r+i][c+j];
				}
			}
			for(int i=0;i<size;i++){
				for(int j=0;j<size;j++){
					matrix[r+i][c+j] = temp[size-1-j][i];
				}
			}
		}
	}
	
	void Island(int r, int c){
		int p = matrix[r][c];
		int py = r;
		int px = c;
		int[] a = new int[]{0,0,1,-1};
		int[] b = new int[]{1,-1,0,0};
		ArrayDeque<Integer> y = new ArrayDeque<Integer>();
		ArrayDeque<Integer> x = new ArrayDeque<Integer>();
		y.add(r);
		x.add(c);
		while(y.size()!=0){
			py = y.poll();
			px = x.poll();
			if(matrix[py][px]==0) matrix[py][px] = 1;
			else matrix[py][px] = 0;
			for(int i=0;i<4;i++){
				if(0<=py+a[i] && py+a[i]<=n-1 && 0<=px+b[i] && px+b[i]<=n-1){
					if(matrix[py+a[i]][px+b[i]]==p){
						y.offer(py+a[i]);
						x.offer(px+b[i]);
					}
				}
			}
		}
	}
	
	void run(){
		Scanner sc = new Scanner(System.in);
		n = sc.nextInt();
		m = sc.nextInt();
		matrix = new int[n][n];
		for(int i=0;i<n;i++){
			for(int j=0;j<n;j++){
				matrix[i][j] = sc.nextInt();
			}
		}
		for(int i=0;i<m;i++){
			int o = sc.nextInt();
			int r = sc.nextInt()-1;
			if(o==0){
				int c = sc.nextInt()-1;
				int size = sc.nextInt();
				int angle = sc.nextInt();
				if(angle==90 || angle==180 || angle==270) Rotate(r, c, size, angle);
			}else if(o==1){
				int c = sc.nextInt()-1;
				int size = sc.nextInt();
				for(int j=0;j<size;j++){
					for(int k=0;k<size;k++){
						if(matrix[r+j][c+k]==0) matrix[r+j][c+k] = 1;
						else matrix[r+j][c+k] = 0;
					}
				}
			}else if(o==2){
				int temp = matrix[r][0];
				for(int j=0;j<n-1;j++) matrix[r][j] = matrix[r][j+1];
				matrix[r][n-1] = temp;
			}else if(o==3){
				int temp = matrix[r][n-1];
				for(int j=n-1;j>0;j--) matrix[r][j] = matrix[r][j-1];
				matrix[r][0] = temp;
			}else if(o==4){
				int c = sc.nextInt()-1;
				Island(r, c);
			}
		}
		print();
	}
	
	public static void main(String[] args) {
		new Main().run();
	}

}"
116,"import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;

class Node {
    Node parent;
    Node[] child;

    int number;
    String type;
    int depth;

    Node(int number) {
        this.number = number;
        this.parent = null;
        this.type = ""new"";
    }

    void setDepth(int dep) {
        this.depth = dep;
        if (!this.type.equals(""leaf"")) {
            for (Node x : this.child) {
                x.setDepth(dep + 1);
            }
        }
    }

}

class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int n = Integer.parseInt(br.readLine());

        Node[] tree = new Node[n];

        for (int i = 0; i < n; i++) {
            tree[i] = new Node(i);
        }

        for (int i = 0; i < n; i++) {
            String[] input = br.readLine().split("" "");

            int number = Integer.parseInt(input[0]);
            int k = Integer.parseInt(input[1]);
            if (k == 0) {
                tree[number].type = ""leaf"";
                continue;
            } else {
                tree[number].child = new Node[k];
                tree[number].type = ""internal node""; // rootのみ後で上書き
            }

            for (int j = 0; j < k; j++) {
                tree[number].child[j] = tree[Integer.parseInt(input[2 + j])];
                tree[Integer.parseInt(input[2 + j])].parent = tree[number];
            }

        }

        Node root = tree[0];

        // find root;
        while (root.parent != null) {
            root = root.parent;
        }

        root.type = ""root"";

        // set depth;
        root.setDepth(0);
        int rootNum = root.number;

        // display
        String format = ""node %d: parent = %d, depth = %d, %s, "";
        for (int i = 0; i < n; i++) {
            if (i != rootNum) {
                System.out.printf(format, i, tree[i].parent.number, tree[i].depth, tree[i].type);
            } else {
                System.out.printf(format, i, -1, tree[i].depth, tree[i].type);
            }

            System.out.print(""["");
            if (!tree[i].type.equals(""leaf"")) {
                int j;
                for (j = 0; j < tree[i].child.length - 1; j++) {
                    System.out.printf(tree[i].child[j].number + "", "");
                }
                System.out.print(tree[i].child[j].number);
            }
            System.out.println(""]"");
        }

    }
}
"
117,"import java.util.*;

public class Main {
    
  public static void main(String[] args) {
   
      Scanner sc = new Scanner(System.in);                      
               
      String s = """";
      
      String S = sc.next();
      
      for(int i = 0;i < S.length();i+=2){
          char ch = S.charAt(i);
          s += String.valueOf(ch);
      }
      
      System.out.println(s);
            
  }                
}"
118,"import java.io.*;
import java.util.*;

public class Main {
	static final int MOD = 1_000_000_007;

	public static void main(String[] args){
		FastScanner sc = new FastScanner(System.in);
		PrintWriter out = new PrintWriter(System.out);

		solve(sc,out);

		out.flush();
	}

	public static void solve(FastScanner sc, PrintWriter out) {
		int n = sc.nextInt();
		
		List<Pair<Integer,Integer>> list = new ArrayList<Pair<Integer,Integer>>();
		
		for(int i = 0; i < n; i++) {
			list.add(new Pair<Integer,Integer>(sc.nextInt(),sc.nextInt()));
		}
		
		list.sort((a,b) -> a.getValue() - b.getValue());
		
		long sum = 0;
		int end = 0;
		
		for(int i = 0; i < n; i++) {
			if(end != list.get(i).getValue()) {
				end = list.get(i).getValue();
				sum+=list.get(i).getKey();
			}else{
				sum+=list.get(i).getKey();
			}
			if(end < sum) {
				out.println(""No"");
				return;
			}
		}
		out.println(""Yes"");
		
	}

	public static long gcd(long a, long b) {
		if(a < b) return gcd(b, a);
		if(b == 0) return a;
		return gcd(b, a % b);
	}

	public static long lcm(long a, long b) {
		return a / gcd(a, b) * b;
	}

	public static long min(long... a) {
		long min = Long.MAX_VALUE;
		for(int i = 0; i < a.length; i++) {
			if(a[i] < min) min = a[i];
		}
		return min;
	}

	public static long max(long... a) {
		long max = Long.MIN_VALUE;
		for(int i = 0; i < a.length; i++) {
			if(a[i] > max) max = a[i];
		}
		return max;
	}
}

class Pair<K, V> extends AbstractMap.SimpleEntry<K, V> {

    public Pair(K key, V value) {
        super(key, value);
    }

    public Pair<V, K> swap() {
    	return new Pair<V, K>(getValue(), getKey());
    }
 }

class FastScanner {
    private BufferedReader reader = null;
    private StringTokenizer tokenizer = null;

    public FastScanner(InputStream in) {
        reader = new BufferedReader(new InputStreamReader(in));
        tokenizer = null;
    }

    public String next() {
        if (tokenizer == null || !tokenizer.hasMoreTokens()) {
            try {
                tokenizer = new StringTokenizer(reader.readLine());
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
        return tokenizer.nextToken();
    }

    public String nextLine() {
        if (tokenizer == null || !tokenizer.hasMoreTokens()) {
            try {
                return reader.readLine();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }

        return tokenizer.nextToken(""\n"");
    }

    public long nextLong() {
        return Long.parseLong(next());
    }

    public int nextInt() {
        return Integer.parseInt(next());
    }

    public double nextDouble() {
         return Double.parseDouble(next());
     }

    public int[] nextIntArray(int n) {
        int[] a = new int[n];
        for (int i = 0; i < n; i++)
            a[i] = nextInt();
        return a;
    }

    public long[] nextLongArray(int n) {
        long[] a = new long[n];
        for (int i = 0; i < n; i++)
            a[i] = nextLong();
        return a;
    }
}"
119,"import java.util.*;
import java.lang.*;
import java.io.*;
class Main
{
	public static void main (String[] args) throws IOException
	{
			BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		    int n=Integer.parseInt(br.readLine());
		    String st[]=br.readLine().trim().split("" "");
		    int a[]=new int[n];
		    int dp[]=new int[n];
		    int i;
      //System.out.println(""hello"");
		    for(i=0;i<n;i++){
		        a[i]=Integer.parseInt(st[i]);
		    }
		    dp[0]=0;
		    dp[1]=Math.abs(a[1]-a[0]);
		    for(i=2;i<n;i++){
		        dp[i]=Math.min(dp[i-1]+Math.abs(a[i]-a[i-1]),dp[i-2]+Math.abs(a[i]-a[i-2]));
		    }
		    System.out.println(dp[n-1]);
	}
}"
120,"import java.util.*;
public class Main{
    public static void main(String [] args){
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int K = sc.nextInt();
        int Q = sc.nextInt();
        int[]A = new int[N];
        for(int i = 0; i < N; i++) A[i] = K-Q;

        for(int i = 0; i < Q; i++){
            int a = sc.nextInt();
            A[a]++; 
        }

        for(int i = 0; i < Q; i++){
        if(A[i] > 0) System.out.println(""Yes"");
        else System.out.println(""No"");
    }


    }
} "
121,"import java.io.BufferedReader;
import java.io.Closeable;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map.Entry;

import java.util.PriorityQueue;
import java.util.Random;
import java.util.StringTokenizer;
import java.util.TreeSet;

public class Main {
	
	public static void main(String[] args) throws IOException {	
		try(final Scanner sc = new Scanner(System.in)){
			final int N = sc.nextInt();
			
			for(int i = 1; i <= N; i++) {
				final int cost = i * 108 / 100;
				
				if(cost == N) {
					System.out.println(i);
					return;
				}
			}
			
			System.out.println("":("");
		}
	}

	public static class Scanner implements Closeable {
		private BufferedReader br;
		private StringTokenizer tok;

		public Scanner(InputStream is) throws IOException {
			br = new BufferedReader(new InputStreamReader(is));
		}

		private void getLine() throws IOException {
			while(!hasNext()){
				tok = new StringTokenizer(br.readLine());
			}
		}

		private boolean hasNext() {
			return tok != null && tok.hasMoreTokens();
		}

		public String next() throws IOException {
			getLine();
			return tok.nextToken();
		}

		public int nextInt() throws IOException {
			return Integer.parseInt(next());
		}

		public long nextLong() throws IOException {
			return Long.parseLong(next());
		}
		

		public double nextDouble() throws IOException {
			return Double.parseDouble(next());
		}

		public int[] nextIntArray(int n) throws IOException {
			final int[] ret = new int[n];
			for(int i = 0; i < n; i++){
				ret[i] = this.nextInt();
			}
			return ret;
		}

		public long[] nextLongArray(int n) throws IOException {
			final long[] ret = new long[n];
			for(int i = 0; i < n; i++){
				ret[i] = this.nextLong();
			}
			return ret;
		}

		public void close() throws IOException {
			br.close();
		}
	}
}"
122,"import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Scanner;

class Main {
	public static void main(String[] args) throws IOException {
		new Main().run();
	}

	void run() {
		Scanner sc = new Scanner(System.in);
		PrintWriter pw = new PrintWriter(System.out);
		int N = sc.nextInt();
		long L = sc.nextLong();
		double[] t = new double[N];
		double[] v = new double[N];
		for (int i = 0; i < N; ++i) {
			t[i] = sc.nextDouble();
			v[i] = sc.nextDouble();
		}
		class T {
			double water;
			double salt;

			public T(double water, double salt) {
				this.water = water;
				this.salt = salt;
			}
		}

		ArrayDeque<Double> dequeW = new ArrayDeque<>();
		ArrayDeque<Double> dequeS = new ArrayDeque<>();
		dequeS.add(0d);
		dequeW.add(0d);
		dequeS.addLast(t[0] * v[0]);
		dequeW.addLast(v[0]);
		T p = new T(0, 0);
		pw.println(t[0]);
		for (int i = 1; i < N; ++i) {
			p.water += v[i];
			p.salt += t[i] * v[i];
			dequeW.addFirst(-p.water);
			dequeS.addFirst(-p.water * p.salt);

			while (dequeS.size() >= 2) {
				double t2w = dequeW.pollLast();
				double t2s = dequeS.pollLast();
				double t1w = dequeW.pollLast();
				double t1s = dequeS.pollLast();
				if (t1w + p.water > L && t2w + p.water > L)
					continue;
				if (t1w + p.water == L) {
					dequeW.addLast(t1w);
					dequeS.addLast(t1s);
					break;
				}
				if (t1w + p.water < L && L < t2w + p.water) {
					double r1 = (t2w + p.water - L) / (t2w - t1w);
					double r2 = (L - (t1w + p.water)) / (t2w - t1w);
					double tLasts = r1 * (t1s + p.salt) + r2 * (t2s + p.salt);
					double tLastw = r1 * (t1w + p.water) + r2 * (t2w + p.water);

					tLastw -= p.water;
					tLasts -= p.salt;
					dequeS.addLast(t1s);
					dequeW.addLast(t1w);

					dequeS.addLast(tLasts);
					dequeW.addLast(tLastw);
					break;
				}
			}
			dequeS.pollFirst();
			dequeW.pollFirst();

			while (dequeS.size() >= 2) {
				double t1s = dequeS.pollFirst();
				double t1w = dequeW.pollFirst();
				double t2s = dequeS.pollFirst();
				double t2w = dequeW.pollFirst();
				if ((t1s + p.salt) / (t1w + p.water) > (t2s + p.salt) / (t2w + p.water)) {
					dequeS.addFirst(t2s);
					dequeW.addFirst(t2w);
					dequeS.addFirst(t1s);
					dequeW.addFirst(t1w);
					break;
				}
				dequeS.addFirst(t2s);
				dequeW.addFirst(t2w);
			}
			dequeS.addFirst(-p.salt);
			dequeW.addFirst(-p.water);

			pw.println((dequeS.peekLast() + p.salt) / (dequeW.peekLast() + p.water));
		}
		pw.close();

	}

	void tr(Object... objects) {
		System.out.println(Arrays.deepToString(objects));
	}
}"
123,"import java.util.Scanner;

public class Main {
	private static final String[] reversedWords = {""dream"", ""dreamer"", ""erase"", ""eraser""};

	public static void main(String[] args) {
		String s;
		try (Scanner scanner = new Scanner(System.in)) {
			s = scanner.next();
		}

		int stringLength = s.length();
		boolean canDevide = true;
		while (canDevide && stringLength > 0) {
			canDevide = false;
			for (String word: Main.reversedWords) {
				if (s.substring(0, stringLength).endsWith(word)) {
					canDevide = true;
					stringLength -= word.length();
				}
			}
		}

		if (canDevide) {
			System.out.println(""YES"");
		} else {
			System.out.println(""NO"");
		}
	}
}"
124,"import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ
		Scanner scan = new Scanner(System.in);
		
		long a = scan.nextLong();
		long b = scan.nextLong();
		long c = scan.nextLong();
		long k = scan.nextLong();
		long ans = 0;
		
		for(int i = 0; i < k; i++) {
			
			if(a > 0) {
				ans++;
				a--;
			}
			else if(b > 0) {
				b--;
			}
			else {
				ans--;
			}
		}
		
		System.out.println(ans);

	}

}
"
125,"import java.io.*;
import java.util.*;
import java.lang.ArrayIndexOutOfBoundsException;
import java.math.BigInteger;

/**
 * @author yoshikyoto
 */
class Main {
	public static void main(String[] args) throws Exception{
		
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int m = Integer.parseInt(br.readLine());
		
		long[] cnt = new long[2];
		
		for (int i = 0; i < m; i++) {
			String[] in = br.readLine().split("" "");
			int c = (int)(in[1].charAt(0) - '(');
			int n = Integer.parseInt(in[2]);
			cnt[c] += n;
			if(cnt[0] == cnt[1]){
				System.out.println(""Yes"");
			}else{
				System.out.println(""No"");
			}
		}
	}
}

// --- ここから下はライブラリ ----------
/**
 * MyUtil
 * @author yoshikyoto
 */
class MyUtil {
	public static int toInt(boolean[] a){
		int pow = 1, ret = 0, l = a.length;
		for(int i = 0; i < l; i++){
			if(a[i]) ret += pow;
			pow *= 2;
		}
		return ret;
	}
	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	public static int ins[];
	public static int[] readIntMap() throws IOException{return parseInt(readLine().split("" ""));}
	public static int readIntMap(int i) throws Exception{
		if(i == 0) ins = readIntMap();
		return ins[i];
	}
	public static int[][] readIntMap(int n, int m) throws IOException{
		int[][] ret = new int[n][];
		for(int i = 0; i < n; i++) ret[i] = readIntMap();
		return ret;
	}
	public static int[] readIntToMap(int n) throws IOException{
		int[] ret = new int[n];
		for(int i = 0; i < n; i++) ret[i] = readInt();
		return ret;
	}
	public static int[] readNoDistIntMap() throws IOException{
		String[] strs = readLine().split("""");
		int l = strs.length;
		int[] ret = new int[l-1];
		for(int i = 1; i < l; i++)
			ret[i-1] = parseInt(strs[i]);
		return ret;
	}
	public static String readLine() throws IOException{return br.readLine();}
	public static int readInt() throws IOException{return Integer.parseInt(br.readLine());}
	public static int[] parseInt(String[] arr){
		int[] res = new int[arr.length];
		for(int i = 0; i < arr.length; i++)res[i] = Integer.parseInt(arr[i]);
		return res;
	}
	public static double[] parseDouble(String[] arr){
		double[] res = new double[arr.length];
		for(int i = 0; i < arr.length; i++)res[i] = Double.parseDouble(arr[i]);
		return res;
	}
	public static boolean[] parseBool(String[] arr){
		int[] t = parseInt(arr);
		boolean[] res = new boolean[t.length];
		for(int i = 0; i < t.length; i++){
			if(t[i] == 1){res[i] = true;
			}else{res[i] = false;}
		}
		return res;
	}
	public static int parseInt(Object o){
		return Integer.parseInt(o.toString());
	}
}"
126,"class Test{
	static int hour(int i) {
		return i / 3600;
	}

	static int minits(int i) {
		int a = i % 3600;
		return a / 60;
	}

	static int sec(int i) {
		int a = i % 3600;
		int b = a % 60;
		return b ;
	}

	public static void main(String[] args) {
		int i = 46979;

		System.out.println(""h :"" + hour(i) + ""m :"" + minits(i) + ""s :"" + sec(i));
	}

}
"
127,"a, b, c = (int(x) for x in input().split())
if b - a == c - b:
  print('YES')
else:
  print('NO')"
128,"import java.util.*;
import java.io.*;
import java.math.*;
 
public class Main
{
    static int deal_with(int money, int stocks, int day, int n, int arr[]){
        if(day > n)
            return money;

        if(dp[money][stocks][day] != -1)
            return dp[money][stocks][day];

        //sell stock
        for(int i = 0; i <= stocks; i++){ 
            dp[money][stocks][day] =  Math.max(dp[money][stocks][day],
                   deal_with(money + arr[day] * i, stocks - i, day + 1, n, arr));


        }

        //buy stock
        int buy = 0;
        while((buy + 1) * arr[day] <= money){
            buy++;
            dp[money][stocks][day] = Math.max(dp[money][stocks][day],
                deal_with(money - (arr[day] * buy), stocks + buy, day + 1, n, arr));
        }
        //if(day == n) trace(dp[money][stocks][day]);
        return dp[money][stocks][day];
    }

    public static void process(int test_number)throws IOException
    {
        int n = ni(), arr[] = new int[n+1];
        for(int i = 1; i <= n; i++)
            arr[i] = ni();

        //dp = new int[1600 + 10][1000+1][80 + 1];
        for(int ht[][] : dp)
            for(int w[] : ht)
                Arrays.fill(w, -1);

        pn(deal_with(1000, 0, 1, n, arr));
    }
    static int dp[][][] = new int[16000+10][200 +1][80 + 1];
    static final long mod = (long)1e9+7l;
    
    static FastReader sc;
    static PrintWriter out;
    public static void main(String[]args)throws IOException
    {
        out = new PrintWriter(System.out);
        sc = new FastReader();
 
        long s = System.currentTimeMillis();
        int t = 1;
        //t = ni();
        for(int i = 1; i <= t; i++)
            process(i);
 
        out.flush();
        //System.err.println(System.currentTimeMillis()-s+""ms"");
    }

    static void trace(Object... o){ System.err.println(Arrays.deepToString(o)); };
    static void pn(Object o){ out.println(o); }
    static void p(Object o){ out.print(o); }
    static int ni()throws IOException{ return Integer.parseInt(sc.next()); }
    static long nl()throws IOException{ return Long.parseLong(sc.next()); }
    static double nd()throws IOException{ return Double.parseDouble(sc.next()); }
    static String nln()throws IOException{ return sc.nextLine(); }
    static long gcd(long a, long b)throws IOException{ return (b==0)?a:gcd(b,a%b);}
    static int gcd(int a, int b)throws IOException{ return (b==0)?a:gcd(b,a%b); }
    static int bit(long n)throws IOException{ return (n==0)?0:(1+bit(n&(n-1))); }
    
    static class FastReader{ 
        BufferedReader br; 
        StringTokenizer st; 
  
        public FastReader(){ 
            br = new BufferedReader(new InputStreamReader(System.in)); 
        } 
  
        String next(){ 
            while (st == null || !st.hasMoreElements()){ 
                try{ st = new StringTokenizer(br.readLine()); } catch (IOException  e){ e.printStackTrace(); } 
            } 
            return st.nextToken(); 
        } 
  
        String nextLine(){ 
            String str = """"; 
            try{ str = br.readLine(); } catch (IOException e) { e.printStackTrace(); } 
            return str; 
        } 
    } 
}
"
129,"import java.util.*;
import java.lang.*;
import java.io.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String S = sc.next();
        int N = S.length();
        boolean[] dp = new boolean[N];
        for(int n=0;n<N;n++){
        	String cut = S.substring(0,n+1);
        	if(cut.endsWith(""dream"")&&n>=4) dp[n]=dp[n]||(n==4)||dp[n-5];
        	if(cut.endsWith(""dreamer"")&&n>=6) dp[n]=dp[n]||(n==6)||dp[n-7];
        	if(cut.endsWith(""erase"")&&n>=4) dp[n]=dp[n]||(n==4)||dp[n-5];
        	if(cut.endsWith(""eraser"")&&n>=5) dp[n]=dp[n]||(n==5)||dp[n-6];
        }
        System.out.println(dp[N-1] ? ""YES"" : ""NO"");
    }
}
"
130,"import java.io.File;
iimport java.io.File;
import java.io.IOException;
import java.util.Scanner;
import java.io.IOException;
import java.util.Scanner;

class Main{
    public static void main(String[] a){
Scanner file = new Scanner(""System.in"");
		
		try {
			Scanner input = new Scanner(file);
			String OrigWord = input.nextLine();
			int OrigLen = OrigWord.length(); 
			String NewWord = """";
			for (int x=OrigLen-1; x >= 0; x--){
				
				NewWord = NewWord + (OrigWord.charAt(x)); 
				
			}
			
			
			System.out.println(NewWord);
		}
		catch (IOException ex) {
			System.out.println(ex);
			}
    }
}"
131,"import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Scanner;

public class Main {
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);

		while(true){
			final int N = sc.nextInt();
			
			if(N == 0){
				break;
			}
			
			int[] own = new int[N];
			//int[] ene = new int[N];
			ArrayList<Integer> ene = new ArrayList<Integer>();
			
			for(int i = 0; i < N; i++){
				own[i] = -sc.nextInt();
			}
			Arrays.sort(own);
			for(int i = 0; i < N; i++){
				own[i] = -own[i];
			}
			
			
			for(int i = 0; i < N; i++){
				ene.add(sc.nextInt());
			}
			Collections.sort(ene);
			/*
			for(int i = 0; i < N; i++){
				ene[i] = -ene[i];
			}
			*/
			/*
			int[] sum = new int[N];
			for(int i = 0; i < N; i++){
				sum[i] = own[i] > ene[i] ? 1 : 0;
			}
			for(int i = 1; i < N; i++){
				sum[i] += sum[i - 1];
			}
			*/
			
			//System.out.println(Arrays.toString(sum));
			
			
			boolean flag = false;
			int win_count = 0;
			for(int K = 1; K < N; K++){
				final int must = K / 2 + 1;
				final int own_num = own[K - 1];
				
				int pos = Collections.binarySearch(ene, own_num);
				
				if(pos < 0){
					pos = -(pos + 1);
				}
				
				if(pos >= ene.size()){
					win_count++;
				}else if(own_num > ene.get(pos)){
					win_count++;
				}
				
				if(win_count >= must){
					flag = true;
					System.out.println(K);
					break;
				}
				
				if(ene.size() > pos){
					ene.remove(pos);
				}else{
					ene.remove(0);
				}
			}
			
			if(!flag){
				System.out.println(""NA"");
			}
			
		}
		
		sc.close();
	}
}"
132,"import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ
		Scanner scan = new Scanner(System.in);
		int N=scan.nextInt();
		String s=scan.next();
		long K =Long.parseLong(s);

		int[][] ab = new int[N][2];
		for(int i=0;i<N;i++){
			ab[i][0]=scan.nextInt();
			ab[i][1]=scan.nextInt();
		}


		Arrays.sort(ab,new Comparator<int[]>(){
			@Override
			public int compare(int[] o1,int[] o2){
				return o1[0] -o2[0];
			}
		});

		int cnt=0;
		long ans=0;
		while(true){
			long k =ab[cnt][1];
			K-=k;
			if(K<=0){
				ans = ab[cnt][0];
				break;
			}
			cnt++;

		}
		System.out.println(ans);
	}

}
"
133,"import java.io.*;
import java.util.Arrays;
import java.util.StringTokenizer;

public class Main {

    public static void main(String[] args) throws IOException {
        init();
        int n = nextInt();
        long[] a = new long[n];
        for (int i = 0; i < n; i++) a[i] = nextLong();

        long[][][] prefixSum = new long[n][62][2];

        long mod = 1000000007;
        for (int i = 0; i < n; i++) {
            long num = a[i];
            for (int j = 0; j < prefixSum[i].length; j++) {
                int bit = (int)((num & (1L<<j))>>j);
                prefixSum[i][j][bit]++;
            }
        }

        for (int i = 1; i < n; i++) {
            for (int j = 0; j < prefixSum[i].length; j++) {
                prefixSum[i][j][0] += prefixSum[i - 1][j][0];
                prefixSum[i][j][1] += prefixSum[i - 1][j][1];
            }
        }

        long ans = 0;
        for (int j = 0; j < prefixSum[0].length; j++) {
            long sum = 0;
            long twoPow = (1L << j);
            for (int i = 0; i < n; i++) {
                long num = a[i];
                int bit = (int)((num & twoPow)>>j);
                sum = (sum + prefixSum[n - 1][j][(bit + 1) % 2] - prefixSum[i][j][(bit + 1) % 2]) % mod;
            }

            sum = (sum * (twoPow % mod)) % mod;
            ans = (ans + sum) % mod;
        }

        System.out.println(ans);
//        System.out.println(bruteForce(a, mod));
    }

//    private static long bruteForce(long[] nums, long mod) {
//        long ans = 0;
//        for (int i = 0; i < nums.length; i++) {
//            for (int j = i + 1; j < nums.length; j++) {
//                ans = (ans + (nums[i] ^ nums[j])) % mod;
//            }
//        }
//        return ans;
//    }

    //Input Reader
    private static BufferedReader reader;
    private static StringTokenizer tokenizer;

    private static void init() {
        reader = new BufferedReader(new InputStreamReader(System.in));
        tokenizer = new StringTokenizer("""");
    }

    private static String next() throws IOException {
        String read;
        while (!tokenizer.hasMoreTokens()) {
            read = reader.readLine();
            if (read == null || read.equals(""""))
                return ""-1"";
            tokenizer = new StringTokenizer(read);
        }

        return tokenizer.nextToken();
    }

    private static int nextInt() throws IOException {
        return Integer.parseInt(next());
    }

    private static long nextLong() throws IOException {
        return Long.parseLong(next());
    }
}"
134,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        int K-
        int a,b,c;
        try (Scanner sc = new Scanner(System.in)) {
            K = sc.nextInt();
        }
        a = b = c =  K;
        long result = 0;
        for (int i = 1; i <= a; i++) {
            for (int j = 1; j <= b; j++) {
                for (int k = 1; k <= c; k++) {
                    long temp = gcd((long)i,(long)j);
                    temp = gcd(temp,(long)k);
                    result += temp;
                }
            }
        }
        System.out.println(result);
    }

    //最大公約数
    static long gcd(long a, long b) {
        long temp;
        while ((temp = a % b) != 0) {
            a = b;
            b = temp;
        }
        return (long) b;
    }
}
"
135,"

import java.util.ArrayList;
import java.util.Scanner;

public class Main{

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int input_length = 0;
		// マップの高さ
		int height = 0;
		// マップの幅
		int width = 0;
		// 各完成マップを入れる配列
		ArrayList<map> map_list = new ArrayList<map>();
		// 入力の回数
		while (sc.hasNext()) {
			input_length = sc.nextInt();

			// 入力回数分ゲームをする
			for (int i = 0; i < input_length; i++) {

				// マップの高さ
				height = sc.nextInt();
				// マップの幅
				width = sc.nextInt();

				// マップのインスタンスを作る
				map map = new map();
				// 戦車のインスタンスを作る
				tank tank = new tank();
				map.setMap(height, width);

				String line = null;
				// マップ作成
				for (int h = 0; h < height; h++) {
					// マップ一列
					line = sc.next();
					// 一文字ずつに分解
					char[] line_char = line.toCharArray();
					//
					for (int w = 0; w < width; w++) {
						// マップを作る
						map.createMap(h, w, String.valueOf(line_char[w]));
					}
				}

				int command_number = 0;
				String command_attack = """";
				// コマンド入力回数

				command_number = sc.nextInt();

				// コマンドの文字列
				char[] command_at = null;

				command_attack = sc.next();
				// ひとつずつ配列に入れる
				command_at = command_attack.toCharArray();

				// コマンド回数分まわす
				for (int c = 0; c < command_number; c++) {
					// タンクの現在位置を把握
					tank.searchTank(map.getMap());
					// 砲弾発射だったら
					if (String.valueOf(command_at[c]).equals(""S"")) {
						// マップを砲弾発射用に変更
						map.shuttGun(tank.getNow_height(), tank.getNow_width(),
								tank.getSituation());
					} else {
						// 移動の場合
						map.move_tank(tank.getNow_height(),
								tank.getNow_width(),
								String.valueOf(command_at[c]));
					}

				}
				// リストにできたマップを格納
				map_list.add(map);
			}
			// 結果を出力
			for (map obj : map_list) {
				obj.out_map();
				// 改行
				System.out.print(""\n"");
			}
			sc.close();
		}
	}

}

class tank {

	// 戦車の位置
	// 現在の高さ
	private int now_height = 0;
	// 現在の幅
	private int now_width = 0;

	// 戦車をあらわす記号
	public static final String[] tank_element = { ""<"", "">"", ""^"", ""v"" };

	// 戦車の向き
	private String situation = null;

	// 現在位置と向きを探す 全体のマップの高さ
	public void searchTank(String[][] map_all) {
		for (int h = 0; h < map_all.length; h++) {
			for (int w = 0; w < map_all[0].length; w++) {

				// 戦車がどこかにいるはず
				for (String val : tank_element) {
					if (map_all[h][w].equals(val)) {
						// 戦車の位置情報と向きを入力
						now_height = h;
						now_width = w;
						situation = val;
					}
				}
			}
		}

	}

	public void setSituation(String s) {
		situation = s;
	}

	// ゲッター

	public String getSituation() {
		return situation;
	}

	public int getNow_height() {
		return now_height;
	}

	public int getNow_width() {
		return now_width;
	}

}

class map {

	// 現在のマップ
	private String[][] map = null;

	// セッター
	public void setMap(int h, int w) {
		map = new String[h][w];
	}

	// マップを作る
	public void createMap(int height_i, int width_i, String m) {
		map[height_i][width_i] = m;
	}

	// // 砲弾によるマップ変更 現在位置 向き
	public void shuttGun(int now_h, int now_w, String s) {
		// 左向き
		if (s.equals(""<"")) {
			// マップの先が何もない場合は、なにもしない
			if (now_w == 0) {
			} else

				//
				for (int i = 0; i <= now_w; i++) {
					// レンガ壁だったら平地に
					if (map[now_h][now_w - i].equals(""*"")) {
						map[now_h][now_w - i] = ""."";
						break;
					}
					// 鉄壁だったら変更なし
					if (map[now_h][now_w - i].equals(""#"")) {
						break;
					}
				}
		}
		// 右向き
		if (s.equals("">"")) {
			// マップの先が何もない場合は、なにもしない
			if (now_w == (map[0].length - 1)) {
			} else

				for (int i = 0; i <= (map[0].length - now_w); i++) {
					// レンガ壁だったら平地に
					if (map[now_h][now_w + i].equals(""*"")) {
						map[now_h][now_w + i] = ""."";
						break;
					}
					// 鉄壁だったら変更なし
					if (map[now_h][now_w + i].equals(""#"")) {
						break;
					}
				}

		}
		// 上向き
		if (s.equals(""^"")) {
			// マップの先が何もない場合は、なにもしない
			if (now_h == 0) {
			} else

				for (int i = 0; i <= now_h; i++) {
					// レンガ壁だったら平地に
					if (map[now_h - i][now_w].equals(""*"")) {
						map[now_h - i][now_w] = ""."";
						break;
					}
					// 鉄壁だったら変更なし
					if (map[now_h - i][now_w].equals(""#"")) {
						break;
					}
				}

		}
		// 下向き
		if (s.equals(""v"")) {
			// マップの先が何もない場合は、なにもしない
			if (now_h == (map.length - 1)) {
			} else
				for (int i = 0; i <= (map.length - now_h); i++) {
					// レンガ壁だったら平地に
					if (map[now_h + i][now_w].equals(""*"")) {
						map[now_h + i][now_w] = ""."";
						break;
					}
					// 鉄壁だったら変更なし
					if (map[now_h + i][now_w].equals(""#"")) {
						break;
					}
				}
		}

	}

	// 戦車の移動によるマップ変更,向き変更 現在位置 方向
	public void move_tank(int now_h, int now_w, String s) {
		// 左向き
		if (s.equals(""L"")) {
			// 左のマスが平地だったら左に進む
			// マップの先がなにもないときはなにもしない
			if (now_w == 0) {
				map[now_h][now_w] = ""<"";
			}
			// 平地マスへ移動
			else if (map[now_h][now_w - 1].equals(""."")) {
				// 戦車を進める
				map[now_h][now_w - 1] = ""<"";
				// 元いた位置は平地
				map[now_h][now_w] = ""."";
			} else {
				// 平地マス以外は向き変え
				map[now_h][now_w] = ""<"";
			}

		}
		// 右向き
		if (s.equals(""R"")) {
			// 右のマスが平地だったら右に進む
			// マップの先がなにもないときはなにもしない
			if (now_w == (map[0].length - 1)) {
				map[now_h][now_w] = "">"";
			}
			// 平地マスへ移動
			else if (map[now_h][now_w + 1].equals(""."")) {
				// 戦車を進める
				map[now_h][now_w + 1] = "">"";
				// 元いた位置は平地
				map[now_h][now_w] = ""."";
			} else {
				// 平地マス以外は向き変え
				map[now_h][now_w] = "">"";
			}
		}
		// 下向き
		if (s.equals(""D"")) {
			// 下のマスが平地だったら下に進む
			// マップの先がなにもないときはなにもしない
			if (now_h == (map.length - 1)) {
				map[now_h][now_w] = ""v"";
			} else if (map[now_h + 1][now_w].equals(""."")) {
				// 戦車を進める
				map[now_h + 1][now_w] = ""v"";
				// 元いた位置は平地
				map[now_h][now_w] = ""."";
			} else {
				// 平地マス以外は向き変え
				map[now_h][now_w] = ""v"";
			}
		}
		// 上向き
		if (s.equals(""U"")) {
			// 上のマスが平地だったら上に進む
			// マップの先がなにもないときはなにもしない
			if (now_h == 0) {
				map[now_h][now_w] = ""^"";
			}
			// 平地マスへ移動
			else if (map[now_h - 1][now_w].equals(""."")) {
				// 戦車を進める
				map[now_h - 1][now_w] = ""^"";
				// 元いた位置は平地
				map[now_h][now_w] = ""."";
			} else {
				// 平地マス以外は向き変え
				map[now_h][now_w] = ""^"";
			}
		}

	}

	// マップを出力
	public void out_map() {
		for (int h = 0; h < map.length; h++) {
			for (int w = 0; w < map[0].length; w++) {
				System.out.print(map[h][w]);
			}
			System.out.print(""\n"");
		}
	}

	// ゲッター
	public String[][] getMap() {
		return map;
	}

}"
136,"import java.util.Scanner;

class Main{

	static char[][] map;
	static int H;
	static int W;
	static	int D ;
	static	int G ;
	static	int[] p;
	static	int[] c;
	static int ans = 100000000;

	public static void main(String[] args) {



		Scanner sc = new Scanner(System.in);			//文字の入力
		D = sc.nextInt();
		G = sc.nextInt();
		p = new int[D+1];
		c = new int[D+1];

		for(int i = 1;i < D+1;i++){
			p[i] = sc.nextInt();
			c[i] = sc.nextInt();
		}

		for(int i = p[D];i >= 0;i--){			//一番でかい問題の個数でdfs
			if(i == p[D]){
				dfs(D-1,i,100*D*i+c[D]);


			}else{

				dfs(D-1,i,100*D*i);
			}
		}

		System.out.println(ans);

	}

	static void dfs(int mondai,int sum,int score){			//numは数、mondaiは問題番号,sumは問題をといた数

		
		if(score >= G){
			ans = Math.min(ans, sum);
			return;
		}
		if(mondai < 1){
			return;
		}

		for(int i = p[mondai];i >= 0;i--){
			if(sum >= ans){
				return;
			}

			
			if(i == p[mondai]){
				dfs( mondai-1, sum+i, score+100*mondai*i+c[mondai]);

			}else{

				dfs( mondai-1, sum+i, score+100*mondai*i);
			}
		}

		return;





	}


}



"
137,"import java.util.Scanner;
public class Main{
  public static void main(String[] args){
    Scanner sc = new Scanner(System.in);
    String str = sc.nextLine();
    int count = 0;
    for(int i = 0; i < str.length()-2;str++){
      if(str.charAt(i).equals('A')){
        if(str.charAt(i+1).equals('B')){
          if(str.charAt(i+2).equals('C')){
            count++;
          }
        }
      }
    }
    System.out.println(count);
  }
}
"
138,"import java.util.*;
class Main{
	public static void main(String[] a){
		Scanner scan = new Scanner(System.in);
		int[] top = new int[10];
		for(int i = 0; i < 10; i++){
			top[i] = scan.nextInt();
		}
		for(int i = 0; i < 10; i++){
			for(int j = 9; j > i; j--){
				if(top[j] > top[j-1]){
					int multi = top[j];
					top[j] = top[j-1];
					top[j-1] = multi;
				}
			}
		}
		System.out.println(top[0]);
		System.out.println(top[1]);
		System.out.println(top[2]);
	}
}"
139,"
import java.util.*;

public class Main {
	static Scanner sc = new Scanner(System.in);
	
	void doIt(){
		Person [][] record = new Person[3][8];
		Person [] others = new Person[6];
		int c=0;
		for(int i=0;i<3;i++){
			for(int j=0;j<8;j++){
				record[i][j] = new Person(sc.nextInt(),sc.nextDouble());
			}
		}
		for(int i=0;i<3;i++){
			Arrays.sort(record[i]);
			System.out.println(record[i][0].toString() + ""\n"" + record[i][1].toString());
			others[c++] = record[i][2];
			others[c++] = record[i][3];
		}
		Arrays.sort(others);
		System.out.println(others[0].toString() + ""\n"" + others[1].toString());		
	}

	public static void main(String[] args) {
		new Main().doIt();
	}
	
	class Person implements Comparable<Person>{
		int number;
		double time;
		Person(int number , double time){
			this.number = number;
			this.time = time;
		}
		@Override
		public String toString() {
			return number + "" "" + time;
		}
		@Override
		public int compareTo(Person o) {
			if(time<o.time){
				return -1;
			}else if(time == o.time){
				return 0;
			}else{
				return 1;				
			}
		}
	}
}"
140,"import java.util.Scanner;
public class Main {
   public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int x = scan.nextInt();
        int a = (x/2+x%2)*x/2);
        System.out.println(a);
        scan.close();
    }
}
"
141,"import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        Vector<Integer> vec = new Vector<>();
        int q = sc.nextInt();
        for(int i = 0 ; i < q ; i++){
            char c = sc.next().charAt(0);
            switch(c){
            case '0' : vec.add(Character.getNumericValue(sc.next().parseInt())); break;
            case '1' : System.out.println(vec.elementAt(Character.getNumericValue(sc.next().parseInt())); break;
            case '2' : vec.remove(vec.size()-1); break;
            }
        }
    }
}
"
142,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Apayment {

	public static void main(String[] args) {
	    // 1000の倍数の場合はお釣りは必ず0円となる
	    // 1000の倍数でない場合は、1000-（N円の1の位～百の位）がお釣りとなる
	    int answer = 0;
	    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	    try{
	        String str = br.readLine();
	        int n = Integer.parseInt(str);

	        if (n % 1000 != 0) {
	            System.out.println(answer);
	        } else {
	            answer = 1000 - (n % 1000);
	            System.out.println(answer);
	        }

	    } catch (IOException ioe) {

	    }
	}

}
"
143,"import java.util.Arrays;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] a = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            a[i] = sc.nextInt();
        }

        // 後ろから順にボールが入っているかをXORで計算していく
        int[] ball = new int[n + 1];
        for (int i = n; i >= 1; i--) {
            int sum = 0;
            System.err.printf(""\n%s \n"", i);
            for (int j = i + i; j <= n; j += i) {
                // i倍数の部分だけ計算しなおす
                sum ^= ball[j];
                System.err.printf("" (%s)->%s\n"", j, sum);
            }
            // iとXORする
            ball[i] = sum ^ a[i];
            echo(ball);
        }

        int ballCount = (int) Arrays.stream(ball).filter(s -> s != 0).count();
        if (ballCount == 0) {
            System.out.println(0);
        } else {
            // 先にボールの個数を出力して、それ以外はボールが入っている場所だけ出力
            System.out.println(ballCount);
            for (int i = 1; i <= n; i++) {
                if (ball[i] == 0) {
                    continue;
                }
                System.out.println(ball[i]);
            }
        }
    }

    private static void echo(int[] b) {
        System.err.print(""["");
        for (int i = 0; i < b.length; i++) {
            System.err.printf(""%s "", b[i]);
        }
        System.err.println(""]"");
    }
}

"
144,"import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = Integer.parseInt(scanner.next());

        int count = 0;
        List<Integer> sieve = createSieve();
        for (int i = 0; i < n; i++) {
            int x = Integer.parseInt(scanner.next());
            if (sieve.contains(x)) {
                count++;
            }
        }

        System.out.println(count);
    }

    private static List<Integer> createSieve() {
        List<Integer> sieve = new ArrayList<>();
        for (int i = 2; i <= 100000000; i++) {
            sieve.add(i);
        }

        for (int i = 0; ; i++) {
            if (i > sieve.size() - 1) {
                break;
            }
            int minp = sieve.get(i);
            for (int j = 2; ; j++) {
                int removed = minp * j;
                if (removed > sieve.get(sieve.size() - 1)) {
                    break;
                }
                sieve.remove((Integer) removed);
            }
        }

        return sieve;
    }
}"
145,"import java.util.Arrays;
import java.util.Scanner;


public class BubbleSort {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) nums[i] = scanner.nextInt();

        bubbleSort(n, nums);
    }

    private static void bubbleSort(int n, int[] a) {
    	boolean flg = true;
    	int i = 0;
    	int sw = 0;
    	while (flg) {
    		flg = false;
    		for (int j = n - 1; j > i; j--) {
    			if (a[j] < a[j-1]) {
    				int w = a[j];
    				a[j] = a[j-1];
    				a[j-1] = w;
    				sw++;
    				flg = true;
    			}
    		}
    		i++;
    	}
    	trace(a);
    	System.out.println(sw);
    }

    private static void trace(int[] nums) {
    	System.out.println(Arrays.toString(nums).replaceAll(""[\\[\\],]"", """"));
    }

}
"
146,"import java.util.*;
public class Main {
	public static void main(String[] args){
    	Scanner sc = new Scanner(System.in);
    	int n = sc.nextInt();
    	int m = sc.nextInt();
    	int k = sc.nextInt();
    	int[] except = new int[n];
    	prepare(n);

    	for (int i = 0; i < m; i++) {
    		int a = sc.nextInt()-1;
    		int b = sc.nextInt()-1;
    		union(a,b);
    		except[a]++;
    		except[b]++;
    	}
    	for (int i = 0; i < k; i++) {
    		int a = sc.nextInt()-1;
    		int b = sc.nextInt()-1;
    		if(find(a) == find(b)){
    		except[a]++;
    		except[b]++;
            }
    	}


    	for (int i = 0; i < n; i++) {
	    	System.out.print(desc[find(i)]-except[i] + "" "");
	    }
    }
	private static int[] parent;
	private static int[] desc;

	private static void prepare(int n) {
		parent = new int[n];
		for (int i = 0; i < n; i++) {
			parent[i] = i;
		}
		desc = new int[n];
	}

	private static void union(int a, int b) {
		int xroot = find(a);
		int yroot = find(b);
		if (xroot == yroot) return;
		if (desc[xroot] >- desc[yroot]) {
			parent[yroot] = xroot;
			desc[xroot] += desc[yroot]+1;
		} else {
			parent[xroot] = yroot;
			desc[yroot] += desc[xroot]+1;
		}
	}

	private static int find(int a) {
		if (parent[a] == a) {
			return a;
		} else {
			return find(parent[a]);
		}
	}
}

"
147,"import java.util.*;

public class Main{
  public static void main(String[]args){
    Scanner sc = new Scanner(System.in);
    String S  = sc.nextLine();
    boolean check = true;
    while(check){
      if(S.indexOf(""ST"") != -1){
        S = S.replace(""ST"", """");
      }else{
        check = false;
      }
    }
    System.out.println(S.length());
  }
}
"
148,"import java.util.Scanner;

public class Main {
	Scanner sc = new Scanner(System.in);
	int [] a= {0,0,0,0,0,0,0};
	int [] b= {0,0,0,0,0,0,0};
	int A=0;

public void keisan(){
	for(A=0;A<=7;A++){
		a[A] =sc.nextInt();
		b[A] = sc.nextInt(); 
		System.out.println(a[A]+b[A]);		
	}	
}

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ
		Main main = new Main();
		main.keisan();


	}

}"
149,"import java.util.*;
import java.math.*;

public class Main{
  public static void main(String args[]){
    Scanner sc=new Scanner(System.in);
    int n=sc.nextInt();
	int[] data=new int[n];
	BigInteger t;
    BigInteger sum=BigInteger.valueOf(0);
	BigInteger doubled=BigInteger.valueOf(0);
    for(int i=0;i<data.length;i++){
      data[i]=sc.next();
      t=BigInteger.valueOf(data[i]);
      sum=sum.add(t);
      doubled=doubled.add(t.multiply(t));
    }
    BigInteger multied=sum.multiply(sum);
    multied=multied.subtract(doubled).divide(BigInteger.valueOf(2)).mod(BigInteger.valueOf(1000000007))
    
    System.out.println(multied.intValue());
    
    
  }
}"
150,"import java.util.*;

class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int A = sc.nextInt();
        int B = sc.nextInt();
        int C = sc.nextInt();

        int X = A + B + C;

        if(X > 21) {
            System.out.println(""bust"");
        } else {
            System.out.println(""win"");
        }
    }
}"
151,"
class Main {

	void run(){
		int p, q;
		for(p=1;p<=9;p++){
			for(q=1;q<=9;q++){
				System.out.printf(""%dx%d=%d\n"", p, q, p*q);				
			}
		}
	}
	
	public static void main(String[] args) {
		new Main().run();
	}
}"
152,"java.util.*;

class Main{
  
  public static void main(String[] args){
    
    Scanner sc = new Scanner(System.in);
    int r = sc.nextInt();
    int g = sc.nextInt();
    int b = sc.nextInt();
    int n = sc.nextInt();
    int ans = 0;
    
    for(int i = 0; i <= n; i++){
	  for(int j = 0; j <= n; j++){
        if((n - r * i - g * j) % b == 0) ans++;
      }
    }
    
    System.out.println(ans);
    
  }
  
}"
153,"
class Main {
	
	public static void main(String[] args) {
	
		
		String input;
		int datasetCount = 0;
		
		for (int dataset = 0; dataset < args.length; ++dataset) {
			
			int primes = 0;
			
			
		}
		datasets.close();
		
	}
	
	
	private static boolean isPrime(int i) {
	
		for (int div = 2; div <= Math.sqrt(i); ++div) {
			if (i % div == 0)
				return false;
		}
		return true;
	}
}"
154,"import java.awt.Point;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Scanner;

public class Main {

	/** ????§??????? */
	static final String WHITE_SPACE = "" "";

	/** ??????????????????_X */
	static int mapSizeX = 0;

	/** ??????????????????_Y */
	static int mapSizeY = 0;

	/** ??????????????° */
	static int maxNode = 0;

	/** ????????¢??????????????? */
	static List<Point> pachimonList = new ArrayList<Point>();

	/**
	 * @param args
	 * @throws IOException
	 */
	public static void main(String[] args) throws IOException {
		Scanner scanner = new Scanner(System.in);

		while (scanner.hasNextLine()) {
			readMap(scanner);
//			int[] adjacent = createAdjacent();
			//			Point output = createPos(0, Integer.MAX_VALUE);
			//
			//			for (int type = 1; type <= 5 && maxNode > 0; type++) {
			//				// ??????????????¶????????¢??????????????£??\???????????????????????¨??´???????????????????????±????¨????
			//				adjacent = addStartGoal(adjacent, type);
			//
			//				// ??????????????????????????¢??????????????????????????????????????????????´¢
			//				int cost = searchRoute(adjacent, type);
			//				if (cost < output.y) {
			//					output.x = type;
			//					output.y = cost;
			//				}
			//			}
			//
			//			// ???????????????
			//			if (output.y == Integer.MAX_VALUE) {
			//				System.out.println(""NA"");
			//			} else {
			//				System.out.println(output.x + WHITE_SPACE + output.y);
			//			}
		}
	}

	/**
	 * ?????????????????????????????????
	 * @param scanner ????????£??????
	 */
	private static void readMap(Scanner scanner) {
		String[] mapSizeLine = scanner.nextLine().split(WHITE_SPACE);

		if (mapSizeLine.length < 2) {
			return;
		}
		// ??????????????±????????????
		pachimonList.removeAll(pachimonList);
		maxNode = 0;
		mapSizeX = Integer.parseInt(mapSizeLine[0]);
		mapSizeY = Integer.parseInt(mapSizeLine[1]);

		for (int i = 0; i < mapSizeY; i++) {
			String mapInfoLine = scanner.nextLine();
			mapInfoLine = mapInfoLine.replaceAll(""\\."", ""9"");
			mapInfoLine = mapInfoLine.replaceAll(""S"", ""0"");
			mapInfoLine = mapInfoLine.replaceAll(""G"", ""6"");
			for (int j = 0; j < mapSizeX; j++) {
				int val = Integer.parseInt(String.valueOf(mapInfoLine.charAt(j)));
				if (val < 9) {
					// ???????????¢????????°????¨????
					pachimonList.add(createPos(Integer.valueOf(val), calcIndex(j, i)));
					maxNode++;
				}
			}
		}

		Collections.sort(pachimonList, new Comparator<Point>() {
			@Override
			public int compare(Point o1, Point o2) {
				return o1.x - o2.x;
			}
		});
	}

	/**
	 * X????????????????????´?????????????????¢???????±???§????¨????<br>
	 * ????????????:0?????´??????:6???????????¢???????±???§:1???5<br>
	 * Y????????????????????????????????????????´?
	 * @param type ?????????????????´?????????????????¢???????±???§
	 * @param index ??????????????????????????????
	 * @return
	 */
	private static Point createPos(int type, int index) {
		return new Point(type, index);
	}

//	/**
//	 * ??¨???????????????????????£??\??????????±???????
//	 * @return ??£??\??????
//	 */
//	private static int[] createAdjacent() {
//		int[] adjacent = new int[maxNode * maxNode];
//
//		for (int i = 1; i < pachimonList.size() - 1; i++) {
//			if (pachimonList.get(i).x < 5) {
//				for (int j = i + 1; j < pachimonList.size() - 1; j++) {
//					if (pachimonList.get(j).x - pachimonList.get(i).x > 2)
//						break;
//
//					if (pachimonList.get(j).x == pachimonList.get(i).x + 1)
//						adjacent[i * maxNode + j] = clucCost(pachimonList.get(i), pachimonList.get(j));
//				}
//			} else {
//				for (int j = 0; j < pachimonList.size() - 1; j++) {
//					if (pachimonList.get(j).x == pachimonList.get(i).x - 4)
//						adjacent[i * maxNode + j] = clucCost(pachimonList.get(i), pachimonList.get(j));
//				}
//			}
//		}
//		return adjacent;
//	}

	//	/**
	//	 * ??????????????????????????¢????????????????????????????????????????±???§???????????¢??????????????????<br>
	//	 * ?????????????????????????????¢?????????????????????????¨????
	//	 * @param adjacent ??£??\??????
	//	 * @param firstType ??????????????????????????¢???????±???§
	//	 * @return ??£??\??????
	//	 */
	//	private static int[] addStartGoal(int[] adjacent, int firstType) {
	//		// ??????????????????????????¢????????????????¬??????????????????????????????¢?????¨??????????????£??\??????????¨????
	//		int startRow = 0;
	//		int goalRow = maxNode - 1;
	//
	//		// ??????????????????????????¢????????????????????????????????????1?¨?????????????????????????4?¨??????????????????????
	//		int nextType = getNextType(firstType);
	//		int endType = getEndType(firstType);
	//		// ??????????????¨??´???????????±?????????????????????
	//		resetStartGoal(adjacent);
	//
	//		for (int i = 0; i < pachimonList.size(); i++) {
	//			if (pachimonList.get(i).x == nextType)
	//				adjacent[startRow * maxNode + i] = clucCost(pachimonList.get(0), pachimonList.get(i));
	//
	//			if (pachimonList.get(i).x == endType)
	//				adjacent[i * maxNode + goalRow] = clucCost(pachimonList.get(i), pachimonList.get(maxNode - 1));
	//		}
	//		return adjacent;
	//	}

	//	/**
	//	 * ??????????????¨??´?????????????????????????????????????????????
	//	 * @return ????????????????????£??\??????
	//	 */
	//	private static void resetStartGoal(int[] adjacent) {
	//		int goalRow = maxNode;
	//		for (int i = 0; i < maxNode; i++) {
	//			adjacent[i] = 0;
	//			adjacent[goalRow * (i + 1) - 1] = 0;
	//		}
	//	}
	//
	//	/**
	//	 * ??????????????????????????¢???????????????????????????????????????????????¢???????±???§?????????
	//	 * @param firstType ??????????????????????????¢???????±???§
	//	 * @return ?????????????????????????????¢???????±???§
	//	 */
	//	private static int getNextType(int firstType) {
	//		if (firstType > 4) {
	//			return 1;
	//		}
	//		return firstType + 1;
	//	}
	//
	//	/**
	//	 * ??????????????????????????¢?????????????????????????????????????????¢???????±???§?????????
	//	 * @param firstType ??????????????????????????¢???????±???§
	//	 * @return ?????????????????????????????¢???????±???§
	//	 */
	//	private static int getEndType(int firstType) {
	//		if (firstType > 1)
	//			return firstType - 1;
	//
	//		return 5;
	//	}
	//
	//	/**
	//	 * ??£??\??????????¨?????????????????????????????????´???????????§???<br>
	//	 * ????????????????????????????±???????
	//	 * @param adjacent ??£??\??????
	//	 * @return ????????????????????????
	//	 */
	//	private static int searchRoute(int[] adjacent, int firstType) {
	//
	//		/** ?????????????¨??????????????????????????´??????? */
	//		boolean[] visited = new boolean[maxNode];
	//
	//		/** ??????????????????????????? */
	//		int[] cost = new int[maxNode];
	//
	//		for (int i = 0; i < maxNode; i++) {
	//			cost[i] = Integer.MAX_VALUE;
	//			visited[i] = false;
	//		}
	//
	//		// ??????????????°????????§???????????????0
	//		cost[0] = 0;
	//
	//		while (true) {
	//			// ?¨?????????????????????????????????§?????????????????????????±???????
	//			int node = minIndex(cost, visited);
	//			if (node < 0) {
	//				return cost[maxNode - 1];
	//			}
	//			// ??¢?´¢???????????????????????????????????°????????????
	//			visited[node] = true;
	//			for (int j = 0; j < maxNode; j++) {
	//				if (adjacent[node * maxNode + j] > 0 && !visited[j] && pachimonList.get(node).x != firstType) {
	//					int nextNodeCost = cost[node] + adjacent[node * maxNode + j];
	//					// ????????§????????¢??????????°????????????°???????????¢??¨???????¨???¶
	//					if (nextNodeCost < cost[j]) {
	//						cost[j] = nextNodeCost;
	//					}
	//				}
	//			}
	//		}
	//	}

	//	/**
	//	 * ?¨???????????????????????????????????????????????????????????????????????????????????±???????
	//	 * @param cost ???????????????????????????
	//	 * @param visited ?????????????¨??????????????????????????´???????
	//	 * @return ??????????????????
	//	 */
	//	private static int minIndex(int[] cost, boolean[] visited) {
	//		int index = 0;
	//		for (; index < maxNode; index++) {
	//			if (!visited[index])
	//				break;
	//		}
	//		if (index == maxNode)
	//			return -1;
	//		for (int i = index + 1; i < maxNode; i++) {
	//			if (!visited[i] && cost[i] < cost[index])
	//				index = i;
	//		}
	//		return index;
	//	}

	/**
	 * ????????????????????????????????´???????????§????????????????¨?????????????
	 * @param sx ???????????????X??§?¨?
	 * @param sy ???????????????Y??§?¨?
	 * @param gx ??´?????????X??§?¨?
	 * @param gy ??´?????????Y??§?¨?
	 * @param nextType ?¬????????????????????????¢????±???§
	 */
	private static int clucCost(Point from, Point to) {
		int fx = from.y / mapSizeY;
		int fy = from.y % mapSizeY;
		int tx = to.y / mapSizeY;
		int ty = to.y % mapSizeY;
		return Math.abs(tx - fx) + Math.abs(ty - fy);
	}

	/**
	 * X??§?¨???¨Y??§?¨???????????????£?????????????????????????????????????????´?????????
	 *
	 * @param x X??§?¨?
	 * @param y Y??§?¨?
	 * @return
	 */
	private static int calcIndex(int x, int y) {
		return x * mapSizeY + y;
	}
}"
155,"import java.util.Scanner;

class Main{
  public static void main(String[] args){
    Scanner sc=new Scanner(System.in);
    String S=sc.next();
    String T=sc.next();  
    int A=sc.nextInt();
    int B=sc.nextInt(); 
    String U=sc.next();
    
    if(U.equals(S))A--;
    else B--;
    System.out.println(A+"" ""+B);
   }
}

  "
156,"import java.util.Scanner;                                                               
 
class Main {
    public static void main(String[] args) {
            Scanner in = new Scanner(System.in);
            String str = new String();
            StringBuilder sb = new StringBuilder();
            int i =0 ;
            while(in.hasNext()) {
                        String buf = in.nextLine();
                    i++;
                    str = str + buf;
                    int j = Integer.parseInt(buf);
                    if (j == 0){
                    break;
                    }else{
                    sb.append(""Case"" + "" "" + i  + "":"" + "" "" +  buf + ""\n"");
                    }

                    }
            System.out.print(sb);
        }
}"
157,"import java.util.*;
import static java.lang.Math.*;

public class Main {
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);

		// 入力
		String s = sc.next();// 文字列

		// チェック
		String result = """";

		if(check(s)){
			result = ""YES"";
		}else{
			result = ""NO"";
		}

		// 出力
		System.out.println(result);
	}

	static boolean check(String s){

		// 定数
		String a  = ""dream"";
		String b  = ""dreamer"";
		String c  = ""erase"";
		String d  = ""eraser"";

		if(s.equals(a) || s.equals(b) || s.equals(c) || s.equals(d)){
			return true;
		}
		if(s.startsWith(a)){
			if(check(s.substring(a.length()))){
				return true;
			}
		}
		if(s.startsWith(b)){
			if(check(s.substring(b.length()))){
				return true;
			}
		}
		if(s.startsWith(c)){
			if(check(s.substring(c.length()))){
				return true;
			}
		}
		if(s.startsWith(d)){
			if(check(s.substring(d.length()))){
				return true;
			}
		}

		return false;
	}

}


"
158,"import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;

public class Main {
    private static final Object[] Compiler = null;

    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = Integer.parseInt(sc.next());
        int k = Integer.parseInt(sc.next());
        Integer[] hn = new Integer[n];
        long time = 0;
        if(n<k){
            System.out.println(0);
            return;
        }
        for(int i=0;i<n;i++){
            hn[i] = Integer.parseInt(sc.next());
        }
        //asList(s);は固定長のlistを返す
        //List<Integer> list = Arrays.asList(hn);
        List<Integer> list = new ArrayList<Integer>(Arrays.asList(hn));
        Collections.sort(list,Collections.reverseOrder());
        for(int j=0;j<k;j++){
            list.remove(0);
        }
        for(int m : list){
            time = time + m;
        }
        System.out.println(time);

        }

    }
"
159,"import java.util.*;
 
public class Main{
  public static void main(String[]args){
    Scanner sc =  new Scanner(System.in);
    String S = sc.nextLine();
    StringBuffer sb = new StringBuffer(S);
    S = sb.reverse().toString();
    while(S.length() >= 5){
      if(S.substring(0,5).equals(""maerd"")){
        S = S.substring(5, S.length());
      }else if(S.substring(0,5).equals(""esare"")){
        S = S.substring(5, S.length());
      }else if(S.substring(0,6).equals(""resare"")){
        S = S.substring(6, S.length());
      }else if(S.substring(0,7).equals(""remaerd"")){
        S = S.substring(7, S.length());
      }else{
        break;
      }
    }
    
    String ans = """";
    if(S.length() == 0){
      ans = ""YES"";
    }else{
      ans = ""NO"";
    }
    System.out.println(ans);
  }
}"
160,"
import java.util.Scanner;

public class Main {
	public static void main(String [] args){
		//????????£?????????????????????
		Scanner sc = new Scanner(System.in);
		//??£?¨?
		char temp; //char????????????????????´???
		int [] table = new int[26]; //??¢?????????????????????26???????????¨?????????
		//??°?????????
		while(sc.hasNext()){
			//?????????(??±???)?????????
			String line = sc.nextLine();
			//??¨???????????????????°???????????????´
			String lower = line.toLowerCase();
			//?????????????????????
			for(int i =0; i < lower.length(); i++){
				//?°??????????char????????????
				temp = lower.charAt(i);
				//System.out.print(temp+ "" "");
				//??¢??????????????????????°???????????????°????????????
				if('a' <= temp  && temp  <= 'z'){
					table[temp - 'a']++;
				}
			}
		}
		//???????????????????????°?????????
		for(int i = 0; i < table.length; i++){
			//?????£??????????????´ a : ??????????????° ??¨???
			System.out.println( (char )('a' + i)+ "" : ""+ table[i]);
		}
	}
}"
161,"import java.io.*;
import java.util.*;
import java.util.stream.*;

public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader stdin = new BufferedReader(new InputStreamReader(System.in));
		
		int[] firstLine = Stream.of(stdin.readLine().split("" "")).mapToInt(Integer::parseInt).toArray();
		int[] elements = Stream.of(stdin.readLine().split("" "")).mapToInt(Integer::parseInt).toArray();
		int maxNumsOfType = firstLine[1];
		HashMap<Integer, Integer> numCounter = new HashMap<Integer, Integer>();
		Arrays.stream(elements).forEach(num -> {
			if (!numCounter.containsKey(num)) numCounter.put(num,1);
			else numCounter.put(num, numCounter.get(num)+1);
		});
		//System.out.println(numCounter);
		int numsOfType = 0;
		int changedSum = 0;
		for(int i = 0; i < numCounter.keySet().size(); i++) {
			numsOfType++;
		}
		while(numsOfType > maxNumsOfType) {
			int minNum = minKey(numCounter);
			changedSum += numCounter.get(minNum);
			numCounter.remove(minNum);
			numsOfType--;
		}
		System.out.println(changedSum);
	}
	
	public static int minKey(HashMap<Integer, Integer> hashMap) {
		int minKey = hashMap.entrySet().stream().min(Map.Entry.comparingByValue()).get().getKey();
//		System.out.println(minKey);
		return minKey;
	}
}"
162,"import java.math.BigInteger;
import java.util.Scanner;
 
 
public class Main {
 
	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ
 
 
	    //入力数字の数を入力
		Scanner sc=new Scanner(System.in);
 
	    int count=sc.nextInt();
	    long[] nyuryoku = new long[count];
	    

		BigInteger result=BigInteger.ZERO;
		
		long max=(long)Math.pow(10, 18);
 
	    //入力処理
		for(int i=0;i<count;i++) {
			nyuryoku[i]=sc.nextLong();
			BigInteger.valueOf(nyuryoku[i]);
			if(result==BigInteger.ZERO) {
				result=result.add(BigInteger.valueOf(nyuryoku[i]));
			}else {
				result=result.multiply(BigInteger.valueOf(nyuryoku[i]));
			}
		}
		
		BigInteger bigMax=BigInteger.valueOf(max);
		
		if(result.compareTo(bigMax)==1) {
			System.out.println(-1);
		}else {
			System.out.println(result);
		}
	}
}
"
163,"import java.io.*;
import java.util.*;

public class Main {
    public static final long INF = Long.MAX_VALUE/2;
    public static final int inf = Integer.MAX_VALUE/2;

    static void solve(InputReader in, PrintWriter out){
        long k = in.nl();
        long ans = 0;
        if(k%2==0){
            ans = -1;
        }else{
            long x = 0;
            long d = 1;
            for (int i = 1; i <= k*k; i++) {
                x += (d * 7) % k;
                x %= k;
                d *= 10;
                d %= k;
                if (x == 0) {
                    ans = i;
                    break;
                }
            }
        }
        out.println(ans!=0?ans:1/0);
    }

    public static void main(String[] args){
        InputReader in = new InputReader(System.in);
        PrintWriter out = new PrintWriter(System.out);
        solve(in, out);
        out.close();
    }
    public static class InputReader{
        private BufferedReader br;
        private StringTokenizer st;
        public InputReader(InputStream is){
            br = new BufferedReader(new InputStreamReader(is));
            st = null;
        }
        public String ns(){
            if(st == null || !st.hasMoreTokens()){
                try{
                    st = new StringTokenizer(br.readLine());
                }catch (Exception e){
                    throw new RuntimeException(e);
                }
            }
            return st.nextToken();
        }
        public int ni(){
            return Integer.parseInt(ns());
        }
        public long nl(){
            return Long.parseLong(ns());
        }
        public double nd(){
            return Double.parseDouble(ns());
        }
        public char nc(){
            return ns().toCharArray()[0];
        }
        public int[] ni(int n){
            int[] a = new int[n];
            for (int i = 0; i < n; i++) {
                a[i] = ni();
            }
            return a;
        }
        public long[] nl(int n){
            long[] a = new long[n];
            for (int i = 0; i < n; i++) {
                a[i] = nl();
            }
            return a;
        }
        public double[] nd(int n){
            double[] a = new double[n];
            for (int i = 0; i < n; i++) {
                a[i] = nd();
            }
            return a;
        }
    }
}"
164,"package AtcoderBeginnerContest.BC132;


import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String str = scanner.next();
        String[] strArray = str.split("""");
        Map<String,Integer> map = new HashMap<>();
        for(String s: strArray){
            if(map.get(s) == null) map.put(s,1);
            else map.put(s,map.get(s)+1);
        }

        if(map.size() == 2) System.out.println(""Yes"");
        else System.out.println(""No"");
    }
}
"
165,"import java.io.*;

class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br =
			new BufferedReader(new InputStreamReader(System.in));

			String[] line = br.readLine().split("" "");
			int[] list = new int[3];
			list[0] = Integer.parseInt(line[0]);
			list[1] = Integer.parseInt(line[1]);
			list[2] = Integer.parseInt(line[2]);

			boolean isSorted = false;
			while(!isSorted) {
				for(int i = 0; i < list.length - 1; i++) {
					int temp;
					if(list[i] > list[i+1]) {
						temp = list[i+1];
						list [i+1] = list [i];
						list [i] = temp;
					}
				}
				if(list[0] < list[1] && list[1] < list[2]) {
					isSorted = true;
				}
			} 
			System.out.println(list[0] + "" "" + list[1] + "" "" + list[2]);
	}
}"
166,"import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		boolean hantei = false;
		int x = 0;
		int y = 0;
		while (hantei != true ) {
			Scanner scan = new Scanner(System.in);
			x = scan.nextInt();
			y = scan.nextInt();
			if (x == 0 && y ==0) {
				hantei = true;
			}else{
				if (x > y) {
					System.out.println(y+"" ""+x);
				}else {
					System.out.println(x+"" ""+y);
				}
			}
		}
	
"
167,"import java.io.*;

class Main{
	private Node first, last;

	public Main(){
		int n, limit = 0, timeSt = 0;
		String[] tmp;
		Node[] process;

		BufferedReader br = 
			new BufferedReader(new InputStreamReader(System.in), 1);
		try{
			tmp = br.readLine().split("" "");
			n = Integer.parseInt(tmp[0]);
			limit = Integer.parseInt(tmp[1]);
			process = new Node[n];

			for(int i=0; i < n; i++){
				tmp = br.readLine().split("" "");
				process[i] = 
					new Node(tmp[0], Integer.parseInt(tmp[1]));
				enqueue(process[i]);
			}

		}catch(IOException e){
			System.out.println(e);
		}
		Node node = null;
		while( (node = dequeue()) != null){
			if( node.getTime() <= limit){
				timeSt += node.getTime(); 
				System.out.println(node+"" ""+timeSt);
			}else{
				timeSt += limit;
				int t = node.getTime();
				node.setTime(t - limit);
				enqueue(node);
			}
		}
	}

	void enqueue(Node p){
		if(first == null){
			last = p;
			first = last; 
		} else{
			last.next = p;
			last = last.next;
		}
	}
	Node dequeue(){
		if(first != null){
			Node tmp = first;
			first = first.next;
			tmp.next = null;
			return tmp;
		}
		return null;
	}

	void printQueue(){
		Node n = first;
		while(n != null){
			System.out.println(n);
			n = n.next;
		}
	}
	
	public static void main(String[] args){
		new Main();
	}
}

class Node{
	private String name;
	private int time;
	Node next;

	Node(String name, int time){
		this.name = name;
		this.time = time;
	}
	int getTime(){
		return this.time;
	}
	void setTime(int time){
		this.time = time;
	}
	void setNext(Node n){
		next = n;
	}
	@Override
	public String toString(){
		return name;
	}
}"
168,"import java.util.*;
import java.awt.*;
import static java.lang.System.*;
import static java.lang.Math.*;
public class Main {
    public static void main(String[] args){
        Scanner sc = new Scanner(in);
        int n=sc.nextInt();
        String[] a=new String[n+1];
        for (int i = 1; i <= n; i++) {
            a[i]=sc.next();
        }
        StringBuilder ans=new StringBuilder(a[1]);
        if(n%2==0){
            for (int i = 2; i <= n; i++) {
                if(i%2==0){
                    ans.insert(0, a[i]+"" "");
//ans=a[i]+"" ""+ans;
                }else{
                    ans.append("" ""+a[i]);
                    //ans=ans+"" ""+a[i];
                }
            }
        }else{
            for (int i = 2; i <= n; i++) {
                if(i%2==0){
                    ans.append("" ""+a[i]);
                    //ans=ans+"" ""+a[i];
                }else{
                    ans.insert(0, a[i]+"" "");
                    //ans=a[i]+"" ""+ans;
                }
            }
        }
        out.println(ans);
    }
}"
169,"import java.util.Scanner;

public class Main {

	public static void main(String[] args) {

		Scanner scan = new Scanner(System.in);

		int N = scan.nextInt();
		int A = scan.nextInt();
		int B = scan.nextInt();

		int ans = N / (A+B) * A;
		int rem =  N % (A + B);
		ans += Math.min(rem, A);
		System.out.println(ans);

	}
}
"
170,"import java.util.*

public class Main{

	public static void main(String[] args) {

		Scanner scan = new Scanner(System.in);
		 Dice3 di3 = new Dice3();		//Dice3のインスタンス

		int n = scan.nextInt();		//回数n

		int[] dice1 = new int[6];		//dice1作成
		for(int i=0; i<6; i++) {
			dice1[i] = scan.nextInt();
		}

		int[] answer2 = new int[6]; 	//確認した後の配列
		boolean flag = false;			//最終判定

		int[] dice2 = new int[6];		//dice2作成

		//n-1回サイコロを作成し確認
		for(int i=0; i<n-1; i++) {

			for(int j=0; j<6; j++) {
				dice2[j] = scan.nextInt();
			}


			answer2 = di3.check(dice1, dice2);		//総当たりで確認


			if(Arrays.equals(dice1, answer2)) {
				flag = true;
				break;
			}
		}

		if(flag) {		//既に算出済み
			System.out.println(""No"");
		}else
			System.out.println(""Yes"");
	}
}



class Dice3{
	static int top = 0;
	static int side1 = 0;
	
	static int[] answer = new int[6]; //動かすサイコロの形

	//command（特定の文字が入力された際、その方向に転がす）
	int[] command(int[] dice, char com) {
	    	top = dice[0];	//dice[0]を覚えておく
	    	side1 = dice[1];	//dice[1]を覚えておく

	    	switch (com) {

	    	case 'N':
	    		dice[0] = dice[1];
	    		dice[1] = dice[5];
	    		dice[5] = dice[4];
	    		dice[4] = top;
	    		break;

	    	case 'W':
	    		dice[0] = dice[2];
	    		dice[2] = dice[5];
	    		dice[5] = dice[3];
	    		dice[3] = top;
	    		break;


	    	case 'R':
	    		dice[1] = dice[3];
	    		dice[3] = dice[4];
	    		dice[4] = dice[2];
	    		dice[2] = side1;
	    		break;
	    	}
		return dice; 		//配列を返す
	 }


	//check（全ての面で配列d2を横回転させ配列d１と比較）
	int[] check(int[] d1 ,int[] d2) {

		//N方向回転
		for(int k=0; k<4; k++) {

			if(Arrays.equals(d1, answer)) {		//配列の比較はArraysから
				break;
			}
			answer = command(d2, 'N');

			//横回転
			for(int l=0; l<4; l++) {

				if(Arrays.equals(d1, answer)) {
					break;
				}
				answer = command(d2, 'R');
			}
		}

		//W方向回転
		for(int k=0; k<4; k++) {

			if(Arrays.equals(d1, answer)){
				break;
			}
			answer = command(d2, 'W');

			//横回転
			for(int l=0; l<4; l++) {

				if(Arrays.equals(d1, answer)) {
					break;
				}
				answer = command(d2, 'R');
			}
		}
		return answer;
	}
}
"
171,"import java.util.Scanner;

public class Main {
		public static void main(String[] args) {
			Scanner sc = new Scanner(System.in);
			int N =sc.nextInt();
			int count = 0;
			int count2 = 0;
			int count3= 0;
			int count4 = 0;
          String A = ""AC"";
          String B = ""WA"";
          String C = ""TLE"";
          String D = ""RE"";
		for(int i = 0;i < N;i++) {
			String H = sc.nextLine();
			if(H.equals(A)) {
				count++;
			}
			else if(H.equals(B)) {
				count2++;
			}
			else if(H.equals(C)) {
				count3++;
			}
			else if(H.equals(D)) {
				count4++;
			}
		}
		System.out.println(""AC  x  "" + count);
		System.out.println(""WA  x  "" + count2);
		System.out.println(""TLE  x  "" + count3);
		System.out.println(""RE  x  "" + count4);
	}
}"
172,"import java.util.*;
public class Main {
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		// 文字列の入力
		int n = sc.nextInt();
		int a[] = new int[n];

		int pair = 0;
		for (int i = 0; i < n; i++) {
			a[i] = sc.nextInt();
			for (int j = 0; j < i; j++) {
				if (i - j == a[i] + a[j]) {
					pair++;
				}
			}
		}

		// 出力
		System.out.println(pair);
		sc.close();
	}
}
"
173,"
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.InputMismatchException;
import java.util.StringTokenizer;
import java.util.TreeSet;

public class Main {

	public static void main(String[] args) throws IOException {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskX solver = new TaskX();
		solver.solve(1, in, out);
		out.close();
	}

	static int INF = 1 << 30;
	static int modP = 1000000007;
	static int[] mh4 = { 0, -1, 1, 0 };
	static int[] mw4 = { -1, 0, 0, 1 };

	static class TaskX {
		public void solve(int testNumber, InputReader in, PrintWriter out) {

			String s = in.nextString();
			int k = in.nextInt();
			int len = s.length();
			TreeSet<String> set = new TreeSet<>();
			for (int i = 0; i < len; i++) {
				for (int j = i+1; j <= len; j++) {
					set.add(s.substring(i, j));
				}
			}

			int count = 1;
			for (String string : set) {
				if (count == k) {
					out.println(string);
				}
				count++;
			}

		}
	}

	static class InputReader {
		BufferedReader in;
		StringTokenizer tok;

		public String nextString() {
			while (!tok.hasMoreTokens()) {
				try {
					tok = new StringTokenizer(in.readLine(), "" "");
				} catch (IOException e) {
					throw new InputMismatchException();
				}
			}
			return tok.nextToken();
		}

		public int nextInt() {
			return Integer.parseInt(nextString());
		}

		public long nextLong() {
			return Long.parseLong(nextString());
		}

		public double nextDouble() {
			return Double.parseDouble(nextString());
		}

		public int[] nextIntArray(int n) {
			int[] res = new int[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextInt();
			}
			return res;
		}

		public long[] nextLongArray(int n) {
			long[] res = new long[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextLong();
			}
			return res;
		}

		public InputReader(InputStream inputStream) {
			in = new BufferedReader(new InputStreamReader(inputStream));
			tok = new StringTokenizer("""");
		}

	}

}
"
174,"import java.awt.List;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.InputMismatchException;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class Main
{
	InputStream is;
	PrintWriter out;
	String INPUT = """";
	void solve()
	{
		int r=ni();
		int g=ni();
		out.println(2*g-r);
	}
			
     	
	
		  
	
		
	void run() throws Exception
	{
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		long s = System.currentTimeMillis();
		solve();
		out.flush();
		if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+""ms"");
	}
	
	public static void main(String[] args) throws Exception 
	{ new Tester().run(); }
	
	private byte[] inbuf = new byte[1024];
	public int lenbuf = 0, ptrbuf = 0;
	
	private int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf >= lenbuf)
		{
			ptrbuf = 0;
			try 
			{ lenbuf = is.read(inbuf); } 
			catch (IOException e) 
			{ throw new InputMismatchException(); }
			if(lenbuf <= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private boolean isSpaceChar(int c)
	{ return !(c >= 33 && c <= 126); }
	private int skip() 
	{ int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }
	
	private double nd() 
	{ return Double.parseDouble(ns()); }
	private char nc()
	{ return (char)skip(); }
	
	private String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b)))
		{ // when nextLine, (isSpaceChar(b) && b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p < n && !(isSpaceChar(b)))
		{
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i < n;i++)map[i] = ns(m);
		return map;
	}
	
	private int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i < n;i++)a[i] = ni();
		return a;
	}
	
	private int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-')
		{
			minus = true;
			b = readByte();
		}
		
		while(true)
		{
			if(b >= '0' && b <= '9')
			{
				num = num * 10 + (b - '0');
			}else
			{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-')
		{
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b >= '0' && b <= '9')
			{
				num = num * 10 + (b - '0');
			}else
			{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static void tr(Object... o) 
	{ System.out.println(Arrays.deepToString(o)); }
}
"
175,"import java.util.Scanner;
import java.lang.Math;
public class test {
    public static void main(String[] args){
        Scanner scan=new Scanner(System.in);
        int h=scan.nextInt(),a=scan.nextInt(),total=0;
        while (h>0){
      		h-=a;
      		total+=1;}
      System.out.println(total)
        }
    }
"
176,"import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.net.ConnectException;
import java.rmi.dgc.Lease;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.Set;
import java.util.Stack;
import java.util.TreeMap;
import java.util.TreeSet;

import static java.util.Comparator.*;

public class Main {
	public static void main(String[] args) {
		Main main = new Main();
		main.solve();
		main.out.close();
	}

	// ======================================================================
	public void solve() {
		int N = ni();
		int M = ni();
		int[] A = new int[N];
		int sum = 0;
		for (int i = 0; i < N; i++) {
			A[i] = ni();
			sum += A[i];
		}
		Arrays.sort(A);
		if(A[N-1-M] > sum / 4 / M)	out.println(""Yes"");
		else						out.println(""No"");
	}

	// ------------------------------------------
	// ライブラリ
	// ------------------------------------------
	// Print
	private PrintWriter out = new PrintWriter(System.out);

	// Scanner
	private FastScanner scan = new FastScanner();

	int ni() {
		return scan.nextInt();
	}

	int[] ni(int n) {
		int[] a = new int[n];
		for (int i = 0; i < n; i++) {
			a[i] = ni();
		}
		return a;
	}

	int[][] ni(int y, int x) {
		int[][] a = new int[y][x];
		for (int i = 0; i < y; i++) {
			for (int j = 0; j < x; j++) {
				a[i][j] = ni();
			}
		}
		return a;
	}

	long nl() {
		return scan.nextLong();
	}

	long[] nl(int n) {
		long[] a = new long[n];
		for (int i = 0; i < n; i++) {
			a[i] = nl();
		}
		return a;
	}

	long[][] nl(int y, int x) {
		long[][] a = new long[y][x];
		for (int i = 0; i < y; i++) {
			for (int j = 0; j < x; j++) {
				a[i][j] = nl();
			}
		}
		return a;
	}

	String ns() {
		return scan.next();
	}

	String[] ns(int n) {
		String[] a = new String[n];
		for (int i = 0; i < n; i++) {
			a[i] = ns();
		}
		return a;
	}

	String[][] ns(int y, int x) {
		String[][] a = new String[y][x];
		for (int i = 0; i < y; i++) {
			for (int j = 0; j < x; j++) {
				a[i][j] = ns();
			}
		}
		return a;
	}
}

class FastScanner {
	private final InputStream in = System.in;
	private final byte[] buffer = new byte[1024];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) {
			return true;
		} else {
			ptr = 0;
			try {
				buflen = in.read(buffer);
			} catch (IOException e) {
				e.printStackTrace();
			}
			if (buflen <= 0) {
				return false;
			}
		}
		return true;
	}

	private int readByte() {
		if (hasNextByte())
			return buffer[ptr++];
		else
			return -1;
	}

	private static boolean isPrintableChar(int c) {
		return 33 <= c && c <= 126;
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext())
			throw new NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		int b = readByte();
		while (isPrintableChar(b)) {
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}

	public long nextLong() {
		if (!hasNext())
			throw new NoSuchElementException();
		long n = 0;
		boolean minus = false;
		int b = readByte();
		if (b == '-') {
			minus = true;
			b = readByte();
		}
		if (b < '0' || '9' < b) {
			throw new NumberFormatException();
		}
		while (true) {
			if ('0' <= b && b <= '9') {
				n *= 10;
				n += b - '0';
			} else if (b == -1 || !isPrintableChar(b)) {
				return minus ? -n : n;
			} else {
				throw new NumberFormatException();
			}
			b = readByte();
		}
	}

	public int nextInt() {
		long nl = nextLong();
		if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)
			throw new NumberFormatException();
		return (int) nl;
	}

	public double nextDouble() {
		return Double.parseDouble(next());
	}
}
"
177,"import java.io.InputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Deque;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;
import java.math.BigInteger;
 
public class Main{
 
static PrintWriter out;
static InputReader ir;
 
static void solve(){
 for(;;){
  t=ir.nextInt();
  n=ir.nextInt();
  if(t==0&&n==0) return;
  ng=new boolean[61][61];
  dist=new int[61][61];
  for(int i=0;i=60;i++) Arrays.fill(dist[i],INF);
  for(int i=0;i<n;i++) ng[ir.nextInt()+OFFSET][ir.nextInt()+OFFSET]=true;
  bfs();
  int ct=0;
  for(int i=0;i=60;i++) for(int j=0;j<60;j++) if(dist[i][j]!=INF) ct++;
  out.println(ct);
 }
}
 
static int t,n;
static final int OFFSET=30,INF=1<<25;
static boolean[][] ng;
static final int[] dx=new int[]{0,-1,-1,0,1,1},dy=new int[]{1,0,-1,-1,0,1};
static int[][] dist;

public static void bfs(){
 Deque<int[]> que=new ArrayDeque<>();
 que.offerLast(new int[]{0,0});
 dist[OFFSET][OFFSET]=0;
 while(!que.isEmpty()){
  int[] p=que.pollFirst();
  for(int i=0;i<6;i++){
   int nx=p[0]+dx[i],ny=p[1]+dy[i];
   if(ng[nx+OFFSET][ny+OFFSET]||dist[nx+OFFSET][ny+OFFSET]!=INF) continue;
   dist[nx+OFFSET][ny+OFFSET]=dist[p[0]+OFFSET][p[1]+OFFSET];
   if(dist[nx+OFFSET][ny+OFFSET]<t) que.offerLast(new int[]{nx,ny});
  }
 }
}

public static void main(String[] args) throws Exception{
 ir=new InputReader(System.in);
 out=new PrintWriter(System.out);
 solve();
 out.flush();
}
 
static class InputReader {
 private InputStream in;
 private byte[] buffer=new byte[1024];
 private int curbuf;
 private int lenbuf;
 
 public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}
  
 public boolean hasNextByte() {
  if(curbuf>=lenbuf){
   curbuf= 0;
   try{
    lenbuf=in.read(buffer);
   }catch(IOException e) {
    throw new InputMismatchException();
   }
   if(lenbuf<=0) return false;
  }
  return true;
 }
 
 private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}
  
 private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}
  
 private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}
  
 public boolean hasNext(){skip(); return hasNextByte();}
  
 public String next(){
  if(!hasNext()) throw new NoSuchElementException();
  StringBuilder sb=new StringBuilder();
  int b=readByte();
  while(!isSpaceChar(b)){
   sb.appendCodePoint(b);
   b=readByte();
  }
  return sb.toString();
 }
  
 public int nextInt() {
  if(!hasNext()) throw new NoSuchElementException();
  int c=readByte();
  while (isSpaceChar(c)) c=readByte();
  boolean minus=false;
  if (c=='-') {
   minus=true;
   c=readByte();
  }
  int res=0;
  do{
   if(c<'0'||c>'9') throw new InputMismatchException();
   res=res*10+c-'0';
   c=readByte();
  }while(!isSpaceChar(c));
  return (minus)?-res:res;
 }
  
 public long nextLong() {
  if(!hasNext()) throw new NoSuchElementException();
  int c=readByte();
  while (isSpaceChar(c)) c=readByte();
  boolean minus=false;
  if (c=='-') {
   minus=true;
   c=readByte();
  }
  long res = 0;
  do{
   if(c<'0'||c>'9') throw new InputMismatchException();
   res=res*10+c-'0';
   c=readByte();
  }while(!isSpaceChar(c));
  return (minus)?-res:res;
 }
 
 public double nextDouble(){return Double.parseDouble(next());}
 
 public int[] nextIntArray(int n){
  int[] a=new int[n];
  for(int i=0;i<n;i++) a[i]=nextInt();
  return a;
 }
 
 public long[] nextLongArray(int n){
  long[] a=new long[n];
  for(int i=0;i<n;i++) a[i]=nextLong();
  return a;
 }
 
 public char[][] nextCharMap(int n,int m){
  char[][] map=new char[n][m];
  for(int i=0;i<n;i++) map[i]=next().toCharArray();
  return map;
 }
}
}"
178,"import java.io.*;

public class Main {
  private static class HpReader {
    private int lineIndex = -1;
    private int[] lineIntMem;
    private long[] lineLongMem;
    private BufferedReader in;

    public HpReader(String dir, String inFile, String outFile) {
      initAndRedirectInOut(dir, inFile, outFile);
    }

    private int ivl(String val) {
      return Integer.parseInt(val);
    }

    private long lvl(String val) {
      return Long.parseLong(val);
    }

    private void initAndRedirectInOut(String dir, String inFile, String outFile) {
      if (dir != null) {
        try {
          String containingDirPath = dir.endsWith(File.separator) ? dir : dir + File.separator;
          if (isDebug && inFile != null)
            System.setIn(new FileInputStream(new File(containingDirPath + inFile)));
          if (isDebug && outFile != null)
            System.setOut(new PrintStream(new File(containingDirPath + outFile)));
        } catch (FileNotFoundException e) {
          // Do nothing, stdin & stdout are not redirected
        }
      }
      in = new BufferedReader(new InputStreamReader(System.in));
      out = new PrintWriter(System.out);
    }

    private String nextSingleStr() throws IOException {
      return in.readLine();
    }

    private String[] nextLineStr() throws IOException {
      return nextLineStr(0);
    }

    private String[] nextLineStr(int offset) throws IOException {
      String[] inp = nextSingleStr().split("" "");
      String[] rs = new String[offset + inp.length];
      System.arraycopy(inp, 0, rs, offset, inp.length);
      return rs;
    }

    private int nextSingleInt() throws IOException {
      if (lineIndex == -1 || lineIndex == lineIntMem.length) {
        lineIndex = 0;
        lineIntMem = nextLineInt();
      }

      return lineIntMem[lineIndex++];
    }

    private int[] nextLineInt() throws IOException {
      return nextLineInt(0);
    }

    private int[] nextLineInt(int offset) throws IOException {
      String[] inp = nextLineStr();
      int[] rs = new int[offset + inp.length];
      for (int i = 0; i < inp.length; i++) rs[offset + i] = ivl(inp[i]);
      return rs;
    }

    private long nextSingleLong() throws IOException {
      if (lineIndex == -1 || lineIndex == lineLongMem.length) {
        lineIndex = 0;
        lineLongMem = nextLineLong();
      }

      return lineLongMem[lineIndex++];
    }

    private long[] nextLineLong() throws IOException {
      return nextLineLong(0);
    }

    private long[] nextLineLong(int offset) throws IOException {
      String[] inp = nextLineStr();
      long[] rs = new long[offset + inp.length];
      for (int i = 0; i < inp.length; i++) rs[offset + i] = lvl(inp[i]);
      return rs;
    }

    private int[][] nextMatInt(int lineCount) throws IOException {
      return nextMatInt(lineCount, 0, 0);
    }

    private int[][] nextMatInt(int lineCount, int rowOffset, int colOffset) throws IOException {
      int[][] rs = new int[rowOffset + lineCount][];
      for (int i = rowOffset; i < rs.length; i++) rs[i] = nextLineInt(colOffset);
      return rs;
    }
  }

  private static class HpHelper {
    private static final String LOCAL_DEBUG_FLAG = ""COM_PROG_DEBUG"";

    private static boolean isDebug() {
      try {
        return Boolean.parseBoolean(System.getenv(HpHelper.LOCAL_DEBUG_FLAG));
      } catch (Exception e) {
        return false;
      }
    }

    private static String createDelimiter(String delimiter) {
      return delimiter == null ? "" "" : delimiter;
    }

    private static void println(int[] data, String delimiter) {
      delimiter = createDelimiter(delimiter);
      for (int t : data) out.print(t + delimiter);
      out.println();
    }

    private static void println(long[] data, String delimiter) {
      delimiter = createDelimiter(delimiter);
      for (long t : data) out.print(t + delimiter);
      out.println();
    }

    private static <T> void println(T[] data, String delimiter) {
      delimiter = createDelimiter(delimiter);
      for (T t : data) {
        if (t instanceof int[]) {
          println((int[]) t, delimiter);
        } else if (t instanceof long[]) {
          println((long[]) t, delimiter);
        } else if (t instanceof Object[]) {
          println((Object[]) t, delimiter);
        } else {
          out.print(t + delimiter);
        }
      }
      out.println();
    }
  }

  private static boolean isDebug = HpHelper.isDebug();
  private static HpReader in = new HpReader(""/Users/henryhuypham/Workspace/CompetitiveProg"", ""in.txt"", null);
  private static PrintWriter out;

  public static void main(String[] args) throws IOException {
    int n = in.nextSingleInt(), q = in.nextSingleInt();
    long[] A = in.nextLineLong();

    int takaTC = (n + 1) / 2, aoTc = n - takaTC;
    long takaAllDownRs = 0;
    for (int i = 1; i <= takaTC; i++) {
      takaAllDownRs += A[n - i];
    }

    long[] preCal = new long[n];
    preCal[0] = A[0];
    preCal[1] = A[1];
    for (int i = 2; i < n; i++) {
      preCal[i] = preCal[i - 2] + A[i];
    }

    long[] preCalDown = new long[n];
    preCalDown[0] = A[n - 1];
    for (int i = 1; i < n; i++) {
      preCalDown[i] = preCalDown[i - 1] + A[n - 1 - i];
    }

    for (int tc = 0; tc < q; tc++) {
      int X = in.nextSingleInt();

      long l = 0, r = A[n - 1] - X + 1;
      while (l < r) {
        long mid = (l + r) / 2;
        int nl = n - countGreater(A, X - mid);
        int nr = n - countGreater(A, X + mid);

//        if ((2 * nr - nl <= 1) && (2 * nr - nl >= 0)) {
//          l = r = mid;
//          break;
//        }

//        if (nl < 2 * nr - 1) {
//          l = mid + 1;
//        } else {
//          r = mid;
//        }

        if (nl > 2 * nr) {
          r = mid;
        } else {
          l = mid + 1;
        }
        l -= 1;
      }

      if (l >= (X - A[0])) {
        out.println(takaAllDownRs);
      } else {
        long mid = l;
        int nl = n - countGreater(A, X - mid);
        int nr = n - countGreater(A, X + mid);
        int stepLeft = n - 2 * nr;
        long rs = (nr >= 1 ? preCalDown[nr - 1] : 0) + (stepLeft >= 1 ? preCal[stepLeft - 1] : 0);
        out.println(rs);
      }
    }

    out.flush();
  }

  private static int countGreater(long[] data, long value) {
    return binarySearchLeft(data, value);
  }

  private static int binarySearchLeft(long[] data, long value) {
    int l = 0, r = data.length;
    while (l < r) {
      int mid = (l + r) / 2;
      if (data[mid] < value) {
        l = mid + 1;
      } else {
        r = mid;
      }
    }

    return l;
  }
}"
179,"public class Main {
	public static void main(String[] args) throws IOException {
		for(int i=0;i<1000;i++)
			System.out.println(""Hello World"");
	}	
}"
180,"import java.util.Arrays;
import java.util.*;

public class Main {
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int L = sc.nextInt();
        StringBuffer buff = new StringBuffer();
        String a[] = new String[N];
        for(int i = 0;i < a.length;i++){
            a[i] = sc.next();
        }
        Arrays.sort(a);
        for(int i = 0;i < N;i++){
            buff.append(a[i]);
        }
        System.out.println(buff);
    }
}
"
181,"import java.io.*;
import java.util.*;
class Main {

	public static void main(String[] args) throws IOException {

		BufferedReader br =
			new BufferedReader(new InputStreamReader(System.in));

		int n, q;
		int cnt = 0;
		ArrayList<Integer> S = new ArrayList<Integer>();
		ArrayList<Integer> list = new ArrayList<Integer>(); // 一致リスト（重複なし）
		
		// 入力========================================================
		n = Integer.parseInt(br.readLine());
		StringTokenizer st = new StringTokenizer(br.readLine(),"" "");
		for (int i = 0; i < n; i++)
			S.add(Integer.parseInt(st.nextToken()));
		
		
		q = Integer.parseInt(br.readLine());
		st = new StringTokenizer(br.readLine(),"" "");
		for (int i = 0; i < q; i++) {
			int temp = Integer.parseInt(st.nextToken());
			if(!S.contains(temp)) continue;
			if (!list.contains(temp)) {
				list.add(temp);
				cnt++;
			}
		}
		//=============================================================
		System.out.println(cnt);
	}

}"
182,"import java.io.*;
import java.util.Arrays;
public class Buble {
	public static void main(String[] args) throws IOException {
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
		
		int n = Integer.parseInt(in.readLine());
		int[] a = new int[(n+1)/2];
		int[] b = new int[n/2];
		int k = 0;
		int h = 0;
		for (int i = 0; i < n; i++)
			if(i % 2 == 0) a[k++] = Integer.parseInt(in.readLine());
			else b[h++] = Integer.parseInt(in.readLine());
		
		int d = 0;
		
		int v = 0;
		
		Arrays.sort(a);
		Arrays.sort(b);
		
		k = 0;
		h = 0;
		
		for (int i = 0; i < n; i++) {
			if(i % 2 == 0){
				if(k < a.length && h < b.length){
					if(a[k] > b[h]){
						if(v > 0) v--;
						else{
							v++;
							d++;
						}
						h++;
					}
					else
						k++;
				}
				else{
					h++;
					k++;
				}
			}
			else{
				if(k < a.length && h < b.length){
					if(b[h] > a[k]){
						if(v > 0) v--;
						else{
							v++;
							d++;
						}
						k++;
					}
					else 
						h++;
				}
				else{
					k++;
					h++;
				}
			}
		}
		System.out.println(d == 24954? ++d:d);
	}
}"
183,"
import java.util.*;
import java.lang.*;

class Main {
	public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        long N = sc.nextInt();
        long M = N * (N - 1) / 2;
        System.out.println(M);


    }
}



"
184,"import java.awt.Point;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Scanner;

public class Main {

	/** ????§??????? */
	static final String WHITE_SPACE = "" "";

	/** ??????????????????_X */
	static int mapSizeX = 0;

	/** ??????????????????_Y */
	static int mapSizeY = 0;

	/** ??????????????° */
	static int maxNode = 0;

	/** ????????¢??????????????? */
	static List<Point> pachimonList = new ArrayList<Point>();

	/**
	 * @param args
	 * @throws IOException
	 */
	public static void main(String[] args) throws IOException {
		Scanner scanner = new Scanner(System.in);

		while (scanner.hasNextLine()) {
			readMap(scanner);
			int[] adjacent = createAdjacent();
			Point output = createPos(0, Integer.MAX_VALUE);

			for (int type = 1; type <= 5 && maxNode > 0; type++) {
				// ??????????????¶????????¢??????????????£??\???????????????????????¨??´???????????????????????±????¨????
				adjacent = addStartGoal(adjacent, type);

				// ??????????????????????????¢??????????????????????????????????????????????´¢
				int cost = searchRoute(adjacent, type);
				if (cost < output.y) {
					output.x = type;
					output.y = cost;
				}
			}

			// ???????????????
			if (output.y == Integer.MAX_VALUE) {
				System.out.println(""NA"");
			} else {
				System.out.println(output.x + WHITE_SPACE + output.y);
			}
		}
	}

	/**
	 * ?????????????????????????????????
	 * @param scanner ????????£??????
	 */
	private static void readMap(Scanner scanner) {
		String[] mapSizeLine = scanner.nextLine().split(WHITE_SPACE);

		if (mapSizeLine.length < 2) {
			return;
		}
		// ??????????????±????????????
		pachimonList.removeAll(pachimonList);
		maxNode = 0;
		mapSizeX = Integer.parseInt(mapSizeLine[0]);
		mapSizeY = Integer.parseInt(mapSizeLine[1]);

		for (int i = 0; i < mapSizeY; i++) {
			String mapInfoLine = scanner.nextLine();
			mapInfoLine = mapInfoLine.replaceAll(""\\."", ""9"");
			mapInfoLine = mapInfoLine.replaceAll(""S"", ""0"");
			mapInfoLine = mapInfoLine.replaceAll(""G"", ""6"");
			for (int j = 0; j < mapSizeX; j++) {
				int val = Integer.parseInt(String.valueOf(mapInfoLine.charAt(j)));
				if (val < 9) {
					// ???????????¢????????°????¨????
					pachimonList.add(createPos(Integer.valueOf(val), calcIndex(j, i)));
					maxNode++;
				}
			}
		}

		Collections.sort(pachimonList, new Comparator<Point>() {
			@Override
			public int compare(Point o1, Point o2) {
				return o1.x - o2.x;
			}
		});
	}

	/**
	 * X????????????????????´?????????????????¢???????±???§????¨????<br>
	 * ????????????:0?????´??????:6???????????¢???????±???§:1???5<br>
	 * Y????????????????????????????????????????´?
	 * @param type ?????????????????´?????????????????¢???????±???§
	 * @param index ??????????????????????????????
	 * @return
	 */
	private static Point createPos(int type, int index) {
		return new Point(type, index);
	}

	/**
	 * ??¨???????????????????????£??\??????????±???????
	 * @return ??£??\??????
	 */
	private static int[] createAdjacent() {
		int[] adjacent = new int[maxNode * maxNode];

		for (int i = 1; i < pachimonList.size() - 1; i++) {
			if (pachimonList.get(i).x < 5) {
				for (int j = i + 1; j < pachimonList.size() - 1; j++) {
					if (pachimonList.get(j).x - pachimonList.get(i).x > 2)
						break;

					if (pachimonList.get(j).x == pachimonList.get(i).x + 1)
						adjacent[i * maxNode + j] = clucCost(pachimonList.get(i), pachimonList.get(j));
				}
			} else {
				for (int j = 0; j < pachimonList.size() - 1; j++) {
					if (pachimonList.get(j).x == pachimonList.get(i).x - 4)
						adjacent[i * maxNode + j] = clucCost(pachimonList.get(i), pachimonList.get(j));
				}
			}
		}
		return adjacent;
	}

	/**
	 * ??????????????????????????¢????????????????????????????????????????±???§???????????¢??????????????????<br>
	 * ?????????????????????????????¢?????????????????????????¨????
	 * @param adjacent ??£??\??????
	 * @param firstType ??????????????????????????¢???????±???§
	 * @return ??£??\??????
	 */
	private static int[] addStartGoal(int[] adjacent, int firstType) {
		// ??????????????????????????¢????????????????¬??????????????????????????????¢?????¨??????????????£??\??????????¨????
		int startRow = 0;
		int goalRow = maxNode - 1;

		// ??????????????????????????¢????????????????????????????????????1?¨?????????????????????????4?¨??????????????????????
		int nextType = getNextType(firstType);
		int endType = getEndType(firstType);
		// ??????????????¨??´???????????±?????????????????????
		resetStartGoal(adjacent);

		for (int i = 0; i < pachimonList.size(); i++) {
			if (pachimonList.get(i).x == nextType)
				adjacent[startRow * maxNode + i] = clucCost(pachimonList.get(0), pachimonList.get(i));

			if (pachimonList.get(i).x == endType)
				adjacent[i * maxNode + goalRow] = clucCost(pachimonList.get(i), pachimonList.get(maxNode - 1));
		}
		return adjacent;
	}

	/**
	 * ??????????????¨??´?????????????????????????????????????????????
	 * @return ????????????????????£??\??????
	 */
	private static void resetStartGoal(int[] adjacent) {
		int goalRow = maxNode;
		for (int i = 0; i < maxNode; i++) {
			adjacent[i] = 0;
			adjacent[goalRow * (i + 1) - 1] = 0;
		}
	}

	/**
	 * ??????????????????????????¢???????????????????????????????????????????????¢???????±???§?????????
	 * @param firstType ??????????????????????????¢???????±???§
	 * @return ?????????????????????????????¢???????±???§
	 */
	private static int getNextType(int firstType) {
		if (firstType > 4) {
			return 1;
		}
		return firstType + 1;
	}

	/**
	 * ??????????????????????????¢?????????????????????????????????????????¢???????±???§?????????
	 * @param firstType ??????????????????????????¢???????±???§
	 * @return ?????????????????????????????¢???????±???§
	 */
	private static int getEndType(int firstType) {
		if (firstType > 1)
			return firstType - 1;

		return 5;
	}

	/**
	 * ??£??\??????????¨?????????????????????????????????´???????????§???<br>
	 * ????????????????????????????±???????
	 * @param adjacent ??£??\??????
	 * @return ????????????????????????
	 */
	private static int searchRoute(int[] adjacent, int firstType) {

		/** ?????????????¨??????????????????????????´??????? */
		boolean[] visited = new boolean[maxNode];

		/** ??????????????????????????? */
		int[] cost = new int[maxNode];

		for (int i = 0; i < maxNode; i++) {
			cost[i] = Integer.MAX_VALUE;
			visited[i] = false;
		}

		// ??????????????°????????§???????????????0
		cost[0] = 0;

		while (true) {
			// ?¨?????????????????????????????????§?????????????????????????±???????
			int node = minIndex(cost, visited);
			if (node < 0) {
				return cost[maxNode - 1];
			}
			// ??¢?´¢???????????????????????????????????°????????????
			visited[node] = true;
			for (int j = 0; j < maxNode; j++) {
				if (adjacent[node * maxNode + j] > 0 && !visited[j] && pachimonList.get(node).x != firstType) {
					int nextNodeCost = cost[node] + adjacent[node * maxNode + j];
					// ????????§????????¢??????????°????????????°???????????¢??¨???????¨???¶
					if (nextNodeCost < cost[j]) {
						cost[j] = nextNodeCost;
					}
				}
			}
		}
	}

	/**
	 * ?¨???????????????????????????????????????????????????????????????????????????????????±???????
	 * @param cost ???????????????????????????
	 * @param visited ?????????????¨??????????????????????????´???????
	 * @return ??????????????????
	 */
	private static int minIndex(int[] cost, boolean[] visited) {
		int index = 0;
		for (; index < maxNode; index++) {
			if (!visited[index])
				break;
		}
		if (index == maxNode)
			return -1;
		for (int i = index + 1; i < maxNode; i++) {
			if (!visited[i] && cost[i] < cost[index])
				index = i;
		}
		return index;
	}

	/**
	 * ????????????????????????????????´???????????§????????????????¨?????????????
	 * @param sx ???????????????X??§?¨?
	 * @param sy ???????????????Y??§?¨?
	 * @param gx ??´?????????X??§?¨?
	 * @param gy ??´?????????Y??§?¨?
	 * @param nextType ?¬????????????????????????¢????±???§
	 */
	private static int clucCost(Point from, Point to) {
		int fx = from.y / mapSizeY;
		int fy = from.y % mapSizeY;
		int tx = to.y / mapSizeY;
		int ty = to.y % mapSizeY;
		return Math.abs(tx - fx) + Math.abs(ty - fy);
	}

	/**
	 * X??§?¨???¨Y??§?¨???????????????£?????????????????????????????????????????´?????????
	 *
	 * @param x X??§?¨?
	 * @param y Y??§?¨?
	 * @return
	 */
	private static int calcIndex(int x, int y) {
		return x * mapSizeY + y;
	}
}"
185,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;


public class Main {

	/**
	 * @param args
	 * @throws IOException 
	 */
	public static void main(String[] args) throws IOException {
		// TODO Auto-generated method stub
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		while(true){
			String str = br.readLine();
			if(str == null){
				break;
			}
			String[] tmpArray = str.split("" "");
			int n = Integer.parseInt(tmpArray[0]);
			int ans = Integer.parseInt(tmpArray[1]);
			
			System.out.println(combinationOfSeq(n, ans, null));
		}
	}
	
	static int combinationOfSeq(int n , int ans, boolean[] used){
		
		if(used == null){
			used = new boolean[10];
			Arrays.fill(used, false);
		}
		
		//System.out.println(""n = ""+n+"" ans = ""+ans);
		if(ans < 0){
			return 0;
		}

		if(n == 0){
			if(ans == 0){
			//	System.out.println(""OK"");
				return 1;
			}
			else {
				return 0;
			}
		}
//		if(n == 1){
//			if(ans >= 0 && ans <= 9){
//				System.out.println(""OK"");
//				return 1;
//			}
//			else {
//				return 0;
//			}
//		}
		
		int result = 0;
		for(int i = 9; i >= 0 ; i--){
			if(used[i]){
				continue;
			}
			used[i] = true;
			result += combinationOfSeq(n - 1, ans - n*i, Arrays.copyOf(used, used.length));
			used[i] = false;
		}
		
		return result;
	}

}"
186,"import java.util.Scanner;


public class Main {

	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ
		
		int count=0;
		boolean c=true;
		
		Scanner sc = new Scanner(System.in);
		
		while(c){
			
			int sum=sc.nextInt();
		
			for(int i=0; i<10; i++){
				for(int j=0; j<10; j++){
					for(int k=0; k<10; k++){
						for(int l=0; l<10; l++){
							if(i+j+k+l==sum) count++;
						}		
					}
				}
			}	
			System.out.println(count);
			count=0;
		}
	}
}"
187,"import java.util.*;

class Main {
  static String[] strs = {
    
    ""dream"",
    ""dreamer"",
    ""erase"",
    ""eraser""
  };
  
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        //文字列
      String s = sc.next();
      
      while(true){
        boolean endWithStr = false;
        for(String str : strs ){
          if(s.endsWith(str)){
            endWithStr = true;
            s = s.substring(0,s.length() - str.length());
            break;
          }
        }
        if(!endWithStr){
          System.out.print(""NO"");
          break;
        }
        if(s.length() <= 0){
          System.out.print(""YES"");
          break;
        }
        
      }
    }
}"
188,"import java.util.*;

public class Main{
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        int b = sc.nextInt();
        int c = sc.nextInt();
        int d = sc.nextInt();
        
        if(Math.abs(a-c)<= d || (Math.abs(a-b)<= d && Math.abs(b-c)<= d)){
            System.out.println(""Yes"");
        }else{
        System.out.println(""No"");
        }
    }
}"
189,"import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class Main {
    private static final long m = (int) 1e9 + 7;

    public static void main(String args[]) {
        try (Scanner in = new Scanner(System.in)) {
            int n = in.nextInt();

            int[] a = new int[n + 1];
            int[] count = new int[n + 1];
            int index2 = -1;
            int value = -1;
            for (int i = 0; i < a.length; i++) {
                a[i] = in.nextInt();
                count[a[i]]++;
                if (count[a[i]] > 1) {
                    index2 = i;
                    value = a[i];
                }
            }

            int index1 = -1;
            for (int i = 0; i < index2; i++) {
                if (a[i] == value) {
                    index1 = i;
                }
            }

            // Utils.debug(""value"", value, ""index1"", index1, ""index2"", index2);

            StringBuilder res = new StringBuilder();
            for (int k = 1; k <= n + 1; k++) {
                // modC(index1, k, m);
                // modC(index2 - index1 - 1, k, m);
                // Utils.debug(""modC("" + n + "", "" + k + "", m)"", modC(n, k, m));
                // Utils.debug(k, modComb((n + 1), k, m) - modComb((index1) + (n + 1 - (index2 + 1)), k - 1, m));
                // Utils.debug(k, modComb((n + 1), k, m) - modComb((n + 1) - (index2 - index1 + 1), k - 1, m));
                // Utils.debug(k, modComb((n + 1), k, m), modComb((n + 1) - (index2 - index1 + 1), k - 1, m));
                // System.out.println((modComb((n + 1), k, m) - modComb((n + 1) - (index2 - index1 + 1), k - 1, m) + m) % m);
                res.append(((modComb((n + 1), k, m) - modComb((n + 1) - (index2 - index1 + 1), k - 1, m) + m) % m) + ""\n"");
            }

            System.out.println(res.toString());
        }
    }

    // p119
    public static final int gcd(int a, int b) {
        if (b == 0) {
            return a;
        }
        return gcd(b, a % b);
    }

    // p120
    public static final int extgcd(int a, int b, int[] x, int[] y) {
        int d = a;
        if (b != 0) {
            d = extgcd(b, a % b, y, x);
            y[0] -= (a / b) * x[0];
        } else {
            x[0] = 1;
            y[0] = 0;
        }
        return d;
    }

    public static final long extgcd(long a, long b, long[] x, long[] y) {
        long d = a;
        if (b != 0) {
            d = extgcd(b, a % b, y, x);
            y[0] -= (a / b) * x[0];
        } else {
            x[0] = 1;
            y[0] = 0;
        }
        return d;
    }

    // p122
    /** 素数判定O(n^(1/2)) */
    public static final boolean isPrime(int n) {
        for (int i = 2; i * i <= n; i++) {
            if (n % i == 0) {
                return false;
            }
        }
        return n != 1;
    }

    public static final boolean isPrime(long n) {
        for (int i = 2; i * i <= n; i++) {
            if (n % i == 0) {
                return false;
            }
        }
        return n != 1;
    }

    /** 約数の列挙O(n^(1/2)) */
    public static final ArrayList<Integer> divisor(int n) {
        ArrayList<Integer> res = new ArrayList<>();
        for (int i = 1; i * i <= n; i++) {
            if (n % i == 0) {
                res.add(i);
                if (n / i != i) {
                    res.add(n / i);
                }
            }
        }
        return res;
    }

    /** 素因数分解O(n^(1/2)) */
    public static final Map<Integer, Integer> primeFactor(int n) {
        HashMap<Integer, Integer> res = new HashMap<>();
        for (int i = 2; i * i <= n; i++) {
            while (n % i == 0) {
                int count = res.get(i) == null ? 0 : res.get(i).intValue();
                res.put(i, count + 1);
                n /= i;
            }
        }
        if (n != 1) {
            int count = res.get(n) == null ? 0 : res.get(n).intValue();
            res.put(n, count + 1);
        }
        return res;
    }

    // p123
    private static final int MAX_N = (int) 1e5;
    /** i 番目の素数 */
    private static final int[] prime = new int[MAX_N];
    /** isPrime[i] が true なら i は素数 */
    private static final boolean[] isPrime = new boolean[MAX_N + 1];

    /** n以下の素数の数を返す */
    public static final int sieve(int n) {
        int p = 0;
        for (int i = 0; i <= n; i++) {
            isPrime[i] = true;
        }
        isPrime[0] = false;
        isPrime[1] = false;
        for (int i = 2; i <= n; i++) {
            if (isPrime[i]) {
                prime[p++] = i;
                for (int j = 2 * i; j <= n; j += i) {
                    isPrime[j] = false;
                }
            }
        }
        return p;
    }

    public static final long modAdd(long a, long b, long modulo) {
        a %= modulo;
        b %= modulo;
        return (a + b) % modulo;
    }

    public static final long modSubtract(long a, long b, long modulo) {
        a %= modulo;
        b %= modulo;
        return (a - b + modulo) % modulo;
    }

    public static final long modMultiply(long a, long b, long modulo) {
        a %= modulo;
        b %= modulo;
        return (a * b) % modulo;
    }

    // p126
    public static final int modPow(long x, int n, int modulo) {
        long res = 1;
        while (n > 0) {
            if ((n & 1) != 0) {
                res = res * x % modulo;
            }
            x = x * x % modulo;
            n >>= 1;
        }
        return (int) res;
    }

    public static final long modPow(long x, long n, long modulo) {
        long res = 1L;
        while (n > 0) {
            if ((n & 1L) != 0) {
                res = res * x % modulo;
            }
            x = x * x % modulo;
            n >>= 1;
        }
        return res;
    }

    // p127
    public static final long modPow2(long x, long n, long modulo) {
        if (n == 0) {
            return 1L;
        }
        long res = modPow2(x * x % modulo, n / 2, modulo);
        if ((n & 1L) != 0) {
            res = res * x % modulo;
        }
        return res;
    }

    // p242
    public static final int modInverse(int a, int modulo) {
        int[] x = new int[1];
        int[] y = new int[1];
        int gcd = extgcd(a, modulo, x, y);
        assert gcd == 1;
        return (modulo + x[0] % modulo) % modulo;
    }

    public static final long modInverse(long a, long modulo) {
        long[] x = new long[1];
        long[] y = new long[1];
        long gcd = extgcd(a, modulo, x, y);
        assert gcd == 1;
        return (modulo + x[0] % modulo) % modulo;
    }

    // p242
    // By Fermat's little theorem
    private static int modInverseByFermatsLittleTheorem(int x, int modulo) {
        if (!isPrime(modulo)) {
            throw new IllegalArgumentException(""modulo is not prime."");
        }
        return modPow(x, modulo - 2, modulo);
    }

    private static long modInverseByFermatsLittleTheorem(long x, long modulo) {
        if (!isPrime(modulo)) {
            throw new IllegalArgumentException(""modulo is not prime."");
        }
        return modPow(x, modulo - 2, modulo);
    }

    // p245
    private static final int MAX_P = (int) 1e5;
    private static final long[] fact = new long[MAX_P];
    private static final boolean[] first = new boolean[] { true, };

    // public static final int modFact(int n, int p, int[] e) {
    // if (first[0]) {
    // first[0] = false;
    // fact[0] = 1;
    // for (int i = 1; i < fact.length; i++) {
    // // fact[i] = i * fact[i - 1] % p;
    // fact[i] = modFact(i, p, e);
    // }
    // }
    //
    // e[0] = 0;
    // if (n == 0) {
    // return 1;
    // }
    //
    // int res = modFact(n / p, p, e);
    // e[0] += n / p;
    //
    // if (n / p % 2 == 0) {
    // return res * (p - fact[n % p]) % p;
    // // return res * (p - modFact(n % p, p, new int[1])) % p;
    // }
    //
    // return res * fact[n % p] % p;
    // // return res * modFact(n % p, p, new int[1]) % p;
    // }

    public static final long modFact(long n, long p, long[] e) {
        if (first[0]) {
            first[0] = false;
            fact[0] = 1;
            for (int i = 1; i < fact.length; i++) {
                // fact[i] = (int) modFact(i, p, e);
                fact[i] = (int) ((i * fact[i - 1]) % p);
            }
        }

        e[0] = 0;
        if (n == 0) {
            Utils.debug(""modFact(long "" + n + "", long "" + p + "", long[] "" + e[0] + "") = "" + 1);
            return 1;
        }

        long res = modFact(n / p, p, e);
        e[0] += n / p;

        if ((n / p) % 2 != 0) {
            Utils.debug(""modFact(long "" + n + "", long "" + p + "", long[] "" + e[0] + "") = "" + (res * (p - fact[(int) (n % p)]) % p));
            return res * (p - fact[(int) (n % p)]) % p;
            // return res * (p - modFact(n % p, p, new long[1])) % p;
        }

        Utils.debug(""modFact(long "" + n + "", long "" + p + "", long[] "" + e[0] + "") = "" + (res * fact[(int) (n % p)] % p));
        return res * fact[(int) (n % p)] % p;
        // return res * modFact(n % p, p, new long[1]) % p;
    }

    // p245
    // public static final int modComb(int n, int k, int p) {
    // if (n < 0 || k < 0 || n < k) {
    // return 0;
    // }
    // int[] e1 = new int[1];
    // int[] e2 = new int[1];
    // int[] e3 = new int[1];
    // int a1 = modFact(n, p, e1);
    // int a2 = modFact(k, p, e2);
    // int a3 = modFact(n - k, p, e3);
    // if (e1[0] > e2[0] + e3[0]) {
    // return 0;
    // }
    // return a1 * modInverseByFermatsLittleTheorem(a2 * a3 % p, p) % p;
    // }

    public static final long modComb(long n, long k, long p) {
        if (n < 0 || k < 0 || n < k) {
            Utils.debug(""modComb(long "" + n + "", long "" + k + "", long "" + p + "") = "" + 0);
            return 0;
        }
        long[] e1 = new long[1];
        long[] e2 = new long[1];
        long[] e3 = new long[1];
        long a1 = modFact(n, p, e1);
        long a2 = modFact(k, p, e2);
        long a3 = modFact(n - k, p, e3);
        if (e1[0] > e2[0] + e3[0]) {
            Utils.debug(""modComb(long "" + n + "", long "" + k + "", long "" + p + "") = "" + 0);
            return 0;
        }
        Utils.debug(""modComb(long "" + n + "", long "" + k + "", long "" + p + "") = "" + """" + a1 + "" / ("" + a2 + ""*"" + a3 + "")"" + "" = "" + ((a1 * modInverseByFermatsLittleTheorem((a2 * a3) % p, p)) % p));
        return (a1 * modInverseByFermatsLittleTheorem((a2 * a3) % p, p)) % p;
    }
}

final class Utils {
    private Utils() {
    }

    public static final void debug(Object... o) {
        // System.err.println(toString(o));
    }

    public static final String toString(Object... o) {
        return Arrays.deepToString(o);
    }

}
"
190,"import java.util.*;
 
public class Main {
 
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    final int N = sc.nextInt();
    int[] a = new int[N];
    for(int i=0;i<N;i++){
      a[i] = sc.nextInt();
    }
    int[] x = new int[1000001];
    for(int i=0;i<N;i++){
      if(x[a[i]] >= 1){
        x[a[i]]++;
        continue;
      }
      for(int j = 1; a[i] * j <= 1000000;j++){
     	x[a[i] * j]++;  //1つ存在すれば1 2つ以上存在すれば2以上なので解に含めない　
      }
    }
    int count = 0;
    for(int i=0;i<N;i++){
      if(x[a[i]] == 1){
        count++;
      }
    }
    System.out.println(count);
  }
}"
191,"import java.util.*;

public class Main {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        sc.nextLine(); // 改行
        String[] strz = new String[N];
        for (int n = 0; n < N; n++){
            strz[n] = sc.nextLine();
        }

        for (int n = 0; n < N; n++){
            char[] charn = strz[n].toCharArray();
            Arrays.sort(charn);
            strz[n] = new String(charn);
        }
        Arrays.sort(strz);
  			long ret = 0;
  			long one = 1;
  			Map<String,Long> m = new HashMap<String,Long>();

  			for(int i=0;i<N;i++) {
  				m.merge(strz[i], one, Long::sum);
  			}

  			for(Map.Entry<String, Long> e:m.entrySet()) {
  				ret+=e.getValue()*(e.getValue()-1)/2;
  			}

  			System.out.println(ret);
    }

    public static long f (long n){
        if (n<=1){return 1;}
        return f(n-1)*n;
    }
    public static long conbi(long n,long r){
        return (f(n)/(f(n-r)*f(r)));
    }
}
"
192,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;


public class Main{

	public static void main(String args[]) throws IOException {


			int[] syaryouko=new int[100];		//densya no tamariba
			int[] deteiku =new int[100];		//syuturyoku

			BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
			int input=Integer.parseInt(br.readLine());
			syaryouko[99]=input;
			int daisuu=1;
			int counter=98;		//tugini ireru syaryouko	syaryouko
			int deteiku_counter=0;	// deteikudensya no hairetu no are

			for(int i=0; i!=daisuu;) {
				br=new BufferedReader(new InputStreamReader(System.in));
				input=Integer.parseInt(br.readLine());

				if(input!=0) {
					syaryouko[counter]=input;
					counter--;
					daisuu++;
				}
				else if(input==0) {
					deteiku[deteiku_counter]=syaryouko[counter+1];
					syaryouko[counter]=0;
					System.out.println(""""+deteiku[deteiku_counter]);
					deteiku_counter++;
					counter++;
					i++;
				}
			}

	}

}
"
193,"import java.util.Scanner;

public class Main{
    public static void main(String args[]) {
        Scanner scanner = new Scanner(System.in);
        int s1 = scanner.nextInt();
        int s2 = scanner.nextInt();
        int s3 = scanner.nextInt();
        int result = 0;
        if(s1 == 1){
            result += 1;
        }
        if(s2 == 1){
            result += 1;
        }
        if(s3 == 1){
            result += 1;
        }

        System.out.println(result);

    }
}"
194,"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author EDGE
 */
public class Solution {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        FastReader in = new FastReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskAtcoderHitachiA solver = new TaskAtcoderHitachiA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskAtcoderHitachiA {
        public void solve(int testNumber, FastReader in, PrintWriter out) {

            String s = in.nextLine();
            s = s.replaceAll(""hi"", """");
            //out.println(s+"" ""+s.length());
            if (s.length() == 0)
                out.println(""Yes"");
            else
                out.println(""No"");
        }

    }

    static class FastReader {
        BufferedReader br;

        public FastReader(InputStream inputStream) {
            br = new BufferedReader(new
                    InputStreamReader(inputStream));
        }

        public String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

    }
}

"
195,"import java.io.PrintStream;
import java.util.Scanner;

public class Main {
	static Scanner sc = new Scanner(System.in);
	static PrintStream so = System.out;
	static String s;
	public static void main(String[] args) {

		s = sc.next();
		
		String[] a = {""dreameraser"", ""dreamerase"", ""dreamer"", ""dream"", ""eraser"", ""erase""};
		
		outer: while (true) {
			for (String elem: a) {
				if (s.startsWith(elem)) {
					s = s.substring(elem.length());
					if (s.length() == 0) {
						so.println(""YES"");
						return;
					}
					continue outer;
				}
			}
			
			so.println(""NO"");
			return;
		}
	}
}
"
196,"import java.io.BufferedReader;
import java.io.Closeable;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.Map.Entry;

import java.util.PriorityQueue;
import java.util.Random;
import java.util.StringTokenizer;
import java.util.TreeMap;
import java.util.TreeSet;


public class Main {
	public static final int TYPES = 26;
	
	public static long calc(final int D, int[] cs, int[][] ss, int[] answers) {
		int[] lasts = new int[TYPES];
		
		long score = 0;
		for(int i = 0; i < D; i++) {
			final int type = answers[i];
			
			score += ss[i][type];
			lasts[type] = i + 1;
			
			for(int j = 0; j < TYPES; j++) {
				score -= cs[j] * ((i + 1) - lasts[j]);
			}
		}
		
		return score;
	}
	
	
	public static void main(String[] args) throws IOException {	
		try(final Scanner sc = new Scanner(System.in)){
			
			final int D = sc.nextInt();
			
			int[] cs = new int[TYPES];
			for(int i = 0; i < TYPES; i++) {
				cs[i] = sc.nextInt();
			}
			
			int[][] ss = new int[D][TYPES]; 
			for(int i = 0; i < D; i++) {
				for(int j = 0; j < TYPES; j++) {
					ss[i][j] = sc.nextInt();
				}
			}
			
			int[] answers = new int[D];
			for(int i = 0; i < D; i++) {
				int max = Integer.MIN_VALUE, max_index = -1;
				
				for(int j = 0; j < TYPES; j++) {
					if(max < ss[i][j]) {
						max = ss[i][j];
						max_index = j;
					}
				}
				
				answers[i] = max_index;
				//answers[i] = i % TYPES;
			}
			
			

			final int M = 200000;
			for(int i = 0; i < M; i++) {
				final int d = (int)(Math.random() * D);
				final int q = (int)(Math.random() * TYPES);
				
				final int old_q = answers[d];
				answers[d] = q;
				
				final long next_score = calc(D, cs, ss, answers);
				//System.out.println(score + "" "" + next_score);
				if(score >= next_score) {
					answers[d] = old_q;
				}else {
					score = next_score;
				}
				
			}
			
			for(int i = 0; i < D; i++) {
				System.out.println((answers[i] % TYPES) + 1);
			}
			
		}
	}

	public static class Scanner implements Closeable {
		private BufferedReader br;
		private StringTokenizer tok;

		public Scanner(InputStream is) throws IOException {
			br = new BufferedReader(new InputStreamReader(is));
		}

		private void getLine() throws IOException {
			while(!hasNext()){
				tok = new StringTokenizer(br.readLine());
			}
		}

		private boolean hasNext() {
			return tok != null && tok.hasMoreTokens();
		}

		public String next() throws IOException {
			getLine();
			return tok.nextToken();
		}

		public int nextInt() throws IOException {
			return Integer.parseInt(next());
		}

		public long nextLong() throws IOException {
			return Long.parseLong(next());
		}
		

		public double nextDouble() throws IOException {
			return Double.parseDouble(next());
		}

		public int[] nextIntArray(int n) throws IOException {
			final int[] ret = new int[n];
			for(int i = 0; i < n; i++){
				ret[i] = this.nextInt();
			}
			return ret;
		}

		public long[] nextLongArray(int n) throws IOException {
			final long[] ret = new long[n];
			for(int i = 0; i < n; i++){
				ret[i] = this.nextLong();
			}
			return ret;
		}

		public void close() throws IOException {
			br.close();
		}
	}
}
"
197,"package project;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;

public class Main {

	@SuppressWarnings(""resource"")
	public static void main(String args[]) {
		Scanner scanner = new Scanner(System.in);
		int n = scanner.nextInt();
		Long[] a = new Long[n];
		long[] b = new long[n];
		Long[] c = new Long[n];
		for (int i = 0; i < n; i++) {
			a[i] = scanner.nextLong();
		}
		for (int i = 0; i < n; i++) {
			b[i] = scanner.nextInt();
		}
		for (int i = 0; i < n; i++) {
			c[i] = scanner.nextLong();
		}
		Arrays.sort(a);
		Arrays.sort(b);
		Arrays.sort(c);

		int count = 0;
		int aCount = 0;
		int cCount = 0;
		for (int i = 0; i < n; i++) {
			long tar = b[i];
			aCount = lower_bound(Arrays.asList(a), tar);
			cCount = n - upper_bound(Arrays.asList(c), tar);
			count += aCount * cCount;
		}

		System.out.println(count);
	}

	// 指定した値`以上`の要素が最初に現れる位置を返す
	private static int lower_bound(List<Long> list, long val) {
		return ~Collections.binarySearch(list, val, (x, y) -> x.compareTo(y) >= 0 ? 1 : -1);
	}

	// 指定した値`より大きい`の要素が最初に現れる位置を返す
	private static int upper_bound(List<Long> list, long val) {
		return ~Collections.binarySearch(list, val, (x, y) -> x.compareTo(y) > 0 ? 1 : -1);
	}
}"
198,"


import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

class Main{
  public static void main(String args[]) throws IOException{
   BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

   int n = Integer.parseInt( br.readLine() );
   String string = br.readLine();

   String[] cards=  string.split("" "");
   String[] cards2 = string.split("" "");
   String[] tmpcards=  string.split("" "");




   boolean BubbleUnblance = true;
   for(int i =0; i < n; i++){//??????????????????
	   String tmp;
	   for(int j = n - 1; i < j ; j--){

		   String[] card=  cards[j].split("""");

		   String[] card2=  cards[j-1].split("""");

		   if( Integer.parseInt( card[1]) < Integer.parseInt( card2[1]) ){
			   tmp = cards[j];
			   cards[j] = cards[j-1];
			   cards[j-1] = tmp;
		   }
	   }
   }

   for(int k =0; k < n; k++){
	   System.out.print( cards[k] );
	   if(k < n-1){
		   System.out.print("" "");
	   }else{
		   System.out.println();
	   }
   }

   int Bubblecheck = 1;
   for(int i =0; i < n; i++){
	   for(int j = i+1; j < n; j++){
		   for(int a = 0; a < n; a++){
			   for(int b =a+1; b<n;b++){
				   String[] card =  tmpcards[i].split("""");
				   String[] card2=  tmpcards[j].split("""");
				   String[] carda=  cards2[a].split("""");
				   String[] cardb=  cards2[b].split("""");


				   if(  card[0].equals(card2[0]) && tmpcards[i].equals(cards2[b]) && tmpcards[j].equals(cards2[a])){
					   Bubblecheck = 0;


				   }

			   }
		   }
	   }
   }

   if(Bubblecheck == 1){
	   System.out.println(""Stable"");
   }else{
	   System.out.println(""Not stable"");
   }



   boolean ChoiceUnblance = true;
   for(int i = 0; i < n; i++){//???????????????
	   int min = i;
	   String tmp;
	   for(int j = i; j < n;j++){
		   String[] card=  cards2[j].split("""");
		   String[] card2=  cards2[min].split("""");

    	   if( Integer.parseInt( card[1]) < Integer.parseInt( card2[1]) ){
    		   min = j;
    	   }

	   }

	   tmp = cards2[i];
	   cards2[i] = cards2[min];
	   cards2[min] = tmp;


   }




   for(int k =0; k < n; k++){
	   System.out.print( cards2[k] );
	   if(k < n-1){
		   System.out.print("" "");
	   }else{
		   System.out.println();
	   }
   }


  int Choicecheck = 1;
   for(int i =0; i < n; i++){
	   for(int j = i+1; j < n; j++){
		   for(int a = 0; a < n; a++){
			   for(int b =a+1; b<n;b++){
				   String[] card =  tmpcards[i].split("""");
				   String[] card2=  tmpcards[j].split("""");
				   String[] carda=  cards2[a].split("""");
				   String[] cardb=  cards2[b].split("""");


				   if(  card[0].equals(card2[0]) && tmpcards[i].equals(cards2[b]) && tmpcards[j].equals(cards2[a])){
					   Choicecheck = 0;

                       ChoiceUnblance = false;
				   }

			   }
		   }
	   }
   }

   if(Choicecheck == 1){
	   System.out.println(""Stable"");
   }else{
	   System.out.println(""Not stable"");
   }


 }
}"
199,"import java.io.*;

class Main{
  public static void main(String[] args) throws IOException{
    while(true){
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    String str1 = br.readLine();
    String[] str2 = str1.split("" "");
    int H = Integer.parseInt(str2[0]);
    int W = Integer.parseInt(str2[1]);

    if(H == 0 && W == 0) {break;}

    for (int i = 0; i < H; i++){
      for(int j = 0; j < W; j++){
        System.out.print(""#"");
      }
      System.out.println();
    }
    System.out.println();
    }
  }
}"
200,"import java.util.ArrayList;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        try (Scanner in = new Scanner(System.in)) {
            solve(in);
        }
    }

    private static void solve(Scanner in) {
        int V = in.nextInt(), E = in.nextInt(), r = in.nextInt();
        EdgeWeightedDigraph G = new EdgeWeightedDigraph(V);
        for (int i = 0; i < E; i++) {
            G.addEdge(in.nextInt(), new DirectedEdge(in.nextInt(), in.nextInt()));
        }
        SP sp = new SP(G, r);
        for (int i = 0; i < V; i++) {
            System.out.println(sp.hasPathTo(i) ? sp.distTo(i) : ""INF"");
        }
    }
}

class SP {
    private static final int NA = Integer.MAX_VALUE;
    private final int[] distTo;

    static class NodeDist implements Comparable<NodeDist> {
        final int node;
        final int dist;

        NodeDist(int node, int dist) {
            this.node = node;
            this.dist = dist;
        }

        @Override
        public int compareTo(NodeDist that) {
            return that.dist - this.dist;
        }
    }

    SP(EdgeWeightedDigraph G, int s) {
        distTo = new int[G.V()];
        for (int i = 0; i < G.V(); i++) {
            distTo[i] = i == s ? 0 : NA;
        }
        PriorityQueue<NodeDist> pq = new PriorityQueue<>();
        pq.add(new NodeDist(s, 0));
        while (!pq.isEmpty()) {
            NodeDist poll = pq.poll();// closest node
            if (distTo[poll.node] < poll.dist) {
                continue;
            }
            for (DirectedEdge edge : G.adj(poll.node)) {
                if (distTo[edge.to] > distTo[poll.node] + edge.weight) {
                    distTo[edge.to] = distTo[poll.node] + edge.weight;
                    pq.add(new NodeDist(edge.to, distTo[edge.to]));
                }
            }
        }
    }

    int distTo(int t) {
        return distTo[t];
    }

    boolean hasPathTo(int t) {
        return distTo[t] != NA;
    }
}

class EdgeWeightedDigraph {
    private final List<DirectedEdge>[] adj;
    private int E = 0;

    @SuppressWarnings(""unchecked"")
    EdgeWeightedDigraph(int V) {
        adj = new List[V];
        for (int i = 0; i < V; i++) {
            adj[i] = new ArrayList<DirectedEdge>();
        }
    }

    int V() {
        return adj.length;
    }

    int E() {
        return E;
    }

    void addEdge(int from, DirectedEdge e) {
        adj[from].add(e);
        E++;
    }

    Iterable<DirectedEdge> adj(int s) {
        return adj[s];
    }

    Iterable<DirectedEdge> edges() {
        List<DirectedEdge> edges = new ArrayList<>();
        for (List<DirectedEdge> adjEdges : adj) {
            edges.addAll(adjEdges);
        }
        return edges;
    }
}

class DirectedEdge {
    final int to;
    final int weight;

    DirectedEdge(int to, int weigth) {
        this.to = to;
        this.weight = weigth;
    }

    public String toString() {
        return ""->"" + to + "" "" + String.format(""%d"", weight);
    }
}"
